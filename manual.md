![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.001.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.002.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.003.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.004.jpeg)**BES TWS**

**SOFTWARE DEVELOPMENT USER MANUAL**

**BES Confidential and Proprietary**

CONTACT US:

***Company:** Bestechnic (Shanghai) Co., Ltd. (“**BES**”)*

***Address:** Room 201, Tower B, Chamtime Plaza, Lane 2889 Jinke Road, Pudong New District, Shanghai 201203, China*

***Phone:** (86)21 6877 1788*

*For products inquires and more information, please visit [www.bestechnic.com](http://www.bestechnic.com/)[*.*](http://www.bestechnic.com/)*

DISCLAIMER:

*No part of this document may be reproduced or transmitted in any form or by any means, electronic or mechanical,*

*including photocopying and recording, for any purpose, without the express written permission of BES. BES retains the*

*right to make changes to this document at any time, without notice. BES makes no warranty of any kind, expressed or*

*implied, with regard to any information contained in this document, including, but not limited to, the implied warranties*

*of merchant ability or fitness for any particular purpose. Further, BES does not warrant the accuracy or completeness of*

*the information, text, graphics, or other items contained within this document.*





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.005.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Revision History**

The following table lists the technical content changes for all revisions.

**Revision Date Description**

0. ` `July 2022 Initial release
0. ` `April 2023 Made function names and order of sample code conisistant with those in code base;

included more detailed guidence for Software Development Environment Setup section;

grammatical and formatting editing

0. ` `May 2023 Updated prompt usage guide: add prompt in flash functionality

Rev 1.2 Page2 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Table of Contents**

[**List**](#br6)[** ](#br6)[of**](#br6)[** ](#br6)[Tables**](#br6)[.........................................................................................................................................................................](#br6)[ ](#br6)[6](#br6)

[**List**](#br8)[** ](#br8)[of**](#br8)[** ](#br8)[Figures**](#br8)[........................................................................................................................................................................](#br8)[ ](#br8)[8](#br8)

[**List**](#br12)[** ](#br12)[of**](#br12)[** ](#br12)[Sample**](#br12)[** ](#br12)[Code**](#br12)[............................................................................................................................................................](#br12)[ ](#br12)[12](#br12)

1. [](#br14)[** ](#br14)[General**](#br14)[** ](#br14)[Description**](#br14)[** ](#br14)[...................................................................................................................................................](#br14)[ ](#br14)[14](#br14)
1. [](#br15)[** ](#br15)[Terms**](#br15)[** ](#br15)[and**](#br15)[** ](#br15)[Definitions**](#br15)[................................................................................................................................................](#br15)[ ](#br15)[15](#br15)
1. [](#br16)[** ](#br16)[Get**](#br16)[** ](#br16)[Started**](#br16)[** ](#br16)[with**](#br16)[** ](#br16)[our**](#br16)[** ](#br16)[SDK**](#br16)[...........................................................................................................................................](#br16)[ ](#br16)[16](#br16)
1. [](#br16)[ ](#br16)[Software](#br16)[ ](#br16)[Development](#br16)[ ](#br16)[Environment](#br16)[ ](#br16)[Setup......................................................................................................](#br16)[ ](#br16)[16](#br16)
1. [](#br16)[ ](#br16)[Set](#br16)[ ](#br16)[up](#br16)[ ](#br16)[Compilation](#br16)[ ](#br16)[Environment](#br16)[ ](#br16)[......................................................................................................](#br16)[ ](#br16)[16](#br16)
1. [](#br16)[ ](#br16)[Build](#br16)[ ](#br16)[the](#br16)[ ](#br16)[Project................................................................................................................................](#br16)[ ](#br16)[16](#br16)
1. [](#br17)[ ](#br17)[Usage](#br17)[ ](#br17)[of](#br17)[ ](#br17)[Hardware](#br17)[ ](#br17)[Development](#br17)[ ](#br17)[Kit................................................................................................](#br17)[ ](#br17)[17](#br17)
1. [](#br18)[ ](#br18)[Image](#br18)[ ](#br18)[Programming](#br18)[ ](#br18)[..........................................................................................................................](#br18)[ ](#br18)[18](#br18)
1. [](#br21)[ ](#br21)[Implement](#br21)[ ](#br21)[Basic](#br21)[ ](#br21)[Functions](#br21)[ ](#br21)[...............................................................................................................](#br21)[ ](#br21)[21](#br21)
1. [](#br24)[** ](#br24)[Software**](#br24)[** ](#br24)[System**](#br24)[** ](#br24)[Introduction**](#br24)[...................................................................................................................................](#br24)[ ](#br24)[24](#br24)
1. [](#br24)[ ](#br24)[Software](#br24)[ ](#br24)[Architecture........................................................................................................................................](#br24)[ ](#br24)[24](#br24)
1. [](#br25)[ ](#br25)[SDK](#br25)[ ](#br25)[Folder](#br25)[ ](#br25)[Structure..........................................................................................................................................](#br25)[ ](#br25)[25](#br25)
1. [](#br26)[ ](#br26)[Introduction](#br26)[ ](#br26)[of](#br26)[ ](#br26)[Main](#br26)[ ](#br26)[MCU-dedicated](#br26)[ ](#br26)[Threads..................................................................................................](#br26)[ ](#br26)[26](#br26)
1. [](#br28)[** ](#br28)[Software**](#br28)[** ](#br28)[Development**](#br28)[** ](#br28)[Guide**](#br28)[** ](#br28)[...................................................................................................................................](#br28)[ ](#br28)[28](#br28)

[ ](#br28)[5.1](#br28)[ ](#br28)[Target](#br28)[ ](#br28)[Configuration..........................................................................................................................................](#br28)[ ](#br28)[28](#br28)[ ](#br28)[5.1.1](#br28)[ ](#br28)[Common.mk](#br28)[ ](#br28)[......................................................................................................................................](#br28)[ ](#br28)[28](#br28)[ ](#br28)[5.1.2](#br28)[ ](#br28)[Target.mk](#br28)[ ](#br28)[..........................................................................................................................................](#br28)[ ](#br28)[28](#br28)[ ](#br28)[5.1.3](#br28)[ ](#br28)[Link](#br28)[ ](#br28)[Script](#br28)[ ](#br28)[..........................................................................................................................................](#br28)[ ](#br28)[28](#br28)[ ](#br28)[5.1.4](#br28)[ ](#br28)[Target](#br28)[ ](#br28)[Hardware](#br28)[ ](#br28)[Configuration.........................................................................................................](#br28)[ ](#br28)[28](#br28)[ ](#br32)[5.2](#br32)[ ](#br32)[Hardware](#br32)[ ](#br32)[Abstract](#br32)[ ](#br32)[Layer](#br32)[ ](#br32)[Drives](#br32)[ ](#br32)[........................................................................................................................](#br32)[ ](#br32)[32](#br32)[ ](#br32)[5.2.1](#br32)[ ](#br32)[Use](#br32)[ ](#br32)[GPIO............................................................................................................................................](#br32)[ ](#br32)[32](#br32)[ ](#br36)[5.2.2](#br36)[ ](#br36)[Use](#br36)[ ](#br36)[UART...........................................................................................................................................](#br36)[ ](#br36)[36](#br36)[ ](#br39)[5.2.3](#br39)[ ](#br39)[Use](#br39)[ ](#br39)[I2C...............................................................................................................................................](#br39)[ ](#br39)[39](#br39)[ ](#br42)[5.2.4](#br42)[ ](#br42)[Use](#br42)[ ](#br42)[SPI...............................................................................................................................................](#br42)[ ](#br42)[42](#br42)[ ](#br44)[5.2.5](#br44)[ ](#br44)[Use](#br44)[ ](#br44)[I2S...............................................................................................................................................](#br44)[ ](#br44)[44](#br44)[ ](#br47)[5.2.6](#br47)[ ](#br47)[Use](#br47)[ ](#br47)[ADC.............................................................................................................................................](#br47)[ ](#br47)[47](#br47)[ ](#br48)[5.2.7](#br48)[ ](#br48)[Use](#br48)[ ](#br48)[Hardware](#br48)[ ](#br48)[Timer..........................................................................................................................](#br48)[ ](#br48)[48](#br48)[ ](#br49)[5.2.8](#br49)[ ](#br49)[Use](#br49)[ ](#br49)[PWM...........................................................................................................................................](#br49)[ ](#br49)[49](#br49)[ ](#br52)[5.2.9](#br52)[ ](#br52)[DMA...................................................................................................................................................](#br52)[ ](#br52)[52](#br52)[ ](#br54)[5.3](#br54)[ ](#br54)[Memory](#br54)[ ](#br54)[Map](#br54)[ ](#br54)[.....................................................................................................................................................](#br54)[ ](#br54)[54](#br54)[ ](#br55)[5.3.1](#br55)[ ](#br55)[Logic](#br55)[ ](#br55)[Address](#br55)[ ](#br55)[Map](#br55)[ ](#br55)[............................................................................................................................](#br55)[ ](#br55)[55](#br55)[ ](#br55)[5.3.2](#br55)[ ](#br55)[Flash](#br55)[ ](#br55)[Memory](#br55)[ ](#br55)[Map............................................................................................................................](#br55)[ ](#br55)[55](#br55)[ ](#br56)[5.3.3](#br56)[ ](#br56)[Audio](#br56)[ ](#br56)[Buffer](#br56)[ ](#br56)[Usage............................................................................................................................](#br56)[ ](#br56)[56](#br56)[ ](#br57)[5.3.4](#br57)[ ](#br57)[Memory](#br57)[ ](#br57)[Usage](#br57)[ ](#br57)[in](#br57)[ ](#br57)[Link](#br57)[ ](#br57)[Script.............................................................................................................](#br57)[ ](#br57)[57](#br57)[ ](#br60)[5.3.5](#br60)[ ](#br60)[Define](#br60)[ ](#br60)[a](#br60)[ ](#br60)[Specific](#br60)[ ](#br60)[Section](#br60)[ ](#br60)[and](#br60)[ ](#br60)[Use](#br60)[ ](#br60)[it](#br60)[ ](#br60)[..................................................................................................](#br60)[ ](#br60)[60](#br60)[ ](#br60)[5.3.6](#br60)[ ](#br60)[Coordinate](#br60)[ ](#br60)[Ram](#br60)[ ](#br60)[Size..........................................................................................................................](#br60)[ ](#br60)[60](#br60)[ ](#br61)[5.3.7](#br61)[ ](#br61)[Overlay](#br61)[ ](#br61)[Usage....................................................................................................................................](#br61)[ ](#br61)[61](#br61)

4. [](#br62)[ ](#br62)[System](#br62)[ ](#br62)[API](#br62)[ ](#br62)[.........................................................................................................................................................](#br62)[ ](#br62)[62](#br62)[ ](#br62)[5.4.1](#br62)[ ](#br62)[System](#br62)[ ](#br62)[Ticks](#br62)[ ](#br62)[......................................................................................................................................](#br62)[ ](#br62)[62](#br62)[ ](#br62)[5.4.2](#br62)[ ](#br62)[Battery](#br62)[ ](#br62)[Management](#br62)[ ](#br62)[........................................................................................................................](#br62)[ ](#br62)[62](#br62)

Rev 1.2 Page3 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

3. [](#br64)[ ](#br64)[UART](#br64)[ ](#br64)[Data](#br64)[ ](#br64)[Path](#br64)[ ](#br64)[.................................................................................................................................](#br64)[ ](#br64)[64](#br64)
3. [](#br68)[ ](#br68)[Dynamic](#br68)[ ](#br68)[Frequency...........................................................................................................................](#br68)[ ](#br68)[68](#br68)
3. [](#br69)[ ](#br69)[Core](#br69)[ ](#br69)[Bridge........................................................................................................................................](#br69)[ ](#br69)[69](#br69)
3. [](#br72)[ ](#br72)[Sensor](#br72)[ ](#br72)[Hub](#br72)[ ](#br72)[........................................................................................................................................](#br72)[ ](#br72)[72](#br72)
3. [](#br74)[ ](#br74)[M55](#br74)[ ](#br74)[...................................................................................................................................................](#br74)[ ](#br74)[74](#br74)
3. [](#br75)[ ](#br75)[Co-processor......................................................................................................................................](#br75)[ ](#br75)[75](#br75)
3. [](#br77)[ ](#br77)[Power](#br77)[ ](#br77)[Management..........................................................................................................................](#br77)[ ](#br77)[77](#br77)
3. [](#br86)[ ](#br86)[Button](#br86)[ ](#br86)[Action](#br86)[ ](#br86)[Handler.......................................................................................................................](#br86)[ ](#br86)[86](#br86)
3. [](#br92)[ ](#br92)[Nor-Flash](#br92)[ ](#br92)[API.....................................................................................................................................](#br92)[ ](#br92)[92](#br92)
3. [](#br103)[ ](#br103)[PMU](#br103)[ ](#br103)[Watchdog](#br103)[ ](#br103)[...............................................................................................................................](#br103)[ ](#br103)[103](#br103)
3. [](#br104)[ ](#br104)[TWS](#br104)[ ](#br104)[Synchronization](#br104)[ ](#br104)[Operation](#br104)[ ](#br104)[API](#br104)[ ](#br104)[...............................................................................................](#br104)[ ](#br104)[104](#br104)
3. [](#br105)[ ](#br105)[Dynamic](#br105)[ ](#br105)[Heap](#br105)[ ](#br105)[Usage.......................................................................................................................](#br105)[ ](#br105)[105](#br105)
3. [](#br106)[ ](#br106)[Retention](#br106)[ ](#br106)[Information](#br106)[ ](#br106)[Management](#br106)[ ](#br106)[..............................................................................................](#br106)[ ](#br106)[106](#br106)
4. [](#br107)[ ](#br107)[RTOS.................................................................................................................................................................](#br107)[ ](#br107)[107](#br107)
1. [](#br107)[ ](#br107)[Multi-task](#br107)[ ](#br107)[........................................................................................................................................](#br107)[ ](#br107)[107](#br107)
1. [](#br107)[ ](#br107)[Task](#br107)[ ](#br107)[Scheduler.................................................................................................................................](#br107)[ ](#br107)[107](#br107)
1. [](#br109)[ ](#br109)[OS](#br109)[ ](#br109)[Abstract](#br109)[ ](#br109)[Layer](#br109)[ ](#br109)[............................................................................................................................](#br109)[ ](#br109)[109](#br109)
1. [](#br110)[ ](#br110)[Create](#br110)[ ](#br110)[a](#br110)[ ](#br110)[Task](#br110)[ ](#br110)[...................................................................................................................................](#br110)[ ](#br110)[110](#br110)
1. [](#br111)[ ](#br111)[OS](#br111)[ ](#br111)[Event](#br111)[ ](#br111)[..........................................................................................................................................](#br111)[ ](#br111)[111](#br111)
1. [](#br113)[ ](#br113)[OS](#br113)[ ](#br113)[Mailbox](#br113)[ ](#br113)[......................................................................................................................................](#br113)[ ](#br113)[113](#br113)
1. [](#br115)[ ](#br115)[OS](#br115)[ ](#br115)[Timer](#br115)[ ](#br115)[..........................................................................................................................................](#br115)[ ](#br115)[115](#br115)
1. [](#br116)[ ](#br116)[OS](#br116)[ ](#br116)[Semaphore.................................................................................................................................](#br116)[ ](#br116)[116](#br116)
1. [](#br117)[ ](#br117)[OS](#br117)[ ](#br117)[Delay](#br117)[ ](#br117)[..........................................................................................................................................](#br117)[ ](#br117)[117](#br117)
1. [](#br118)[ ](#br118)[OS](#br118)[ ](#br118)[Thread](#br118)[ ](#br118)[Statistics.........................................................................................................................](#br118)[ ](#br118)[118](#br118)
4. [](#br120)[ ](#br120)[Audio](#br120)[ ](#br120)[Function](#br120)[ ](#br120)[Usage](#br120)[ ](#br120)[Guide............................................................................................................................](#br120)[ ](#br120)[120](#br120)
1. [](#br120)[ ](#br120)[Audio](#br120)[ ](#br120)[Flinger](#br120)[ ](#br120)[...................................................................................................................................](#br120)[ ](#br120)[120](#br120)
1. [](#br126)[ ](#br126)[Audio](#br126)[ ](#br126)[Data](#br126)[ ](#br126)[Path](#br126)[ ](#br126)[Introduction..........................................................................................................](#br126)[ ](#br126)[126](#br126)
1. [](#br128)[ ](#br128)[Left](#br128)[ ](#br128)[and](#br128)[ ](#br128)[Right](#br128)[ ](#br128)[Playback](#br128)[ ](#br128)[Channel](#br128)[ ](#br128)[Configuration](#br128)[ ](#br128)[..............................................................................](#br128)[ ](#br128)[128](#br128)
1. [](#br131)[ ](#br131)[Configure](#br131)[ ](#br131)[Music](#br131)[ ](#br131)[Jitter](#br131)[ ](#br131)[Buffer](#br131)[ ](#br131)[Length...............................................................................................](#br131)[ ](#br131)[131](#br131)
4. [](#br132)[ ](#br132)[Callback](#br132)[ ](#br132)[API......................................................................................................................................................](#br132)[ ](#br132)[132](#br132)
1. [](#br132)[ ](#br132)[Prompt](#br132)[ ](#br132)[Usage](#br132)[ ](#br132)[Guide........................................................................................................................](#br132)[ ](#br132)[132](#br132)
1. [](#br142)[ ](#br142)[Volume](#br142)[ ](#br142)[Level](#br142)[ ](#br142)[Configuration](#br142)[ ](#br142)[and](#br142)[ ](#br142)[Volume](#br142)[ ](#br142)[Control...........................................................................](#br142)[ ](#br142)[142](#br142)
4. [](#br144)[ ](#br144)[Bluetooth](#br144)[ ](#br144)[Usage](#br144)[ ](#br144)[Guide....................................................................................................................................](#br144)[ ](#br144)[144](#br144)
1. [](#br144)[ ](#br144)[Bluetooth](#br144)[ ](#br144)[Framework](#br144)[ ](#br144)[.....................................................................................................................](#br144)[ ](#br144)[144](#br144)
1. [](#br146)[ ](#br146)[Classic](#br146)[ ](#br146)[BT](#br146)[ ](#br146)[.........................................................................................................................................](#br146)[ ](#br146)[146](#br146)
1. [](#br180)[ ](#br180)[BLE...................................................................................................................................................](#br180)[ ](#br180)[180](#br180)
1. [](#br236)[ ](#br236)[TWS](#br236)[ ](#br236)[Communication](#br236)[ ](#br236)[Data](#br236)[ ](#br236)[Path](#br236)[ ](#br236)[......................................................................................................](#br236)[ ](#br236)[236](#br236)
1. [](#br239)[ ](#br239)[GATT](#br239)[ ](#br239)[over](#br239)[ ](#br239)[BR/EDR...........................................................................................................................](#br239)[ ](#br239)[239](#br239)
1. [](#br241)[ ](#br241)[DUT](#br241)[ ](#br241)[Test](#br241)[ ](#br241)[Mode................................................................................................................................](#br241)[ ](#br241)[241](#br241)
1. [](#br248)[ ](#br248)[Throughput](#br248)[ ](#br248)[Usage](#br248)[ ](#br248)[Guide.................................................................................................................](#br248)[ ](#br248)[248](#br248)
4. [](#br260)[ ](#br260)[OTA](#br260)[ ](#br260)[..................................................................................................................................................................](#br260)[ ](#br260)[260](#br260)
1. [](#br260)[ ](#br260)[OTA](#br260)[ ](#br260)[Flash](#br260)[ ](#br260)[Memory](#br260)[ ](#br260)[Map..................................................................................................................](#br260)[ ](#br260)[260](#br260)
1. [](#br261)[ ](#br261)[OTA](#br261)[ ](#br261)[Flow](#br261)[ ](#br261)[.........................................................................................................................................](#br261)[ ](#br261)[261](#br261)
1. [](#br262)[ ](#br262)[OTA](#br262)[ ](#br262)[Protocol](#br262)[ ](#br262)[...................................................................................................................................](#br262)[ ](#br262)[262](#br262)
1. [](#br277)[ ](#br277)[OTA](#br277)[ ](#br277)[User](#br277)[ ](#br277)[Guide](#br277)[ ](#br277)[...............................................................................................................................](#br277)[ ](#br277)[277](#br277)

Rev 1.2 Page4 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

4. [](#br298)[ ](#br298)[TOTA](#br298)[ ](#br298)[................................................................................................................................................................](#br298)[ ](#br298)[298](#br298)
1. [](#br298)[ ](#br298)[TOTA](#br298)[ ](#br298)[Protocol](#br298)[ ](#br298)[.................................................................................................................................](#br298)[ ](#br298)[298](#br298)
1. [](#br301)[ ](#br301)[TOTA](#br301)[ ](#br301)[User](#br301)[ ](#br301)[Guide](#br301)[ ](#br301)[.............................................................................................................................](#br301)[ ](#br301)[301](#br301)
4. [](#br304)[ ](#br304)[Add](#br304)[ ](#br304)[a](#br304)[ ](#br304)[Custom](#br304)[ ](#br304)[UART](#br304)[ ](#br304)[Command](#br304)[ ](#br304)[.......................................................................................................................](#br304)[ ](#br304)[304](#br304)
4. [](#br305)[ ](#br305)[Debugging](#br305)[ ](#br305)[Methods.........................................................................................................................................](#br305)[ ](#br305)[305](#br305)
1. [](#br305)[ ](#br305)[UART](#br305)[ ](#br305)[Log](#br305)[ ](#br305)[Print.................................................................................................................................](#br305)[ ](#br305)[305](#br305)
1. [](#br305)[ ](#br305)[Crash](#br305)[ ](#br305)[Analysis..................................................................................................................................](#br305)[ ](#br305)[305](#br305)
1. [](#br324)[ ](#br324)[Full](#br324)[ ](#br324)[CPU](#br324)[ ](#br324)[Workload](#br324)[ ](#br324)[Power](#br324)[ ](#br324)[Consumption](#br324)[ ](#br324)[Measurement](#br324)[ ](#br324)[.................................................................](#br324)[ ](#br324)[324](#br324)
1. [](#br327)[ ](#br327)[Thread](#br327)[ ](#br327)[Information](#br327)[ ](#br327)[Periodic](#br327)[ ](#br327)[Print...................................................................................................](#br327)[ ](#br327)[327](#br327)
1. [](#br330)[ ](#br330)[Audio](#br330)[ ](#br330)[Dump](#br330)[ ](#br330)[Tool](#br330)[ ](#br330)[Usage..................................................................................................................](#br330)[ ](#br330)[330](#br330)

Rev 1.2 Page5 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**List of Tables**

[Table](#br26)[ ](#br26)[1](#br26)[ ](#br26)[Thread](#br26)[ ](#br26)[Introduction](#br26)[ ](#br26)[.......................................................................................................................................](#br26)[ ](#br26)[26](#br26)

[Table](#br32)[ ](#br32)[2](#br32)[ ](#br32)[GPIO](#br32)[ ](#br32)[IOMuX](#br32)[ ](#br32)[Coniguration..............................................................................................................................](#br32)[ ](#br32)[32](#br32)

[Table](#br36)[ ](#br36)[3](#br36)[ ](#br36)[UART](#br36)[ ](#br36)[Configuration........................................................................................................................................](#br36)[ ](#br36)[36](#br36)

[Table](#br40)[ ](#br40)[4](#br40)[ ](#br40)[I2C](#br40)[ ](#br40)[Configuration............................................................................................................................................](#br40)[ ](#br40)[40](#br40)

[Table](#br41)[ ](#br41)[5](#br41)[ ](#br41)[Parameter](#br41)[ ](#br41)[List](#br41)[ ](#br41)[of](#br41)[ ](#br41)[Function](#br41)[ ](#br41)[hal_i2c_send.......................................................................................................](#br41)[ ](#br41)[41](#br41)

[Table](#br42)[ ](#br42)[6](#br42)[ ](#br42)[Parameter](#br42)[ ](#br42)[List](#br42)[ ](#br42)[of](#br42)[ ](#br42)[Function](#br42)[ ](#br42)[hal_i2c_recv........................................................................................................](#br42)[ ](#br42)[42](#br42)

[Table](#br42)[ ](#br42)[7](#br42)[ ](#br42)[SPI](#br42)[ ](#br42)[Configuration............................................................................................................................................](#br42)[ ](#br42)[42](#br42)

[Table](#br44)[ ](#br44)[8](#br44)[ ](#br44)[I2S](#br44)[ ](#br44)[Configuration............................................................................................................................................](#br44)[ ](#br44)[44](#br44)

[Table](#br47)[ ](#br47)[9](#br47)[ ](#br47)[GPADC](#br47)[ ](#br47)[Configurable](#br47)[ ](#br47)[Items.............................................................................................................................](#br47)[ ](#br47)[47](#br47)

[Table](#br48)[ ](#br48)[10](#br48)[ ](#br48)[Hardware](#br48)[ ](#br48)[Timer](#br48)[ ](#br48)[Type...................................................................................................................................](#br48)[ ](#br48)[48](#br48)

[Table](#br49)[ ](#br49)[11](#br49)[ ](#br49)[PWM](#br49)[ ](#br49)[IOMuX](#br49)[ ](#br49)[Coniguration...........................................................................................................................](#br49)[ ](#br49)[49](#br49)

[Table](#br51)[ ](#br51)[12](#br51)[ ](#br51)[Breathing](#br51)[ ](#br51)[LED](#br51)[ ](#br51)[Configuration........................................................................................................................](#br51)[ ](#br51)[51](#br51)

[Table](#br52)[ ](#br52)[13](#br52)[ ](#br52)[DMA](#br52)[ ](#br52)[Coniguration........................................................................................................................................](#br52)[ ](#br52)[52](#br52)

[Table](#br61)[ ](#br61)[14](#br61)[ ](#br61)[Overlay](#br61)[ ](#br61)[Configuration](#br61)[ ](#br61)[..................................................................................................................................](#br61)[ ](#br61)[61](#br61)

[Table](#br68)[ ](#br68)[15](#br68)[ ](#br68)[Dynamic](#br68)[ ](#br68)[Frequency](#br68)[ ](#br68)[Setting..........................................................................................................................](#br68)[ ](#br68)[68](#br68)

[Table](#br77)[ ](#br77)[16](#br77)[ ](#br77)[Lower](#br77)[ ](#br77)[Power](#br77)[ ](#br77)[Mode......................................................................................................................................](#br77)[ ](#br77)[77](#br77)

[Table](#br79)[ ](#br79)[17](#br79)[ ](#br79)[Wake](#br79)[ ](#br79)[Lock](#br79)[ ](#br79)[Types..........................................................................................................................................](#br79)[ ](#br79)[79](#br79)

[Table](#br86)[ ](#br86)[18](#br86)[ ](#br86)[GPIO](#br86)[ ](#br86)[Button](#br86)[ ](#br86)[Configuration](#br86)[ ](#br86)[..........................................................................................................................](#br86)[ ](#br86)[86](#br86)

[Table](#br92)[ ](#br92)[19](#br92)[ ](#br92)[Flash](#br92)[ ](#br92)[Module](#br92)[ ](#br92)[ID............................................................................................................................................](#br92)[ ](#br92)[92](#br92)

[Table](#br99)[ ](#br99)[20](#br99)[ ](#br99)[Factory](#br99)[ ](#br99)[Section](#br99)[ ](#br99)[Information.........................................................................................................................](#br99)[ ](#br99)[99](#br99)

[Table](#br102)[ ](#br102)[21](#br102)[ ](#br102)[Data](#br102)[ ](#br102)[Format](#br102)[ ](#br102)[of](#br102)[ ](#br102)[Custom](#br102)[ ](#br102)[Parameters](#br102)[ ](#br102)[..........................................................................................................](#br102)[ ](#br102)[102](#br102)

[Table](#br103)[ ](#br103)[22](#br103)[ ](#br103)[Example](#br103)[ ](#br103)[of](#br103)[ ](#br103)[Custom](#br103)[ ](#br103)[Parameters.................................................................................................................](#br103)[ ](#br103)[103](#br103)

[Table](#br104)[ ](#br104)[23](#br104)[ ](#br104)[TWS](#br104)[ ](#br104)[Synchronization](#br104)[ ](#br104)[Operation](#br104)[ ](#br104)[Code](#br104)[ ](#br104)[.......................................................................................................](#br104)[ ](#br104)[104](#br104)

[Table](#br105)[ ](#br105)[24](#br105)[ ](#br105)[Heap](#br105)[ ](#br105)[Information.......................................................................................................................................](#br105)[ ](#br105)[105](#br105)

[Table](#br118)[ ](#br118)[25](#br118)[ ](#br118)[Threads](#br118)[ ](#br118)[Statistics](#br118)[ ](#br118)[Introduction](#br118)[ ](#br118)[..................................................................................................................](#br118)[ ](#br118)[118](#br118)

[Table](#br120)[ ](#br120)[26](#br120)[ ](#br120)[Capture](#br120)[ ](#br120)[Configuration................................................................................................................................](#br120)[ ](#br120)[120](#br120)

[Table](#br122)[ ](#br122)[27](#br122)[ ](#br122)[Playback](#br122)[ ](#br122)[Configuration...............................................................................................................................](#br122)[ ](#br122)[122](#br122)

[Table](#br136)[ ](#br136)[28](#br136)[ ](#br136)[APIs](#br136)[ ](#br136)[of](#br136)[ ](#br136)[Voice](#br136)[ ](#br136)[Prompt](#br136)[ ](#br136)[Module](#br136)[ ](#br136)[....................................................................................................................](#br136)[ ](#br136)[136](#br136)

[Table](#br148)[ ](#br148)[29](#br148)[ ](#br148)[app_ibrt_if_get_a2dp_state](#br148)[ ](#br148)[Parameters...................................................................................................](#br148)[ ](#br148)[148](#br148)

[Table](#br148)[ ](#br148)[30](#br148)[ ](#br148)[app_ibrt_if_get_avrcp_state](#br148)[ ](#br148)[Parameters](#br148)[ ](#br148)[..................................................................................................](#br148)[ ](#br148)[148](#br148)

[Table](#br149)[ ](#br149)[31](#br149)[ ](#br149)[app_ibrt_if_get_hfp_state](#br149)[ ](#br149)[Parameters......................................................................................................](#br149)[ ](#br149)[149](#br149)

[Table](#br149)[ ](#br149)[32](#br149)[ ](#br149)[app_ibrt_if_get_hfp_call_status](#br149)[ ](#br149)[Parameters.............................................................................................](#br149)[ ](#br149)[149](#br149)

[Table](#br150)[ ](#br150)[33](#br150)[ ](#br150)[app_ibrt_if_get_mobile_connected_dev_list](#br150)[ ](#br150)[Parameters](#br150)[ ](#br150)[........................................................................](#br150)[ ](#br150)[150](#br150)

[Table](#br150)[ ](#br150)[34](#br150)[ ](#br150)[app_ibrt_if_nvrecord_get_mobile_addr](#br150)[ ](#br150)[Parameters](#br150)[ ](#br150)[................................................................................](#br150)[ ](#br150)[150](#br150)

[Table](#br151)[ ](#br151)[35](#br151)[ ](#br151)[app_ibrt_if_nvrecord_get_mobile_paired_dev_list](#br151)[ ](#br151)[Parameters...............................................................](#br151)[ ](#br151)[151](#br151)

[Table](#br152)[ ](#br152)[36](#br152)[ ](#br152)[app_ibrt_if_set_side](#br152)[ ](#br152)[Parameters...............................................................................................................](#br152)[ ](#br152)[152](#br152)

[Table](#br153)[ ](#br153)[37](#br153)[ ](#br153)[app_ibrt_if_register_sync_user](#br153)[ ](#br153)[Parameters..............................................................................................](#br153)[ ](#br153)[153](#br153)

[Table](#br153)[ ](#br153)[38](#br153)[ ](#br153)[app_ibrt_if_deregister_sync_user](#br153)[ ](#br153)[Parameters..........................................................................................](#br153)[ ](#br153)[153](#br153)

[Table](#br153)[ ](#br153)[39](#br153)[ ](#br153)[app_ibrt_if_sync_info](#br153)[ ](#br153)[Parameters.............................................................................................................](#br153)[ ](#br153)[153](#br153)

[Table](#br154)[ ](#br154)[40](#br154)[ ](#br154)[app_ibrt_if_request_modify_tws_bandwidth](#br154)[ ](#br154)[Parameters........................................................................](#br154)[ ](#br154)[154](#br154)

[Table](#br154)[ ](#br154)[41](#br154)[ ](#br154)[app_ibrt_if_write_bt_local_address](#br154)[ ](#br154)[Parameters](#br154)[ ](#br154)[......................................................................................](#br154)[ ](#br154)[154](#br154)

[Table](#br154)[ ](#br154)[42](#br154)[ ](#br154)[app_ibrt_if_update_tws_pairing_info](#br154)[ ](#br154)[Parameters....................................................................................](#br154)[ ](#br154)[154](#br154)

[Table](#br155)[ ](#br155)[43](#br155)[ ](#br155)[app_ibrt_if_start_tws_pairing](#br155)[ ](#br155)[Parameters................................................................................................](#br155)[ ](#br155)[155](#br155)

Rev 1.2 Page6 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

[Table](#br159)[ ](#br159)[44](#br159)[ ](#br159)[Ibrt_core_status_changed_cb_t](#br159)[ ](#br159)[Description.............................................................................................](#br159)[ ](#br159)[159](#br159)

[Table](#br160)[ ](#br160)[45](#br160)[ ](#br160)[app_ibrt_if_update_tws_pairing_info](#br160)[ ](#br160)[Parameters....................................................................................](#br160)[ ](#br160)[160](#br160)

[Table](#br160)[ ](#br160)[46](#br160)[ ](#br160)[app_ibrt_if_start_tws_pairing](#br160)[ ](#br160)[Parameters................................................................................................](#br160)[ ](#br160)[160](#br160)

[Table](#br161)[ ](#br161)[47](#br161)[ ](#br161)[app_ibrt_if_event_entry](#br161)[ ](#br161)[Description.........................................................................................................](#br161)[ ](#br161)[161](#br161)

[Table](#br162)[ ](#br162)[48](#br162)[ ](#br162)[ibrt_core_status_changed_cb_t](#br162)[ ](#br162)[Description.............................................................................................](#br162)[ ](#br162)[162](#br162)

[Table](#br164)[ ](#br164)[49](#br164)[ ](#br164)[BES](#br164)[ ](#br164)[UI](#br164)[ ](#br164)[Property](#br164)[ ](#br164)[Configuration](#br164)[ ](#br164)[...................................................................................................................](#br164)[ ](#br164)[164](#br164)

[Table](#br172)[ ](#br172)[50](#br172)[ ](#br172)[TWS_SYNC_USER_T](#br172)[ ](#br172)[Description](#br172)[ ](#br172)[................................................................................................................](#br172)[ ](#br172)[172](#br172)

[Table](#br176)[ ](#br176)[51](#br176)[ ](#br176)[app_ibrt_if_request_modify_tws_bandwidth](#br176)[ ](#br176)[Description........................................................................](#br176)[ ](#br176)[176](#br176)

[Table](#br187)[ ](#br187)[52](#br187)[ ](#br187)[BLE_ADV_PARAM_T](#br187)[ ](#br187)[Description](#br187)[ ](#br187)[...............................................................................................................](#br187)[ ](#br187)[187](#br187)

[Table](#br193)[ ](#br193)[53](#br193)[ ](#br193)[Function](#br193)[ ](#br193)[app_ble_data_fill_enable](#br193)[ ](#br193)[Description](#br193)[ ](#br193)[........................................................................................](#br193)[ ](#br193)[193](#br193)

[Table](#br193)[ ](#br193)[54](#br193)[ ](#br193)[Function](#br193)[ ](#br193)[app_ble_force_switch_adv](#br193)[ ](#br193)[Description......................................................................................](#br193)[ ](#br193)[193](#br193)

[Table](#br194)[ ](#br194)[55](#br194)[ ](#br194)[Function](#br194)[ ](#br194)[app_ble_set_adv_type](#br194)[ ](#br194)[Description.............................................................................................](#br194)[ ](#br194)[194](#br194)

[Table](#br197)[ ](#br197)[56](#br197)[ ](#br197)[Function](#br197)[ ](#br197)[app_ble_param_set_adv_interval](#br197)[ ](#br197)[Description...........................................................................](#br197)[ ](#br197)[197](#br197)

[Table](#br200)[ ](#br200)[57](#br200)[ ](#br200)[Function](#br200)[ ](#br200)[app_ble_set_adv_txpwr_by_actv_user](#br200)[ ](#br200)[Description...................................................................](#br200)[ ](#br200)[200](#br200)

[Table](#br200)[ ](#br200)[58](#br200)[ ](#br200)[Function](#br200)[ ](#br200)[app_ble_set_adv_txpwr_by_adv_user](#br200)[ ](#br200)[Description....................................................................](#br200)[ ](#br200)[200](#br200)

[Table](#br200)[ ](#br200)[59](#br200)[ ](#br200)[Function](#br200)[ ](#br200)[app_ble_set_all_adv_txpwr](#br200)[ ](#br200)[Description.....................................................................................](#br200)[ ](#br200)[200](#br200)

[Table](#br202)[ ](#br202)[60](#br202)[ ](#br202)[Function](#br202)[ ](#br202)[app_ble_set_adv_local_addr_by_user](#br202)[ ](#br202)[Description....................................................................](#br202)[ ](#br202)[202](#br202)

[Table](#br202)[ ](#br202)[61](#br202)[ ](#br202)[Function](#br202)[ ](#br202)[app_ble_set_adv_local_adddr_adv_user](#br202)[ ](#br202)[Description................................................................](#br202)[ ](#br202)[202](#br202)

[Table](#br203)[ ](#br203)[62](#br203)[ ](#br203)[Function](#br203)[ ](#br203)[app_ble_refresh_adv_state](#br203)[ ](#br203)[Description.....................................................................................](#br203)[ ](#br203)[203](#br203)

[Table](#br205)[ ](#br205)[63](#br205)[ ](#br205)[Function](#br205)[ ](#br205)[app_ble_custom_adv_write_data](#br205)[ ](#br205)[Description...........................................................................](#br205)[ ](#br205)[205](#br205)

[Table](#br207)[ ](#br207)[64](#br207)[ ](#br207)[Function](#br207)[ ](#br207)[app_ble_custom_adv_start](#br207)[ ](#br207)[Description.....................................................................................](#br207)[ ](#br207)[207](#br207)

[Table](#br207)[ ](#br207)[65](#br207)[ ](#br207)[Adv](#br207)[ ](#br207)[Event](#br207)[ ](#br207)[List.............................................................................................................................................](#br207)[ ](#br207)[207](#br207)

[Table](#br208)[ ](#br208)[66](#br208)[ ](#br208)[Function](#br208)[ ](#br208)[app_ble_start_scan](#br208)[ ](#br208)[Description..................................................................................................](#br208)[ ](#br208)[208](#br208)

[Table](#br210)[ ](#br210)[67](#br210)[ ](#br210)[Scan](#br210)[ ](#br210)[Event](#br210)[ ](#br210)[List............................................................................................................................................](#br210)[ ](#br210)[210](#br210)

[Table](#br211)[ ](#br211)[68](#br211)[ ](#br211)[Function](#br211)[ ](#br211)[app_ble_start_connect](#br211)[ ](#br211)[Description............................................................................................](#br211)[ ](#br211)[211](#br211)

[Table](#br212)[ ](#br212)[69](#br212)[ ](#br212)[Function](#br212)[ ](#br212)[app_ble_start_connect_with_init_type](#br212)[ ](#br212)[Description](#br212)[ ](#br212)[..................................................................](#br212)[ ](#br212)[212](#br212)

[Table](#br213)[ ](#br213)[70](#br213)[ ](#br213)[Function](#br213)[ ](#br213)[app_ble_is_connection_on_by_addr](#br213)[ ](#br213)[Description](#br213)[ ](#br213)[......................................................................](#br213)[ ](#br213)[213](#br213)

[Table](#br213)[ ](#br213)[71](#br213)[ ](#br213)[Function](#br213)[ ](#br213)[app_ble_is_connection_on](#br213)[ ](#br213)[Description......................................................................................](#br213)[ ](#br213)[213](#br213)

[Table](#br214)[ ](#br214)[72](#br214)[ ](#br214)[Function](#br214)[ ](#br214)[app_ble_start_disconnect](#br214)[ ](#br214)[Description](#br214)[ ](#br214)[.......................................................................................](#br214)[ ](#br214)[214](#br214)

[Table](#br215)[ ](#br215)[73](#br215)[ ](#br215)[Connection](#br215)[ ](#br215)[Event](#br215)[ ](#br215)[List.................................................................................................................................](#br215)[ ](#br215)[215](#br215)

[Table](#br219)[ ](#br219)[74](#br219)[ ](#br219)[Function](#br219)[ ](#br219)[app_ble_update_conn_param_mode](#br219)[ ](#br219)[Description](#br219)[ ](#br219)[.....................................................................](#br219)[ ](#br219)[219](#br219)

[Table](#br219)[ ](#br219)[75](#br219)[ ](#br219)[Function](#br219)[ ](#br219)[app_ble_conn_param](#br219)[ ](#br219)[Description..............................................................................................](#br219)[ ](#br219)[219](#br219)

[Table](#br220)[ ](#br220)[76](#br220)[ ](#br220)[Connection](#br220)[ ](#br220)[Parameter](#br220)[ ](#br220)[Management](#br220)[ ](#br220)[Event](#br220)[ ](#br220)[List](#br220)[ ](#br220)[........................................................................................](#br220)[ ](#br220)[220](#br220)

[Table](#br231)[ ](#br231)[77](#br231)[ ](#br231)[Function](#br231)[ ](#br231)[aob_dts_register_spsm](#br231)[ ](#br231)[Description............................................................................................](#br231)[ ](#br231)[231](#br231)

[Table](#br232)[ ](#br232)[78](#br232)[ ](#br232)[Function](#br232)[ ](#br232)[aob_dts_send_data](#br232)[ ](#br232)[Description](#br232)[ ](#br232)[.................................................................................................](#br232)[ ](#br232)[232](#br232)

[Table](#br232)[ ](#br232)[79](#br232)[ ](#br232)[Function](#br232)[ ](#br232)[aob_dts_disconnect](#br232)[ ](#br232)[Description.................................................................................................](#br232)[ ](#br232)[232](#br232)

[Table](#br233)[ ](#br233)[80](#br233)[ ](#br233)[DTS](#br233)[ ](#br233)[Callback](#br233)[ ](#br233)[handler](#br233)[ ](#br233)[Description...............................................................................................................](#br233)[ ](#br233)[233](#br233)

[Table](#br234)[ ](#br234)[81](#br234)[ ](#br234)[Function](#br234)[ ](#br234)[aob_dtc_connect](#br234)[ ](#br234)[Decription.......................................................................................................](#br234)[ ](#br234)[234](#br234)

[Table](#br234)[ ](#br234)[82](#br234)[ ](#br234)[Function](#br234)[ ](#br234)[aob_dtc_send_data](#br234)[ ](#br234)[Description](#br234)[ ](#br234)[.................................................................................................](#br234)[ ](#br234)[234](#br234)

[Table](#br235)[ ](#br235)[83](#br235)[ ](#br235)[Function](#br235)[ ](#br235)[aob_dtc_disconnect](#br235)[ ](#br235)[Description.................................................................................................](#br235)[ ](#br235)[235](#br235)

[Table](#br235)[ ](#br235)[84](#br235)[ ](#br235)[DTC](#br235)[ ](#br235)[Callback](#br235)[ ](#br235)[Handler](#br235)[ ](#br235)[Description..............................................................................................................](#br235)[ ](#br235)[235](#br235)

[Table](#br237)[ ](#br237)[85](#br237)[ ](#br237)[Command](#br237)[ ](#br237)[Entry](#br237)[ ](#br237)[Definition:........................................................................................................................](#br237)[ ](#br237)[237](#br237)

[Table](#br239)[ ](#br239)[86](#br239)[ ](#br239)[GATT](#br239)[ ](#br239)[Server](#br239)[ ](#br239)[User](#br239)[ ](#br239)[Callback](#br239)[ ](#br239)[Set](#br239)[ ](#br239)[...................................................................................................................](#br239)[ ](#br239)[239](#br239)

[Table](#br247)[ ](#br247)[87](#br247)[ ](#br247)[BLE](#br247)[ ](#br247)[TX](#br247)[ ](#br247)[Test](#br247)[ ](#br247)[.................................................................................................................................................](#br247)[ ](#br247)[247](#br247)

[Table](#br247)[ ](#br247)[88](#br247)[ ](#br247)[BLE](#br247)[ ](#br247)[RX](#br247)[ ](#br247)[Test.................................................................................................................................................](#br247)[ ](#br247)[247](#br247)

Rev 1.2 Page7 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

[Table](#br248)[ ](#br248)[89](#br248)[ ](#br248)[BLE](#br248)[ ](#br248)[service](#br248)[ ](#br248)[profile](#br248)[ ](#br248)[......................................................................................................................................](#br248)[ ](#br248)[248](#br248)

[Table](#br250)[ ](#br250)[90](#br250)[ ](#br250)[Data](#br250)[ ](#br250)[Format](#br250)[ ](#br250)[...............................................................................................................................................](#br250)[ ](#br250)[250](#br250)

[Table](#br250)[ ](#br250)[91](#br250)[ ](#br250)[Command](#br250)[ ](#br250)[Code](#br250)[ ](#br250)[List](#br250)[ ](#br250)[...................................................................................................................................](#br250)[ ](#br250)[250](#br250)

[Table](#br250)[ ](#br250)[92](#br250)[ ](#br250)[Data](#br250)[ ](#br250)[Format](#br250)[ ](#br250)[of](#br250)[ ](#br250)[Command](#br250)[ ](#br250)[Response](#br250)[ ](#br250)[.........................................................................................................](#br250)[ ](#br250)[250](#br250)

[Table](#br251)[ ](#br251)[93](#br251)[ ](#br251)[Error](#br251)[ ](#br251)[Code](#br251)[ ](#br251)[List............................................................................................................................................](#br251)[ ](#br251)[251](#br251)

[Table](#br252)[ ](#br252)[94](#br252)[ ](#br252)[Data](#br252)[ ](#br252)[Format](#br252)[ ](#br252)[...............................................................................................................................................](#br252)[ ](#br252)[252](#br252)

[Table](#br263)[ ](#br263)[95](#br263)[ ](#br263)[OTA](#br263)[ ](#br263)[Command](#br263)[ ](#br263)[Type...................................................................................................................................](#br263)[ ](#br263)[263](#br263)

[Table](#br263)[ ](#br263)[96](#br263)[ ](#br263)[OTA](#br263)[ ](#br263)[Command](#br263)[ ](#br263)[Descriprion........................................................................................................................](#br263)[ ](#br263)[263](#br263)

[Table](#br264)[ ](#br264)[97](#br264)[ ](#br264)[Transmission](#br264)[ ](#br264)[Resuming](#br264)[ ](#br264)[at](#br264)[ ](#br264)[Break](#br264)[ ](#br264)[Point](#br264)[ ](#br264)[(Request](#br264)[ ](#br264)[Packet)](#br264)[ ](#br264)[..........................................................................](#br264)[ ](#br264)[264](#br264)

[Table](#br264)[ ](#br264)[98](#br264)[ ](#br264)[Transmission](#br264)[ ](#br264)[Resuming](#br264)[ ](#br264)[at](#br264)[ ](#br264)[Break](#br264)[ ](#br264)[Point](#br264)[ ](#br264)[(Verification](#br264)[ ](#br264)[Response](#br264)[ ](#br264)[Packet)](#br264)[ ](#br264)[....................................................](#br264)[ ](#br264)[264](#br264)

[Table](#br265)[ ](#br265)[99](#br265)[ ](#br265)[Get](#br265)[ ](#br265)[a](#br265)[ ](#br265)[Current](#br265)[ ](#br265)[Version](#br265)[ ](#br265)[(Request](#br265)[ ](#br265)[Packet)](#br265)[ ](#br265)[....................................................................................................](#br265)[ ](#br265)[265](#br265)

[Table](#br265)[ ](#br265)[100](#br265)[ ](#br265)[Get](#br265)[ ](#br265)[a](#br265)[ ](#br265)[Current](#br265)[ ](#br265)[Version](#br265)[ ](#br265)[(Response](#br265)[ ](#br265)[Packet)](#br265)[ ](#br265)[................................................................................................](#br265)[ ](#br265)[265](#br265)

[Table](#br265)[ ](#br265)[101](#br265)[ ](#br265)[Start](#br265)[ ](#br265)[an](#br265)[ ](#br265)[OTA](#br265)[ ](#br265)[Task](#br265)[ ](#br265)[(Request](#br265)[ ](#br265)[Packet).........................................................................................................](#br265)[ ](#br265)[265](#br265)

[Table](#br266)[ ](#br266)[102](#br266)[ ](#br266)[Start](#br266)[ ](#br266)[an](#br266)[ ](#br266)[OTA](#br266)[ ](#br266)[Task](#br266)[ ](#br266)[(Response](#br266)[ ](#br266)[Packet).......................................................................................................](#br266)[ ](#br266)[266](#br266)

[Table](#br266)[ ](#br266)[103](#br266)[ ](#br266)[OTA](#br266)[ ](#br266)[Configuration](#br266)[ ](#br266)[Packet](#br266)[ ](#br266)[........................................................................................................................](#br266)[ ](#br266)[266](#br266)

[Table](#br267)[ ](#br267)[104](#br267)[ ](#br267)[OTA](#br267)[ ](#br267)[Configuration](#br267)[ ](#br267)[Respone](#br267)[ ](#br267)[Packet](#br267)[ ](#br267)[.........................................................................................................](#br267)[ ](#br267)[267](#br267)

[Table](#br267)[ ](#br267)[105](#br267)[ ](#br267)[Data](#br267)[ ](#br267)[Packet](#br267)[ ](#br267)[Description...........................................................................................................................](#br267)[ ](#br267)[267](#br267)

[Table](#br267)[ ](#br267)[106](#br267)[ ](#br267)[Segment](#br267)[ ](#br267)[CRC](#br267)[ ](#br267)[Verification](#br267)[ ](#br267)[Packet.............................................................................................................](#br267)[ ](#br267)[267](#br267)

[Table](#br267)[ ](#br267)[107](#br267)[ ](#br267)[Segement](#br267)[ ](#br267)[CRC](#br267)[ ](#br267)[Verification](#br267)[ ](#br267)[Response](#br267)[ ](#br267)[Packet...........................................................................................](#br267)[ ](#br267)[267](#br267)

[Table](#br268)[ ](#br268)[108](#br268)[ ](#br268)[Whole-image](#br268)[ ](#br268)[CRC](#br268)[ ](#br268)[Check](#br268)[ ](#br268)[Packet](#br268)[ ](#br268)[..............................................................................................................](#br268)[ ](#br268)[268](#br268)

[Table](#br268)[ ](#br268)[109](#br268)[ ](#br268)[OTA](#br268)[ ](#br268)[Result](#br268)[ ](#br268)[Response](#br268)[ ](#br268)[Packet....................................................................................................................](#br268)[ ](#br268)[268](#br268)

[Table](#br268)[ ](#br268)[110](#br268)[ ](#br268)[New-image](#br268)[ ](#br268)[Side](#br268)[ ](#br268)[Selection](#br268)[ ](#br268)[Packet](#br268)[ ](#br268)[............................................................................................................](#br268)[ ](#br268)[268](#br268)

[Table](#br268)[ ](#br268)[111](#br268)[ ](#br268)[New-image](#br268)[ ](#br268)[Side](#br268)[ ](#br268)[Selection](#br268)[ ](#br268)[Response](#br268)[ ](#br268)[Packet............................................................................................](#br268)[ ](#br268)[268](#br268)

[Table](#br269)[ ](#br269)[112](#br269)[ ](#br269)[Image](#br269)[ ](#br269)[Overwriting](#br269)[ ](#br269)[Confirmation](#br269)[ ](#br269)[Packet..................................................................................................](#br269)[ ](#br269)[269](#br269)

[Table](#br269)[ ](#br269)[113](#br269)[ ](#br269)[Image](#br269)[ ](#br269)[Overwriting](#br269)[ ](#br269)[Confirmation](#br269)[ ](#br269)[Response](#br269)[ ](#br269)[Packet](#br269)[ ](#br269)[.................................................................................](#br269)[ ](#br269)[269](#br269)

[Table](#br269)[ ](#br269)[114](#br269)[ ](#br269)[Set](#br269)[ ](#br269)[an](#br269)[ ](#br269)[OTA](#br269)[ ](#br269)[User](#br269)[ ](#br269)[.......................................................................................................................................](#br269)[ ](#br269)[269](#br269)

[Table](#br269)[ ](#br269)[115](#br269)[ ](#br269)[Set](#br269)[ ](#br269)[an](#br269)[ ](#br269)[OTA](#br269)[ ](#br269)[Version](#br269)[ ](#br269)[(Response](#br269)[ ](#br269)[Packet)](#br269)[ ](#br269)[....................................................................................................](#br269)[ ](#br269)[269](#br269)

[Table](#br270)[ ](#br270)[116](#br270)[ ](#br270)[Get](#br270)[ ](#br270)[an](#br270)[ ](#br270)[OTA](#br270)[ ](#br270)[Version..................................................................................................................................](#br270)[ ](#br270)[270](#br270)

[Table](#br270)[ ](#br270)[117Get](#br270)[ ](#br270)[an](#br270)[ ](#br270)[OTA](#br270)[ ](#br270)[Version](#br270)[ ](#br270)[(Response](#br270)[ ](#br270)[Packet)](#br270)[ ](#br270)[....................................................................................................](#br270)[ ](#br270)[270](#br270)

[Table](#br307)[ ](#br307)[118](#br307)[ ](#br307)[HFSR](#br307)[ ](#br307)[Bit](#br307)[ ](#br307)[Assigments.................................................................................................................................](#br307)[ ](#br307)[307](#br307)

[Table](#br308)[ ](#br308)[119](#br308)[ ](#br308)[MMFSR](#br308)[ ](#br308)[Bit](#br308)[ ](#br308)[Assignments](#br308)[ ](#br308)[..........................................................................................................................](#br308)[ ](#br308)[308](#br308)

[Table](#br311)[ ](#br311)[120](#br311)[ ](#br311)[BFSR](#br311)[ ](#br311)[Bit](#br311)[ ](#br311)[Assignments...............................................................................................................................](#br311)[ ](#br311)[311](#br311)

[Table](#br313)[ ](#br313)[121](#br313)[ ](#br313)[UFSR](#br313)[ ](#br313)[Bit](#br313)[ ](#br313)[Assignments...............................................................................................................................](#br313)[ ](#br313)[313](#br313)

**List of Figures**

[Figure](#br16)[ ](#br16)[1](#br16)[ ](#br16)[Building](#br16)[ ](#br16)[Command........................................................................................................................................](#br16)[ ](#br16)[16](#br16)

[Figure](#br17)[ ](#br17)[2](#br17)[ ](#br17)[Compilation](#br17)[ ](#br17)[Generated](#br17)[ ](#br17)[Files.........................................................................................................................](#br17)[ ](#br17)[17](#br17)

[Figure](#br18)[ ](#br18)[3](#br18)[ ](#br18)[BES](#br18)[ ](#br18)[Evaluation](#br18)[ ](#br18)[Board](#br18)[ ](#br18)[Set-up.........................................................................................................................](#br18)[ ](#br18)[18](#br18)

[Figure](#br19)[ ](#br19)[4](#br19)[ ](#br19)[Emulate](#br19)[ ](#br19)[Download](#br19)[ ](#br19)[Serial](#br19)[ ](#br19)[Ports.....................................................................................................................](#br19)[ ](#br19)[19](#br19)

[Figure](#br19)[ ](#br19)[5](#br19)[ ](#br19)[Enter](#br19)[ ](#br19)[User](#br19)[ ](#br19)[Account](#br19)[ ](#br19)[and](#br19)[ ](#br19)[Password................................................................................................................](#br19)[ ](#br19)[19](#br19)

[Figure](#br20)[ ](#br20)[6](#br20)[ ](#br20)[Image](#br20)[ ](#br20)[Downloading](#br20)[ ](#br20)[Configuration](#br20)[ ](#br20)[...............................................................................................................](#br20)[ ](#br20)[20](#br20)

[Figure](#br21)[ ](#br21)[7](#br21)[ ](#br21)[Image](#br21)[ ](#br21)[Downloading](#br21)[ ](#br21)[......................................................................................................................................](#br21)[ ](#br21)[21](#br21)

[Figure](#br21)[ ](#br21)[8](#br21)[ ](#br21)[Image](#br21)[ ](#br21)[Downloading](#br21)[ ](#br21)[Completed....................................................................................................................](#br21)[ ](#br21)[21](#br21)

[Figure](#br22)[ ](#br22)[9](#br22)[ ](#br22)[Image](#br22)[ ](#br22)[Bootup](#br22)[ ](#br22)[Log](#br22)[ ](#br22)[Printing](#br22)[ ](#br22)[in](#br22)[ ](#br22)[UART..............................................................................................................](#br22)[ ](#br22)[22](#br22)

Rev 1.2 Page8 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

[Figure](#br22)[ ](#br22)[10](#br22)[ ](#br22)[Log](#br22)[ ](#br22)[Printing](#br22)[ ](#br22)[of](#br22)[ ](#br22)[TWS](#br22)[ ](#br22)[Connection](#br22)[ ](#br22)[.................................................................................................................](#br22)[ ](#br22)[22](#br22)

[Figure](#br23)[ ](#br23)[11](#br23)[ ](#br23)[Log](#br23)[ ](#br23)[Printing](#br23)[ ](#br23)[of](#br23)[ ](#br23)[Mobile](#br23)[ ](#br23)[Connection](#br23)[ ](#br23)[.............................................................................................................](#br23)[ ](#br23)[23](#br23)

[Figure](#br24)[ ](#br24)[12](#br24)[ ](#br24)[Software](#br24)[ ](#br24)[Architecture.................................................................................................................................](#br24)[ ](#br24)[24](#br24)

[Figure](#br25)[ ](#br25)[13](#br25)[ ](#br25)[Main](#br25)[ ](#br25)[MCU](#br25)[ ](#br25)[Functions...................................................................................................................................](#br25)[ ](#br25)[25](#br25)

[Figure](#br25)[ ](#br25)[14](#br25)[ ](#br25)[SDK](#br25)[ ](#br25)[Folder](#br25)[ ](#br25)[Structure...................................................................................................................................](#br25)[ ](#br25)[25](#br25)

[Figure](#br27)[ ](#br27)[15](#br27)[ ](#br27)[SDK](#br27)[ ](#br27)[Data](#br27)[ ](#br27)[Flow.............................................................................................................................................](#br27)[ ](#br27)[27](#br27)

[Figure](#br55)[ ](#br55)[16](#br55)[ ](#br55)[Logical](#br55)[ ](#br55)[Address](#br55)[ ](#br55)[Map](#br55)[ ](#br55)[...................................................................................................................................](#br55)[ ](#br55)[55](#br55)

[Figure](#br56)[ ](#br56)[17](#br56)[ ](#br56)[Flash](#br56)[ ](#br56)[Memory](#br56)[ ](#br56)[Map](#br56)[ ](#br56)[for](#br56)[ ](#br56)[OTA........................................................................................................................](#br56)[ ](#br56)[56](#br56)

[Figure](#br64)[ ](#br64)[18](#br64)[ ](#br64)[UART](#br64)[ ](#br64)[Data](#br64)[ ](#br64)[Path...........................................................................................................................................](#br64)[ ](#br64)[64](#br64)

[Figure](#br70)[ ](#br70)[19](#br70)[ ](#br70)[Core](#br70)[ ](#br70)[Bridge](#br70)[ ](#br70)[Communication](#br70)[ ](#br70)[Datapath](#br70)[ ](#br70)[between](#br70)[ ](#br70)[MCU](#br70)[ ](#br70)[and](#br70)[ ](#br70)[Sensor](#br70)[ ](#br70)[Hub](#br70)[ ](#br70)[Core](#br70)[ ](#br70)[............................................](#br70)[ ](#br70)[70](#br70)

[Figure](#br73)[ ](#br73)[20](#br73)[ ](#br73)[Log](#br73)[ ](#br73)[Printing](#br73)[ ](#br73)[of](#br73)[ ](#br73)[Sensor](#br73)[ ](#br73)[Hub](#br73)[ ](#br73)[Bootup.............................................................................................................](#br73)[ ](#br73)[73](#br73)

[Figure](#br74)[ ](#br74)[21](#br74)[ ](#br74)[Log](#br74)[ ](#br74)[Printing](#br74)[ ](#br74)[of](#br74)[ ](#br74)[M55](#br74)[ ](#br74)[Bootup........................................................................................................................](#br74)[ ](#br74)[74](#br74)

[Figure](#br78)[ ](#br78)[22](#br78)[ ](#br78)[Sleep](#br78)[ ](#br78)[and](#br78)[ ](#br78)[Wake-up](#br78)[ ](#br78)[.....................................................................................................................................](#br78)[ ](#br78)[78](#br78)

[Figure](#br80)[ ](#br80)[23](#br80)[ ](#br80)[Jump](#br80)[ ](#br80)[to](#br80)[ ](#br80)[Ram](#br80)[ ](#br80)[Run](#br80)[ ](#br80)[........................................................................................................................................](#br80)[ ](#br80)[80](#br80)

[Figure](#br81)[ ](#br81)[24](#br81)[ ](#br81)[Jump](#br81)[ ](#br81)[to](#br81)[ ](#br81)[Secondary](#br81)[ ](#br81)[Bootloader](#br81)[ ](#br81)[in](#br81)[ ](#br81)[Flash......................................................................................................](#br81)[ ](#br81)[81](#br81)

[Figure](#br82)[ ](#br82)[25](#br82)[ ](#br82)[Application](#br82)[ ](#br82)[Image](#br82)[ ](#br82)[Init.................................................................................................................................](#br82)[ ](#br82)[82](#br82)

[Figure](#br83)[ ](#br83)[26](#br83)[ ](#br83)[Sensor](#br83)[ ](#br83)[Core](#br83)[ ](#br83)[Flow](#br83)[ ](#br83)[........................................................................................................................................](#br83)[ ](#br83)[83](#br83)

[Figure](#br96)[ ](#br96)[27](#br96)[ ](#br96)[Async](#br96)[ ](#br96)[Flash](#br96)[ ](#br96)[Erasing/Programing.................................................................................................................](#br96)[ ](#br96)[96](#br96)

[Figure](#br97)[ ](#br97)[28](#br97)[ ](#br97)[Sync](#br97)[ ](#br97)[Flash](#br97)[ ](#br97)[Erasing/Programing...................................................................................................................](#br97)[ ](#br97)[97](#br97)

[Figure](#br98)[ ](#br98)[29](#br98)[ ](#br98)[Sync](#br98)[ ](#br98)[Flash](#br98)[ ](#br98)[Erasing/Programing](#br98)[ ](#br98)[Influence](#br98)[ ](#br98)[on](#br98)[ ](#br98)[DMA](#br98)[ ](#br98)[Chain...........................................................................](#br98)[ ](#br98)[98](#br98)

[Figure](#br102)[ ](#br102)[30](#br102)[ ](#br102)[Location](#br102)[ ](#br102)[of](#br102)[ ](#br102)[Parameter](#br102)[ ](#br102)[Sector](#br102)[ ](#br102)[...................................................................................................................](#br102)[ ](#br102)[102](#br102)

[Figure](#br108)[ ](#br108)[31](#br108)[ ](#br108)[Thread](#br108)[ ](#br108)[Scheduling](#br108)[ ](#br108)[and](#br108)[ ](#br108)[Interrupt](#br108)[ ](#br108)[Execution](#br108)[ ](#br108)[.............................................................................................](#br108)[ ](#br108)[108](#br108)

[Figure](#br113)[ ](#br113)[32](#br113)[ ](#br113)[Simple](#br113)[ ](#br113)[Event](#br113)[ ](#br113)[Communication...................................................................................................................](#br113)[ ](#br113)[113](#br113)

[Figure](#br116)[ ](#br116)[33](#br116)[ ](#br116)[CMSIS-RTOS](#br116)[ ](#br116)[Semaphore...........................................................................................................................](#br116)[ ](#br116)[116](#br116)

[Figure](#br119)[ ](#br119)[34](#br119)[ ](#br119)[Thread](#br119)[ ](#br119)[Statistics](#br119)[ ](#br119)[Log](#br119)[ ](#br119)[Demo.......................................................................................................................](#br119)[ ](#br119)[119](#br119)

[Figure](#br126)[ ](#br126)[35](#br126)[ ](#br126)[Audio](#br126)[ ](#br126)[Path](#br126)[ ](#br126)[Flow](#br126)[ ](#br126)[of](#br126)[ ](#br126)[Phone](#br126)[ ](#br126)[Call..................................................................................................................](#br126)[ ](#br126)[126](#br126)

[Figure](#br127)[ ](#br127)[36](#br127)[ ](#br127)[Audio](#br127)[ ](#br127)[Path](#br127)[ ](#br127)[Flow](#br127)[ ](#br127)[of](#br127)[ ](#br127)[Music](#br127)[ ](#br127)[Playback](#br127)[ ](#br127)[..........................................................................................................](#br127)[ ](#br127)[127](#br127)

[Figure](#br128)[ ](#br128)[37](#br128)[ ](#br128)[Audio](#br128)[ ](#br128)[Info](#br128)[ ](#br128)[Sync](#br128)[ ](#br128)[of](#br128)[ ](#br128)[Music](#br128)[ ](#br128)[Playback............................................................................................................](#br128)[ ](#br128)[128](#br128)

[Figure](#br133)[ ](#br133)[38](#br133)[ ](#br133)[Convert](#br133)[ ](#br133)[Command....................................................................................................................................](#br133)[ ](#br133)[133](#br133)

[Figure](#br134)[ ](#br134)[39](#br134)[ ](#br134)[File](#br134)[ ](#br134)[Relocation...........................................................................................................................................](#br134)[ ](#br134)[134](#br134)

[Figure](#br144)[ ](#br144)[40](#br144)[ ](#br144)[Summary](#br144)[ ](#br144)[Architecture..............................................................................................................................](#br144)[ ](#br144)[144](#br144)

[Figure](#br145)[ ](#br145)[41](#br145)[ ](#br145)[Software](#br145)[ ](#br145)[Architecture...............................................................................................................................](#br145)[ ](#br145)[145](#br145)

[Figure](#br147)[ ](#br147)[42](#br147)[ ](#br147)[BT](#br147)[ ](#br147)[Mac](#br147)[ ](#br147)[Address](#br147)[ ](#br147)[and](#br147)[ ](#br147)[Bt](#br147)[ ](#br147)[Name](#br147)[ ](#br147)[Configuration............................................................................................](#br147)[ ](#br147)[147](#br147)

[Figure](#br170)[ ](#br170)[43](#br170)[ ](#br170)[Host](#br170)[ ](#br170)[Flow](#br170)[ ](#br170)[..................................................................................................................................................](#br170)[ ](#br170)[170](#br170)

[Figure](#br171)[ ](#br171)[44](#br171)[ ](#br171)[Flow](#br171)[ ](#br171)[Path](#br171)[ ](#br171)[of](#br171)[ ](#br171)[Role](#br171)[ ](#br171)[Switch](#br171)[ ](#br171)[Preparation.......................................................................................................](#br171)[ ](#br171)[171](#br171)

[Figure](#br172)[ ](#br172)[45](#br172)[ ](#br172)[Flow](#br172)[ ](#br172)[Path](#br172)[ ](#br172)[of](#br172)[ ](#br172)[Role](#br172)[ ](#br172)[Switch](#br172)[ ](#br172)[Post](#br172)[ ](#br172)[Operation](#br172)[ ](#br172)[.................................................................................................](#br172)[ ](#br172)[172](#br172)

[Figure](#br172)[ ](#br172)[46](#br172)[ ](#br172)[Role](#br172)[ ](#br172)[Switch](#br172)[ ](#br172)[Controller](#br172)[ ](#br172)[Operation](#br172)[ ](#br172)[.............................................................................................................](#br172)[ ](#br172)[172](#br172)

[Figure](#br181)[ ](#br181)[47](#br181)[ ](#br181)[Configure](#br181)[ ](#br181)[BLE](#br181)[ ](#br181)[Mac](#br181)[ ](#br181)[Address](#br181)[ ](#br181)[and](#br181)[ ](#br181)[BLE](#br181)[ ](#br181)[Name..............................................................................................](#br181)[ ](#br181)[181](#br181)

[Figure](#br218)[ ](#br218)[48](#br218)[ ](#br218)[Connection](#br218)[ ](#br218)[Parameter](#br218)[ ](#br218)[Update](#br218)[ ](#br218)[Policy.......................................................................................................](#br218)[ ](#br218)[218](#br218)

[Figure](#br222)[ ](#br222)[49](#br222)[ ](#br222)[BLE](#br222)[ ](#br222)[Connection](#br222)[ ](#br222)[Process............................................................................................................................](#br222)[ ](#br222)[222](#br222)

[Figure](#br224)[ ](#br224)[50](#br224)[ ](#br224)[BLE](#br224)[ ](#br224)[Profile](#br224)[ ](#br224)[Functional](#br224)[ ](#br224)[Division..................................................................................................................](#br224)[ ](#br224)[224](#br224)

[Figure](#br231)[ ](#br231)[51](#br231)[ ](#br231)[l2cap](#br231)[ ](#br231)[Connection](#br231)[ ](#br231)[......................................................................................................................................](#br231)[ ](#br231)[231](#br231)

[Figure](#br237)[ ](#br237)[52](#br237)[ ](#br237)[L2CAP](#br237)[ ](#br237)[Connection](#br237)[ ](#br237)[Datapath.....................................................................................................................](#br237)[ ](#br237)[237](#br237)

[Figure](#br241)[ ](#br241)[53](#br241)[ ](#br241)[Test](#br241)[ ](#br241)[Setup](#br241)[ ](#br241)[.................................................................................................................................................](#br241)[ ](#br241)[241](#br241)

[Figure](#br243)[ ](#br243)[54](#br243)[ ](#br243)[Test](#br243)[ ](#br243)[Setup](#br243)[ ](#br243)[.................................................................................................................................................](#br243)[ ](#br243)[243](#br243)

Rev 1.2 Page9 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

[Figure](#br248)[ ](#br248)[55](#br248)[ ](#br248)[BLE](#br248)[ ](#br248)[Data](#br248)[ ](#br248)[Path............................................................................................................................................](#br248)[ ](#br248)[248](#br248)

[Figure](#br249)[ ](#br249)[56](#br249)[ ](#br249)[BT](#br249)[ ](#br249)[Data](#br249)[ ](#br249)[Path..............................................................................................................................................](#br249)[ ](#br249)[249](#br249)

[Figure](#br250)[ ](#br250)[57](#br250)[ ](#br250)[Command..................................................................................................................................................](#br250)[ ](#br250)[250](#br250)

[Figure](#br252)[ ](#br252)[58](#br252)[ ](#br252)[Throughput](#br252)[ ](#br252)[Test](#br252)[ ](#br252)[Procedure......................................................................................................................](#br252)[ ](#br252)[252](#br252)

[Figure](#br255)[ ](#br255)[59](#br255)[ ](#br255)[Bestechnic](#br255)[ ](#br255)[for](#br255)[ ](#br255)[Testing](#br255)[ ](#br255)[Throughput...........................................................................................................](#br255)[ ](#br255)[255](#br255)

[Figure](#br256)[ ](#br256)[60](#br256)[ ](#br256)[THROUGH](#br256)[ ](#br256)[PUT](#br256)[ ](#br256)[Interface...........................................................................................................................](#br256)[ ](#br256)[256](#br256)

[Figure](#br257)[ ](#br257)[61](#br257)[ ](#br257)[SW](#br257)[ ](#br257)[Image](#br257)[ ](#br257)[Power](#br257)[ ](#br257)[Off](#br257)[ ](#br257)[Flow](#br257)[ ](#br257)[........................................................................................................................](#br257)[ ](#br257)[257](#br257)

[Figure](#br258)[ ](#br258)[62](#br258)[ ](#br258)[BES](#br258)[ ](#br258)[ThroughPut](#br258)[ ](#br258)[Main](#br258)[ ](#br258)[Interface................................................................................................................](#br258)[ ](#br258)[258](#br258)

[Figure](#br258)[ ](#br258)[63](#br258)[ ](#br258)[Choose](#br258)[ ](#br258)[Bluetooth](#br258)[ ](#br258)[.....................................................................................................................................](#br258)[ ](#br258)[258](#br258)

[Figure](#br259)[ ](#br259)[64](#br259)[ ](#br259)[SPP](#br259)[ ](#br259)[Test.....................................................................................................................................................](#br259)[ ](#br259)[259](#br259)

[Figure](#br260)[ ](#br260)[65](#br260)[ ](#br260)[Main](#br260)[ ](#br260)[Flash](#br260)[ ](#br260)[Section](#br260)[ ](#br260)[....................................................................................................................................](#br260)[ ](#br260)[260](#br260)

[Figure](#br261)[ ](#br261)[66](#br261)[ ](#br261)[OTA](#br261)[ ](#br261)[Flow...................................................................................................................................................](#br261)[ ](#br261)[261](#br261)

[Figure](#br262)[ ](#br262)[67](#br262)[ ](#br262)[Boot](#br262)[ ](#br262)[Area](#br262)[ ](#br262)[Selection...................................................................................................................................](#br262)[ ](#br262)[262](#br262)

[Figure](#br271)[ ](#br271)[68](#br271)[ ](#br271)[Upgrade](#br271)[ ](#br271)[Process](#br271)[ ](#br271)[.......................................................................................................................................](#br271)[ ](#br271)[271](#br271)

[Figure](#br278)[ ](#br278)[69](#br278)[ ](#br278)[Burn](#br278)[ ](#br278)[with](#br278)[ ](#br278)[OTA](#br278)[ ](#br278)[BOOT.................................................................................................................................](#br278)[ ](#br278)[278](#br278)

[Figure](#br279)[ ](#br279)[70](#br279)[ ](#br279)[Main](#br279)[ ](#br279)[View](#br279)[ ](#br279)[.................................................................................................................................................](#br279)[ ](#br279)[279](#br279)

[Figure](#br279)[ ](#br279)[71](#br279)[ ](#br279)[Pairing](#br279)[ ](#br279)[.......................................................................................................................................................](#br279)[ ](#br279)[279](#br279)

[Figure](#br280)[ ](#br280)[72](#br280)[ ](#br280)[Device](#br280)[ ](#br280)[Selection........................................................................................................................................](#br280)[ ](#br280)[280](#br280)

[Figure](#br281)[ ](#br281)[73](#br281)[ ](#br281)[Configure](#br281)[ ](#br281)[Upgrade....................................................................................................................................](#br281)[ ](#br281)[281](#br281)

[Figure](#br281)[ ](#br281)[74](#br281)[ ](#br281)[Device](#br281)[ ](#br281)[Connection](#br281)[ ](#br281)[....................................................................................................................................](#br281)[ ](#br281)[281](#br281)

[Figure](#br282)[ ](#br282)[75](#br282)[ ](#br282)[Image](#br282)[ ](#br282)[Selection.........................................................................................................................................](#br282)[ ](#br282)[282](#br282)

[Figure](#br282)[ ](#br282)[76](#br282)[ ](#br282)[Start](#br282)[ ](#br282)[OTA](#br282)[ ](#br282)[Process......................................................................................................................................](#br282)[ ](#br282)[282](#br282)

[Figure](#br283)[ ](#br283)[77](#br283)[ ](#br283)[OTA](#br283)[ ](#br283)[Process](#br283)[ ](#br283)[Completed............................................................................................................................](#br283)[ ](#br283)[283](#br283)

[Figure](#br283)[ ](#br283)[78](#br283)[ ](#br283)[Main](#br283)[ ](#br283)[View](#br283)[ ](#br283)[.................................................................................................................................................](#br283)[ ](#br283)[283](#br283)

[Figure](#br284)[ ](#br284)[79](#br284)[ ](#br284)[Pairing](#br284)[ ](#br284)[and](#br284)[ ](#br284)[Connection.............................................................................................................................](#br284)[ ](#br284)[284](#br284)

[Figure](#br284)[ ](#br284)[80](#br284)[ ](#br284)[Device](#br284)[ ](#br284)[Selection........................................................................................................................................](#br284)[ ](#br284)[284](#br284)

[Figure](#br285)[ ](#br285)[81](#br285)[ ](#br285)[Configure](#br285)[ ](#br285)[Upgrade....................................................................................................................................](#br285)[ ](#br285)[285](#br285)

[Figure](#br286)[ ](#br286)[82](#br286)[ ](#br286)[Device](#br286)[ ](#br286)[Connection](#br286)[ ](#br286)[....................................................................................................................................](#br286)[ ](#br286)[286](#br286)

[Figure](#br286)[ ](#br286)[83](#br286)[ ](#br286)[Image](#br286)[ ](#br286)[Selection.........................................................................................................................................](#br286)[ ](#br286)[286](#br286)

[Figure](#br287)[ ](#br287)[84](#br287)[ ](#br287)[Start](#br287)[ ](#br287)[OTA](#br287)[ ](#br287)[Process......................................................................................................................................](#br287)[ ](#br287)[287](#br287)

[Figure](#br287)[ ](#br287)[85](#br287)[ ](#br287)[Upgrade](#br287)[ ](#br287)[Completed..................................................................................................................................](#br287)[ ](#br287)[287](#br287)

[Figure](#br288)[ ](#br288)[86](#br288)[ ](#br288)[Main](#br288)[ ](#br288)[View](#br288)[ ](#br288)[.................................................................................................................................................](#br288)[ ](#br288)[288](#br288)

[Figure](#br289)[ ](#br289)[87](#br289)[ ](#br289)[Pairing](#br289)[ ](#br289)[.......................................................................................................................................................](#br289)[ ](#br289)[289](#br289)

[Figure](#br289)[ ](#br289)[88](#br289)[ ](#br289)[Device](#br289)[ ](#br289)[Selection........................................................................................................................................](#br289)[ ](#br289)[289](#br289)

[Figure](#br290)[ ](#br290)[89](#br290)[ ](#br290)[Configure](#br290)[ ](#br290)[Upgrade....................................................................................................................................](#br290)[ ](#br290)[290](#br290)

[Figure](#br291)[ ](#br291)[90](#br291)[ ](#br291)[Device](#br291)[ ](#br291)[Connection](#br291)[ ](#br291)[....................................................................................................................................](#br291)[ ](#br291)[291](#br291)

[Figure](#br291)[ ](#br291)[91](#br291)[ ](#br291)[Image](#br291)[ ](#br291)[Selection.........................................................................................................................................](#br291)[ ](#br291)[291](#br291)

[Figure](#br292)[ ](#br292)[92](#br292)[ ](#br292)[Start](#br292)[ ](#br292)[OTA](#br292)[ ](#br292)[Process......................................................................................................................................](#br292)[ ](#br292)[292](#br292)

[Figure](#br292)[ ](#br292)[93](#br292)[ ](#br292)[OTA](#br292)[ ](#br292)[Completed.........................................................................................................................................](#br292)[ ](#br292)[292](#br292)

[Figure](#br293)[ ](#br293)[94](#br293)[ ](#br293)[Main](#br293)[ ](#br293)[View](#br293)[ ](#br293)[.................................................................................................................................................](#br293)[ ](#br293)[293](#br293)

[Figure](#br294)[ ](#br294)[95](#br294)[ ](#br294)[Pairing](#br294)[ ](#br294)[and](#br294)[ ](#br294)[Connection.............................................................................................................................](#br294)[ ](#br294)[294](#br294)

[Figure](#br294)[ ](#br294)[96](#br294)[ ](#br294)[Device](#br294)[ ](#br294)[Selection........................................................................................................................................](#br294)[ ](#br294)[294](#br294)

[Figure](#br295)[ ](#br295)[97](#br295)[ ](#br295)[Configure](#br295)[ ](#br295)[Upgrade....................................................................................................................................](#br295)[ ](#br295)[295](#br295)

[Figure](#br296)[ ](#br296)[98](#br296)[ ](#br296)[Device](#br296)[ ](#br296)[Connection](#br296)[ ](#br296)[....................................................................................................................................](#br296)[ ](#br296)[296](#br296)

[Figure](#br296)[ ](#br296)[99](#br296)[ ](#br296)[Image](#br296)[ ](#br296)[Selection.........................................................................................................................................](#br296)[ ](#br296)[296](#br296)

Rev 1.2 Page10 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

[Figure](#br297)[ ](#br297)[100](#br297)[ ](#br297)[Start](#br297)[ ](#br297)[OTA](#br297)[ ](#br297)[Process....................................................................................................................................](#br297)[ ](#br297)[297](#br297)

[Figure](#br297)[ ](#br297)[101](#br297)[ ](#br297)[Upgrade](#br297)[ ](#br297)[Completed................................................................................................................................](#br297)[ ](#br297)[297](#br297)

[Figure](#br298)[ ](#br298)[102](#br298)[ ](#br298)[TOTA](#br298)[ ](#br298)[Packet](#br298)[ ](#br298)[Format](#br298)[ ](#br298)[...............................................................................................................................](#br298)[ ](#br298)[298](#br298)

[Figure](#br299)[ ](#br299)[103](#br299)[ ](#br299)[Interaction](#br299)[ ](#br299)[Process](#br299)[ ](#br299)[of](#br299)[ ](#br299)[TOTA](#br299)[ ](#br299)[Test............................................................................................................](#br299)[ ](#br299)[299](#br299)

[Figure](#br300)[ ](#br300)[104](#br300)[ ](#br300)[Message](#br300)[ ](#br300)[Receiving](#br300)[ ](#br300)[Process.....................................................................................................................](#br300)[ ](#br300)[300](#br300)

[Figure](#br301)[ ](#br301)[105](#br301)[ ](#br301)[Message](#br301)[ ](#br301)[Sending](#br301)[ ](#br301)[Process](#br301)[ ](#br301)[.......................................................................................................................](#br301)[ ](#br301)[301](#br301)

[Figure](#br302)[ ](#br302)[106](#br302)[ ](#br302)[IOS](#br302)[ ](#br302)[App](#br302)[ ](#br302)[Operation](#br302)[ ](#br302)[Process.....................................................................................................................](#br302)[ ](#br302)[302](#br302)

[Figure](#br303)[ ](#br303)[107](#br303)[ ](#br303)[Android](#br303)[ ](#br303)[App](#br303)[ ](#br303)[Operation](#br303)[ ](#br303)[Process..............................................................................................................](#br303)[ ](#br303)[303](#br303)

[Figure](#br303)[ ](#br303)[108](#br303)[ ](#br303)[App](#br303)[ ](#br303)[Console](#br303)[ ](#br303)[Log......................................................................................................................................](#br303)[ ](#br303)[303](#br303)

[Figure](#br304)[ ](#br304)[109](#br304)[ ](#br304)[Firmware](#br304)[ ](#br304)[Serial](#br304)[ ](#br304)[Port](#br304)[ ](#br304)[Log.........................................................................................................................](#br304)[ ](#br304)[304](#br304)

[Figure](#br306)[ ](#br306)[110](#br306)[ ](#br306)[SHCSR](#br306)[ ](#br306)[Bit](#br306)[ ](#br306)[Assignmonts](#br306)[ ](#br306)[...........................................................................................................................](#br306)[ ](#br306)[306](#br306)

[Figure](#br306)[ ](#br306)[111](#br306)[ ](#br306)[HardFault](#br306)[ ](#br306)[Status](#br306)[ ](#br306)[Register](#br306)[ ](#br306)[.......................................................................................................................](#br306)[ ](#br306)[306](#br306)

[Figure](#br308)[ ](#br308)[112](#br308)[ ](#br308)[MemManage](#br308)[ ](#br308)[Fault](#br308)[ ](#br308)[Status](#br308)[ ](#br308)[Register.........................................................................................................](#br308)[ ](#br308)[308](#br308)

[Figure](#br311)[ ](#br311)[113](#br311)[ ](#br311)[BusFault](#br311)[ ](#br311)[Status](#br311)[ ](#br311)[Register..........................................................................................................................](#br311)[ ](#br311)[311](#br311)

[Figure](#br313)[ ](#br313)[114](#br313)[ ](#br313)[UsageFault](#br313)[ ](#br313)[Status](#br313)[ ](#br313)[Register](#br313)[ ](#br313)[.....................................................................................................................](#br313)[ ](#br313)[313](#br313)

[Figure](#br315)[ ](#br315)[115](#br315)[ ](#br315)[Mem](#br315)[ ](#br315)[Fault](#br315)[ ](#br315)[Dump](#br315)[ ](#br315)[....................................................................................................................................](#br315)[ ](#br315)[315](#br315)

[Figure](#br316)[ ](#br316)[116](#br316)[ ](#br316)[Instruction](#br316)[ ](#br316)[bus](#br316)[ ](#br316)[error](#br316)[ ](#br316)[Dump](#br316)[ ](#br316)[....................................................................................................................](#br316)[ ](#br316)[316](#br316)

[Figure](#br317)[ ](#br317)[117](#br317)[ ](#br317)[Precise](#br317)[ ](#br317)[Data](#br317)[ ](#br317)[Bus](#br317)[ ](#br317)[Error](#br317)[ ](#br317)[Dump..................................................................................................................](#br317)[ ](#br317)[317](#br317)

[Figure](#br318)[ ](#br318)[118](#br318)[ ](#br318)[Usage](#br318)[ ](#br318)[Fault](#br318)[ ](#br318)[Dump...................................................................................................................................](#br318)[ ](#br318)[318](#br318)

[Figure](#br318)[ ](#br318)[119](#br318)[ ](#br318)[Hard](#br318)[ ](#br318)[Fault](#br318)[ ](#br318)[Dump.....................................................................................................................................](#br318)[ ](#br318)[318](#br318)

[Figure](#br320)[ ](#br320)[120](#br320)[ ](#br320)[Deadlock](#br320)[ ](#br320)[Causes](#br320)[ ](#br320)[Watchdog](#br320)[ ](#br320)[Crash..........................................................................................................](#br320)[ ](#br320)[320](#br320)

[Figure](#br323)[ ](#br323)[121](#br323)[ ](#br323)[Stack](#br323)[ ](#br323)[Smashing........................................................................................................................................](#br323)[ ](#br323)[323](#br323)

[Figure](#br324)[ ](#br324)[122](#br324)[ ](#br324)[Install](#br324)[ ](#br324)[gcc-arm-none-eabi](#br324)[ ](#br324)[.......................................................................................................................](#br324)[ ](#br324)[324](#br324)

[Figure](#br324)[ ](#br324)[123](#br324)[ ](#br324)[Get](#br324)[ ](#br324)[Crash](#br324)[ ](#br324)[Location..................................................................................................................................](#br324)[ ](#br324)[324](#br324)

[Figure](#br327)[ ](#br327)[124](#br327)[ ](#br327)[power_consumption_thread](#br327)[ ](#br327)[Infomation](#br327)[ ](#br327)[...............................................................................................](#br327)[ ](#br327)[327](#br327)

[Figure](#br329)[ ](#br329)[125](#br329)[ ](#br329)[Thread](#br329)[ ](#br329)[Information.................................................................................................................................](#br329)[ ](#br329)[329](#br329)

[Figure](#br330)[ ](#br330)[126](#br330)[ ](#br330)[Audio](#br330)[ ](#br330)[Developer](#br330)[ ](#br330)[GUI](#br330)[ ](#br330)[..............................................................................................................................](#br330)[ ](#br330)[330](#br330)

[Figure](#br331)[ ](#br331)[127](#br331)[ ](#br331)[COM](#br331)[ ](#br331)[........................................................................................................................................................](#br331)[ ](#br331)[331](#br331)

[Figure](#br331)[ ](#br331)[128](#br331)[ ](#br331)[Computer](#br331)[ ](#br331)[Management..........................................................................................................................](#br331)[ ](#br331)[331](#br331)

[Figure](#br332)[ ](#br332)[129](#br332)[ ](#br332)[COM3](#br332)[ ](#br332)[Port](#br332)[ ](#br332)[..............................................................................................................................................](#br332)[ ](#br332)[332](#br332)

[Figure](#br333)[ ](#br333)[130](#br333)[ ](#br333)[Save](#br333)[ ](#br333)[Data](#br333)[ ](#br333)[................................................................................................................................................](#br333)[ ](#br333)[333](#br333)

[Figure](#br333)[ ](#br333)[131](#br333)[ ](#br333)[Trace](#br333)[ ](#br333)[Manager........................................................................................................................................](#br333)[ ](#br333)[333](#br333)

[Figure](#br334)[ ](#br334)[132](#br334)[ ](#br334)[DUMP_PLC_ENABLE................................................................................................................................](#br334)[ ](#br334)[334](#br334)

[Figure](#br334)[ ](#br334)[133](#br334)[ ](#br334)[Record.....................................................................................................................................................](#br334)[ ](#br334)[334](#br334)

[Figure](#br334)[ ](#br334)[134](#br334)[ ](#br334)[DUMP_PLC_ENABLE................................................................................................................................](#br334)[ ](#br334)[334](#br334)

[Figure](#br335)[ ](#br335)[135](#br335)[ ](#br335)[BT_SCO_CHAIN_AUDIO_DUMP..............................................................................................................](#br335)[ ](#br335)[335](#br335)

Rev 1.2 Page11 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**List of Sample Code**

[Sample](#br35)[ ](#br35)[Code](#br35)[ ](#br35)[1:](#br35)[ ](#br35)[GPIO](#br35)[ ](#br35)[Wake-up...................................................................................................................................](#br35)[ ](#br35)[35](#br35)

[Sample](#br39)[ ](#br39)[Code](#br39)[ ](#br39)[2:](#br39)[ ](#br39)[Use](#br39)[ ](#br39)[UART1](#br39)[ ](#br39)[........................................................................................................................................](#br39)[ ](#br39)[39](#br39)

[Sample](#br48)[ ](#br48)[Code](#br48)[ ](#br48)[3:](#br48)[ ](#br48)[Use](#br48)[ ](#br48)[GPADC........................................................................................................................................](#br48)[ ](#br48)[48](#br48)

[Sample](#br49)[ ](#br49)[Code](#br49)[ ](#br49)[4:](#br49)[ ](#br49)[Hardware](#br49)[ ](#br49)[Timer](#br49)[ ](#br49)[................................................................................................................................](#br49)[ ](#br49)[49](#br49)

[Sample](#br62)[ ](#br62)[Code](#br62)[ ](#br62)[5:](#br62)[ ](#br62)[Get](#br62)[ ](#br62)[Current](#br62)[ ](#br62)[Time](#br62)[ ](#br62)[..............................................................................................................................](#br62)[ ](#br62)[62](#br62)

[Sample](#br64)[ ](#br64)[Code](#br64)[ ](#br64)[6:](#br64)[ ](#br64)[Get](#br64)[ ](#br64)[Current](#br64)[ ](#br64)[Battery](#br64)[ ](#br64)[Level](#br64)[ ](#br64)[.................................................................................................................](#br64)[ ](#br64)[64](#br64)

[Sample](#br111)[ ](#br111)[Code](#br111)[ ](#br111)[7:](#br111)[ ](#br111)[OS_Thread](#br111)[ ](#br111)[Creation........................................................................................................................](#br111)[ ](#br111)[111](#br111)

[Sample](#br113)[ ](#br113)[Code](#br113)[ ](#br113)[8](#br113)[ ](#br113)[:](#br113)[ ](#br113)[OS](#br113)[ ](#br113)[Event.........................................................................................................................................](#br113)[ ](#br113)[113](#br113)

[Sample](#br116)[ ](#br116)[Code](#br116)[ ](#br116)[9:](#br116)[ ](#br116)[OS](#br116)[ ](#br116)[Timer..........................................................................................................................................](#br116)[ ](#br116)[116](#br116)

[Sample](#br117)[ ](#br117)[Code](#br117)[ ](#br117)[10:](#br117)[ ](#br117)[OS](#br117)[ ](#br117)[Semaphore](#br117)[ ](#br117)[..............................................................................................................................](#br117)[ ](#br117)[117](#br117)

[Sample](#br125)[ ](#br125)[Code](#br125)[ ](#br125)[11:](#br125)[ ](#br125)[Audio](#br125)[ ](#br125)[Loopback](#br125)[ ](#br125)[Test.....................................................................................................................](#br125)[ ](#br125)[125](#br125)

[Sample](#br132)[ ](#br132)[Code](#br132)[ ](#br132)[12:](#br132)[ ](#br132)[Music](#br132)[ ](#br132)[Jitter](#br132)[ ](#br132)[Buffer](#br132)[ ](#br132)[Length.............................................................................................................](#br132)[ ](#br132)[132](#br132)

[Sample](#br138)[ ](#br138)[Code](#br138)[ ](#br138)[13:](#br138)[ ](#br138)[Prompt](#br138)[ ](#br138)[Usage](#br138)[ ](#br138)[Test........................................................................................................................](#br138)[ ](#br138)[138](#br138)

[Sample](#br144)[ ](#br144)[Code](#br144)[ ](#br144)[14:](#br144)[ ](#br144)[Volume](#br144)[ ](#br144)[Level](#br144)[ ](#br144)[Configuration](#br144)[ ](#br144)[and](#br144)[ ](#br144)[Volume](#br144)[ ](#br144)[Control](#br144)[ ](#br144)[Test.................................................................](#br144)[ ](#br144)[144](#br144)

[Sample](#br147)[ ](#br147)[Code](#br147)[ ](#br147)[15:](#br147)[ ](#br147)[Get](#br147)[ ](#br147)[and](#br147)[ ](#br147)[Write](#br147)[ ](#br147)[BT](#br147)[ ](#br147)[Address.............................................................................................................](#br147)[ ](#br147)[147](#br147)

[Sample](#br148)[ ](#br148)[Code](#br148)[ ](#br148)[16:](#br148)[ ](#br148)[app_ibrt_if_get_a2dp_state](#br148)[ ](#br148)[.........................................................................................................](#br148)[ ](#br148)[148](#br148)

[Sample](#br149)[ ](#br149)[Code](#br149)[ ](#br149)[17:](#br149)[ ](#br149)[app_ibrt_if_get_avrcp_state](#br149)[ ](#br149)[........................................................................................................](#br149)[ ](#br149)[149](#br149)

[Sample](#br149)[ ](#br149)[Code](#br149)[ ](#br149)[18:](#br149)[ ](#br149)[app_ibrt_if_get_hfp_state............................................................................................................](#br149)[ ](#br149)[149](#br149)

[Sample](#br149)[ ](#br149)[Code](#br149)[ ](#br149)[19:](#br149)[ ](#br149)[app_ibrt_if_get_hfp_call_status...................................................................................................](#br149)[ ](#br149)[149](#br149)

[Sample](#br149)[ ](#br149)[Code](#br149)[ ](#br149)[20:](#br149)[ ](#br149)[app_ibrt_if_get_connected_mobile_count..................................................................................](#br149)[ ](#br149)[149](#br149)

[Sample](#br150)[ ](#br150)[Code](#br150)[ ](#br150)[21:](#br150)[ ](#br150)[app_ibrt_if_get_mobile_connected_dev_list...............................................................................](#br150)[ ](#br150)[150](#br150)

[Sample](#br150)[ ](#br150)[Code](#br150)[ ](#br150)[22:](#br150)[ ](#br150)[app_ibrt_if_is_tws_role_switch_on](#br150)[ ](#br150)[.............................................................................................](#br150)[ ](#br150)[150](#br150)

[Sample](#br150)[ ](#br150)[Code](#br150)[ ](#br150)[23:](#br150)[ ](#br150)[app_ibrt_if_tws_role_switch_reques...........................................................................................](#br150)[ ](#br150)[150](#br150)

[Sample](#br150)[ ](#br150)[Code](#br150)[ ](#br150)[24:](#br150)[ ](#br150)[app_ibrt_if_nvrecord_get_mobile_addr](#br150)[ ](#br150)[......................................................................................](#br150)[ ](#br150)[150](#br150)

[Sample](#br150)[ ](#br150)[Code](#br150)[ ](#br150)[25:](#br150)[ ](#br150)[app_ibrt_if_nvrecord_delete_all_mobile_record](#br150)[ ](#br150)[........................................................................](#br150)[ ](#br150)[150](#br150)

[Sample](#br151)[ ](#br151)[Code](#br151)[ ](#br151)[26:](#br151)[ ](#br151)[app_ibrt_if_nvrecord_get_mobile_paired_dev_list.....................................................................](#br151)[ ](#br151)[151](#br151)

[Sample](#br151)[ ](#br151)[Code](#br151)[ ](#br151)[27:](#br151)[ ](#br151)[app_ibrt_if_is_tws_link_connected..............................................................................................](#br151)[ ](#br151)[151](#br151)

[Sample](#br151)[ ](#br151)[Code](#br151)[ ](#br151)[28:](#br151)[ ](#br151)[app_ibrt_if_is_in_freeman_mode................................................................................................](#br151)[ ](#br151)[151](#br151)

[Sample](#br151)[ ](#br151)[Code](#br151)[ ](#br151)[29:](#br151)[ ](#br151)[app_ibrt_if_tws_disconnect_request...........................................................................................](#br151)[ ](#br151)[151](#br151)

[Sample](#br151)[ ](#br151)[Code](#br151)[ ](#br151)[30:](#br151)[ ](#br151)[app_ibrt_if_mobile_disconnect_request......................................................................................](#br151)[ ](#br151)[151](#br151)

[Sample](#br152)[ ](#br152)[Code](#br152)[ ](#br152)[31:](#br152)[ ](#br152)[app_ibrt_if_is_tws_in_pairing_state](#br152)[ ](#br152)[............................................................................................](#br152)[ ](#br152)[152](#br152)

[Sample](#br152)[ ](#br152)[Code](#br152)[ ](#br152)[32:](#br152)[ ](#br152)[app_ibrt_if_is_left_side](#br152)[ ](#br152)[................................................................................................................](#br152)[ ](#br152)[152](#br152)

[Sample](#br152)[ ](#br152)[Code](#br152)[ ](#br152)[33:](#br152)[ ](#br152)[app_ibrt_if_is_right_side..............................................................................................................](#br152)[ ](#br152)[152](#br152)

[Sample](#br152)[ ](#br152)[Code](#br152)[ ](#br152)[34:](#br152)[ ](#br152)[app_ibrt_if_unkown_side.............................................................................................................](#br152)[ ](#br152)[152](#br152)

[Sample](#br152)[ ](#br152)[Code](#br152)[ ](#br152)[35:](#br152)[ ](#br152)[app_ibrt_if_tws_disconnect_request...........................................................................................](#br152)[ ](#br152)[152](#br152)

[Sample](#br152)[ ](#br152)[Code](#br152)[ ](#br152)[36:](#br152)[ ](#br152)[app_ibrt_if_tws_disconnect_request...........................................................................................](#br152)[ ](#br152)[152](#br152)

[Sample](#br153)[ ](#br153)[Code](#br153)[ ](#br153)[37:](#br153)[ ](#br153)[app_ibrt_if_uirole2str...................................................................................................................](#br153)[ ](#br153)[153](#br153)

[Sample](#br161)[ ](#br161)[Code](#br161)[ ](#br161)[38:](#br161)[ ](#br161)[Simple](#br161)[ ](#br161)[Pairing](#br161)[ ](#br161)[Test........................................................................................................................](#br161)[ ](#br161)[161](#br161)

[Sample](#br163)[ ](#br163)[Code](#br163)[ ](#br163)[39:](#br163)[ ](#br163)[BES](#br163)[ ](#br163)[UI](#br163)[ ](#br163)[Usage](#br163)[ ](#br163)[.................................................................................................................................](#br163)[ ](#br163)[163](#br163)

[Sample](#br175)[ ](#br175)[Code](#br175)[ ](#br175)[40:](#br175)[ ](#br175)[Sniff](#br175)[ ](#br175)[and](#br175)[ ](#br175)[Active](#br175)[ ](#br175)[Mode](#br175)[ ](#br175)[Management](#br175)[ ](#br175)[............................................................................................](#br175)[ ](#br175)[175](#br175)

[Sample](#br181)[ ](#br181)[Code](#br181)[ ](#br181)[41:](#br181)[ ](#br181)[get_ble_address............................................................................................................................](#br181)[ ](#br181)[181](#br181)

[Sample](#br182)[ ](#br182)[Code](#br182)[ ](#br182)[42:](#br182)[ ](#br182)[set_ble_address............................................................................................................................](#br182)[ ](#br182)[182](#br182)

[Sample](#br182)[ ](#br182)[Code](#br182)[ ](#br182)[43:](#br182)[ ](#br182)[get_ble_name](#br182)[ ](#br182)[...............................................................................................................................](#br182)[ ](#br182)[182](#br182)

Rev 1.2 Page12 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

[Sample](#br182)[ ](#br182)[Code](#br182)[ ](#br182)[44:](#br182)[ ](#br182)[set_ble_name](#br182)[ ](#br182)[...............................................................................................................................](#br182)[ ](#br182)[182](#br182)

[Sample](#br190)[ ](#br190)[Code](#br190)[ ](#br190)[45:](#br190)[ ](#br190)[ble_adv_user_register](#br190)[ ](#br190)[..................................................................................................................](#br190)[ ](#br190)[190](#br190)

[Sample](#br194)[ ](#br194)[Code](#br194)[ ](#br194)[46:](#br194)[ ](#br194)[Enable](#br194)[ ](#br194)[and](#br194)[ ](#br194)[Disable](#br194)[ ](#br194)[advertising.....................................................................................................](#br194)[ ](#br194)[194](#br194)

[Sample](#br195)[ ](#br195)[Code](#br195)[ ](#br195)[47:](#br195)[ ](#br195)[ble_set_adv_type..........................................................................................................................](#br195)[ ](#br195)[195](#br195)

[Sample](#br197)[ ](#br197)[Code](#br197)[ ](#br197)[48:](#br197)[ ](#br197)[set_adv_interval](#br197)[ ](#br197)[...........................................................................................................................](#br197)[ ](#br197)[197](#br197)

[Sample](#br200)[ ](#br200)[Code](#br200)[ ](#br200)[49:](#br200)[ ](#br200)[ble_set_adv_txpwr_by_actv_user................................................................................................](#br200)[ ](#br200)[200](#br200)

[Sample](#br200)[ ](#br200)[Code](#br200)[ ](#br200)[50:](#br200)[ ](#br200)[ble_set_adv_txpwr_by_adv_user.................................................................................................](#br200)[ ](#br200)[200](#br200)

[Sample](#br200)[ ](#br200)[Code](#br200)[ ](#br200)[51:](#br200)[ ](#br200)[ble_set_all_adv_txpwr..................................................................................................................](#br200)[ ](#br200)[200](#br200)

[Sample](#br202)[ ](#br202)[Code](#br202)[ ](#br202)[52:](#br202)[ ](#br202)[ble_set_adv_local_addr_by_actv_user](#br202)[ ](#br202)[........................................................................................](#br202)[ ](#br202)[202](#br202)

[Sample](#br203)[ ](#br203)[Code](#br203)[ ](#br203)[53:](#br203)[ ](#br203)[ble_set_adv_local_addr_by_adv_user](#br203)[ ](#br203)[.........................................................................................](#br203)[ ](#br203)[203](#br203)

[Sample](#br203)[ ](#br203)[Code](#br203)[ ](#br203)[54:](#br203)[ ](#br203)[ble_user_adv_start](#br203)[ ](#br203)[.......................................................................................................................](#br203)[ ](#br203)[203](#br203)

[Sample](#br207)[ ](#br207)[Code](#br207)[ ](#br207)[55:](#br207)[ ](#br207)[ble_custom_adv_start](#br207)[ ](#br207)[..................................................................................................................](#br207)[ ](#br207)[207](#br207)

[Sample](#br209)[ ](#br209)[Code](#br209)[ ](#br209)[56:](#br209)[ ](#br209)[ble_start_scan...............................................................................................................................](#br209)[ ](#br209)[209](#br209)

[Sample](#br209)[ ](#br209)[Code](#br209)[ ](#br209)[57:](#br209)[ ](#br209)[ble_stop_scan](#br209)[ ](#br209)[...............................................................................................................................](#br209)[ ](#br209)[209](#br209)

[Sample](#br211)[ ](#br211)[Code](#br211)[ ](#br211)[58:](#br211)[ ](#br211)[ble_start_connect.........................................................................................................................](#br211)[ ](#br211)[211](#br211)

[Sample](#br212)[ ](#br212)[Code](#br212)[ ](#br212)[59:](#br212)[ ](#br212)[ble_start_connect_with_init_type](#br212)[ ](#br212)[...............................................................................................](#br212)[ ](#br212)[212](#br212)

[Sample](#br213)[ ](#br213)[Code](#br213)[ ](#br213)[60:](#br213)[ ](#br213)[ble_is_connection_on_by_addr](#br213)[ ](#br213)[...................................................................................................](#br213)[ ](#br213)[213](#br213)

[Sample](#br213)[ ](#br213)[Code](#br213)[ ](#br213)[61:](#br213)[ ](#br213)[ble_is_connection_on_by_conIdx](#br213)[ ](#br213)[................................................................................................](#br213)[ ](#br213)[213](#br213)

[Sample](#br214)[ ](#br214)[Code](#br214)[ ](#br214)[62:](#br214)[ ](#br214)[ble_cancel_connecting](#br214)[ ](#br214)[.................................................................................................................](#br214)[ ](#br214)[214](#br214)

[Sample](#br214)[ ](#br214)[Code](#br214)[ ](#br214)[63:](#br214)[ ](#br214)[ble_start_disconnect](#br214)[ ](#br214)[....................................................................................................................](#br214)[ ](#br214)[214](#br214)

[Sample](#br219)[ ](#br219)[Code](#br219)[ ](#br219)[64:](#br219)[ ](#br219)[ble_update_conn_param_mode](#br219)[ ](#br219)[..................................................................................................](#br219)[ ](#br219)[219](#br219)

[Sample](#br219)[ ](#br219)[Code](#br219)[ ](#br219)[65:](#br219)[ ](#br219)[ble_get_conn_param....................................................................................................................](#br219)[ ](#br219)[219](#br219)

[Sample](#br231)[ ](#br231)[Code](#br231)[ ](#br231)[66:](#br231)[ ](#br231)[DTS](#br231)[ ](#br231)[Registration............................................................................................................................](#br231)[ ](#br231)[231](#br231)

[Sample](#br232)[ ](#br232)[Code](#br232)[ ](#br232)[67:](#br232)[ ](#br232)[dts_send_data](#br232)[ ](#br232)[..............................................................................................................................](#br232)[ ](#br232)[232](#br232)

[Sample](#br232)[ ](#br232)[Code](#br232)[ ](#br232)[68:](#br232)[ ](#br232)[dts_disconnect..............................................................................................................................](#br232)[ ](#br232)[232](#br232)

[Sample](#br234)[ ](#br234)[Code](#br234)[ ](#br234)[69:](#br234)[ ](#br234)[dts_connect](#br234)[ ](#br234)[..................................................................................................................................](#br234)[ ](#br234)[234](#br234)

[Sample](#br235)[ ](#br235)[Code](#br235)[ ](#br235)[70:](#br235)[ ](#br235)[dts_send_data](#br235)[ ](#br235)[..............................................................................................................................](#br235)[ ](#br235)[235](#br235)

[Sample](#br235)[ ](#br235)[Code](#br235)[ ](#br235)[71:](#br235)[ ](#br235)[dts_disconnect..............................................................................................................................](#br235)[ ](#br235)[235](#br235)

[Sample](#br315)[ ](#br315)[Code](#br315)[ ](#br315)[72:](#br315)[ ](#br315)[Data](#br315)[ ](#br315)[Access](#br315)[ ](#br315)[Error..........................................................................................................................](#br315)[ ](#br315)[315](#br315)

[Sample](#br316)[ ](#br316)[Code](#br316)[ ](#br316)[73:](#br316)[ ](#br316)[Instruction](#br316)[ ](#br316)[Bus](#br316)[ ](#br316)[Error.....................................................................................................................](#br316)[ ](#br316)[316](#br316)

[Sample](#br317)[ ](#br317)[Code](#br317)[ ](#br317)[74:](#br317)[ ](#br317)[Precise](#br317)[ ](#br317)[Data](#br317)[ ](#br317)[Bus](#br317)[ ](#br317)[Error...................................................................................................................](#br317)[ ](#br317)[317](#br317)

[Sample](#br318)[ ](#br318)[Code](#br318)[ ](#br318)[75:](#br318)[ ](#br318)[Usage](#br318)[ ](#br318)[Fault....................................................................................................................................](#br318)[ ](#br318)[318](#br318)

[Sample](#br318)[ ](#br318)[Code](#br318)[ ](#br318)[76:](#br318)[ ](#br318)[Hard](#br318)[ ](#br318)[Fault......................................................................................................................................](#br318)[ ](#br318)[318](#br318)

[Sample](#br321)[ ](#br321)[Code](#br321)[ ](#br321)[77:](#br321)[ ](#br321)[Deadlock](#br321)[ ](#br321)[Causes](#br321)[ ](#br321)[Watchdog](#br321)[ ](#br321)[Crash................................................................................................](#br321)[ ](#br321)[321](#br321)

[Sample](#br323)[ ](#br323)[Code](#br323)[ ](#br323)[78:](#br323)[ ](#br323)[stack_overflow..............................................................................................................................](#br323)[ ](#br323)[323](#br323)

Rev 1.2 Page13 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**General Description**

This document is intended for software developers who implement TWS product features based on BES chipsets. Basically,

users can achieve the following objectives by using this manual:

• Learn how to use the BES SDK for quick and easy feature implementation.

• Make minimal effort in using the existing APIs and features.

• Focus on integrating their application layer features and raise requirements for new features that are not

supported yet.

Rev 1.2 Page14 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.009.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Terms and Definitions**

**Term Definition**

SDK Software Development Kit

BT Bluetooth

BLE Bluetooth Low Energy

OTA Over-the-air Technology

TOTA Test protocol over the air

SPP Serial Port Profile

Rev 1.2 Page15 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.010.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.011.jpeg)*Software Development User Guide*

1. ` `**Get Started with our SDK**
1. ` `**Software Development Environment Setup**
1. ` `**Set up Compilation Environment**

The SDK uses the Arm GCC building system, and the recommended Arm GCC tool chain version is gcc-arm-none-eabi-

10-2020-q4-major. The tool chain can be found and downloaded from the following website:

[https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads#panel3a)

[rm/downloads#panel3a](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads#panel3a)[.](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads#panel3a)

On Linux operating system, unzip the downloaded Arm GCC tool chain zip packet.

The default location to put the unzipped Arm gcc tool is */usr/local*, but other locations can be specified as needed.

The steps to add the tool chain into the linux environment are as follows:

1. ` `Switch to the root account in order to edit */etc/profile*.

sudo -i

1. ` `Edit /etc/profile to add the path of tool chain as the bottom line.

vi /etc/profile

e.g.: export PATH=$PATH:/usr/local/gcc-arm-none-eabi-10-2020-q4-major/bin

If users develop software on Windows, the recommended method is to install Ubuntu LTS. The steps to prepare the

environment on Ubuntu LTS are the same as those on Linux. Building projects on Ubuntu LTS is much faster than on

Windows. The steps of Ubuntu LTS installation can be found in the following link:

<https://ubuntu.com/tutorials/ubuntu-on-windows#1-overview>

1. ` `**Build the Project**

Turn to the root path of the SDK, enter the following command:

**Figure 1 Building Command**

\- “T=” is to select the built target name. The target name can be one of the names in the configuration folders.

\- “DEBUG=1” is to enable UART log printing.

\- “-j” is to enable as many processors as the PC can to accelerate the compilation.

\- “2> log.txt” is to output building logs, if many changes are done and the compilation cannot pass, collecting logs is

useful for troubleshooting.

\- After compilation, the following files are generated in the out/best1600\_ibrt folder.

Rev 1.2 Page16 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.012.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 2 Compilation Generated Files**

\- “.lds” is the link script file generated from link script model file scripts\link\best1000.lds.S.

\- “.bin” is the generated image file used for image programming.

\- “.elf” is the symbol file.

\- “.map” is the map file.

If users want to get the full disassemble files, use the following building command:

make T=best1600\_ibrt DEBUG=1 -j all lst 2 > log.txt

1. ` `**Usage of Hardware Development Kit**

The yellow Evaluation Board is compatible with various types of Bluetooth chip boards, which has differential LN/LP,

RN/RP outputs and MIC inputs.

The log information can be downloaded and uploaded to the PC both through UART. The jumper cap should be

changed when switching the power supply mode.

Rev 1.2 Page17 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.013.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 3 BES Evaluation Board Set-up**

1. ` `**Image Programming**

The Windows download GUI tool, **DldProductLine**, can be used for image programming.

The programming procedure is as follows:

\- Set up the BES evaluation board as Figure 3 shown above in section 3.1.3.

\- Connect the BES evaluation board to your computer.

\- Open DldProductLine.

\- Click the button pointed by arrow 1 to open the COM setting window.

\- Click “list” pointed by arrow 2 to emulate all the serial ports, then click “OK” pointed by arrow 3. This step only

needs to be done once.

Rev 1.2 Page18 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.014.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 4 Emulate Download Serial Ports**

\- Click the button with a human figure on it, and enter “1” for both User and Pwd in the login dialog. It can also be

configured <needlogin>0</needlogin> in the file “productline\_cfg. XML” for a password-free login.

**Figure 5 Enter User Account and Password**

Rev 1.2 Page19 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.015.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

\- Configure the following settings to choose the downloaded image and written non-volatile information. Note that

the non-volatile information only needs to be done once. After that, you can uncheck “Erase the whole flash” and

“Update Sector” to avoid unwanted programming.

**Figure 6 Image Downloading Configuration**

Two test boards are needed if left and right earbuds are to be emulated. Please use different BT mac addresses for the

left and right earbuds. Specifically, you should set the last bit of the BT addresses different. For example, if the last bit

of the master BT address is set to 1, the last bit of the slave’s should be set to 0. Based on such BT mac addresses,

default master or slave TWS roles can be assigned to two earbuds.

e.g. Master: 12 42 22 34 34 30; Slave: 12 42 22 34 34 31.

\- After finishing the configuration, press “Save” button.

\- Click the “start” button as shown in the figure below. Press the reset button on the EVB, and then press the

Power-on button on the evaluation board (EVB) to start downloading.

Rev 1.2 Page20 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.016.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.017.jpeg)*Software Development User Guide*

**Figure 7 Image Downloading**

\- When the downloading is completed, click the stop button on the main view.

**Figure 8 Image Downloading Completed**

1. ` `**Implement Basic Functions**

After downloading the image, TWS devices can be set to connect with each other automatically and able to be

connected to mobile phones for basic operations such as playing music.

To enable the auto-pairing, these two macros should be set:

FREE\_TWS\_PAIRING\_ENABLED=1 POWER\_ON\_ENTER\_TWS\_PAIRING\_ENABLED=1

A serial monitor is needed to read the data transmitted by the evalutation board. Xshell is recommended. The default

Baud is 1152000. After both of the COM ports are connected to the serial monitor, you can start pairing the two

devices.

The connection process is as follows:

\- Press RST button of two boards. Boot up log printing, as shown in Figure 9.

Rev 1.2 Page21 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.018.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 9 Image Bootup Log Printing in UART**

\- Two boards pair with each other. A TWS connection is established, and the primary device enters into discoverable

mode. The keyword for log printing in UART is “TWS-STATE”.

**Figure 10 Log Printing of TWS Connection**

\- The primary device can be connected to the mobile phone to play music.

The name for the Bluetooth is set during the burning procedure. The name is defined in the BLE Name block of the

burning setting page, as shown in Figure 6.

The keyword for log printing in UART is “MOBILE-STATE”.

Rev 1.2 Page22 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.019.jpeg)*Software Development User Guide*

**Figure 11 Log Printing of Mobile Connection**

Rev 1.2 Page23 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.020.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

4. ` `**Software System Introduction**
1. ` `**Software Architecture**

The following figure is the functional description of each core in a multi-core system.

**Figure 12 Software Architecture**

The functions of the main MCU are introduced in Figure 13. The main MCU creates different threads based on the OS

Abstract Layer, covering Audio, IBRT core, GAF, classic BT and application.

Rev 1.2 Page24 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.021.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 13 Main MCU Functions**

1. ` `**SDK Folder Structure**

The SDK folder contains the following directories:

**Figure 14 SDK Folder Structure**

Rev 1.2 Page25 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.022.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

\- “apps” mainly stores upper-layer application-related software.

\- “config” indicates the basic differentiated configuration.

\- “Documentations” contains SDK related basic documents.

\- “include” mainly contains RTOS header files.

\- “lib” indicates BES owned libraries.

\- “mbed” indicates mbed configuration files.

\- “out” stores the compiled output file, select the “.bin” file when programming.

\- “platform” mainly contains Driver codes and CMSIS codes.

\- “rtos” indicates RTOS source files.

\- “scripts” contains building framework scripts.

\- “services” indicates service codes.

\- “tests” contains test programs.

\- “thirdparty” indicates third-party libraries.

\- “utils” contains common utility codes.

\- “Makefile” indicates the entry of the Makefile.

1. ` `**Introduction of Main MCU-dedicated Threads**

**Table 1 Thread Introduction**

**Task name Description**

app\_audio\_thread Manages different types of audio streams.

app\_thread Mainly used for the processing messages from the application modules.

af\_thread Processes the audio flinger dma irq events, covering internal codec, i2s, tdm,

spdif, bt pcm functionalities. This is audio thread where the audio algorithms are

running.

BesbtThread Used for running all of the classic BT and BLE host layers.

main\_thread The main thread of the SDK.

a2dp\_decoder\_cc\_processor\_thread Communicates with M55 for A2DP music decoding.

app\_custom\_ux\_thread Distributes the TWS UI owned bluetooth events to the custom project for

implementing the custom UI.

app\_dsp\_m55\_bridge\_rx\_thread Processes the core bridge message between main MCU and m55.

app\_prompt\_handler\_thread Processes the pending prompt playing requests in the queue one by one.

app\_core\_bridge\_rx\_thread Processes the core bridge message between main MCU and sensor hub.

The following figure shows the data flow for the SDK.

Rev 1.2 Page26 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.023.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 15 SDK Data Flow**

Rev 1.2 Page27 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.024.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

4. ` `**Software Development Guide**
1. ` `**Target Configuration**
1. ` `**Common.mk**

The common.mk file is where the general makefile options are included, such as compiler options, chip selection, file

path, etc. The file is located in /config directory.

1. ` `**Target.mk**

The target.mk files consist of build configurations for specific build targets. They are located in /config/<target name>

directory.

1. ` `**Link Script**

Linker scripts tell the linker which sections to include in the output file, as well as which order to put them in, what type

of file is to be produced, and what is to be the address of the first instruction. Those files are located in /scripts

directory.

1. ` `**Target Hardware Configuration**

The configuration of the target hardware is implemented in the “tgt\_hardware.c” and “tgt\_hardware.h” files in the

“config” directory.

The hardware configuration is as follows:

\- Output channel configuration

The following playback channel configuration in “tgt\_hardware.h” is used by default if the audio flinger's channel map is

not configured when starting a playback stream.

#ifdef BLE\_AUDIO\_STEREO\_CHANNEL\_OVER\_ONE\_CIS

#define CFG\_HW\_AUD\_OUTPUT\_PATH\_SPEAKER\_DEV (AUD\_CHANNEL\_MAP\_CH0 |

AUD\_CHANNEL\_MAP\_CH1)

#else

#define CFG\_HW\_AUD\_OUTPUT\_PATH\_SPEAKER\_DEV (AUD\_CHANNEL\_MAP\_CH0)

#endif

\- Battery volume level

The battery voltage settings for full voltage, low voltage, and shutdown voltage are stored in “tgt\_hardware.h”.

#define APP\_BATTERY\_MIN\_MV (3200)

#define APP\_BATTERY\_PD\_MV (3100)

#define APP\_BATTERY\_MAX\_MV (4200)

Rev 1.2 Page28 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.026.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

\- BT Configuration

The following BT and BLE's name and mac addresses are used by default when there is no valid information in the

factory section.

const char \*BT\_LOCAL\_NAME = TO\_STRING(BT\_DEV\_NAME) "\0";

const char \*BLE\_DEFAULT\_NAME = "BES\_BLE";

uint8\_t ble\_global\_addr[6] = {

#ifdef BLE\_DEV\_ADDR

BLE\_DEV\_ADDR

#else

0xBE,0x99,0x34,0x45,0x56,0x67

#endif

};

uint8\_t bt\_global\_addr[6] = {

#ifdef BT\_DEV\_ADDR

BT\_DEV\_ADDR

#else

0x1e,0x57,0x34,0x45,0x56,0x67

#endif

};

\- rfcomm uuid configuration of the TOTA service

Configure the rfcomm uuid if you want to use BES TOTA spec with different UUID values.

uint8\_t tota\_rfcomm\_custom\_uuid[16] =

{ 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,

0x88, 0x88, 0x88, 0x88 };

\- Volume level configuration

Configure the playback codec volume level.

const struct CODEC\_DAC\_VOL\_T codec\_dac\_vol[TGT\_VOLUME\_LEVEL\_QTY] = {

{TX\_PA\_GAIN,0x03,-99},

{TX\_PA\_GAIN,0x03,-45},

{TX\_PA\_GAIN,0x03,-42},

{TX\_PA\_GAIN,0x03,-39},

{TX\_PA\_GAIN,0x03,-36},

{TX\_PA\_GAIN,0x03,-33},

{TX\_PA\_GAIN,0x03,-30},

{TX\_PA\_GAIN,0x03,-27},

Rev 1.2 Page29 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.027.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

{TX\_PA\_GAIN,0x03,-24},

{TX\_PA\_GAIN,0x03,-21},

{TX\_PA\_GAIN,0x03,-18},

{TX\_PA\_GAIN,0x03,-15},

{TX\_PA\_GAIN,0x03,-12},

{TX\_PA\_GAIN,0x03, -9},

{TX\_PA\_GAIN,0x03, -6},

{TX\_PA\_GAIN,0x03, -3},

{TX\_PA\_GAIN,0x03, 0}, //0dBm

};

\- Audio stream configuration

Each entry in this configuration array is used by a specific capture user scenario.

“cfg\_audio\_input\_path\_cfg.io\_path” shall be filled into the audio flinger element “stream\_cfg.io\_path” when you set

up and start an audio stream.

For example: stream\_cfg.io\_path = AUD\_INPUT\_PATH\_MAINMIC.

const struct AUD\_IO\_PATH\_CFG\_T

cfg\_audio\_input\_path\_cfg[CFG\_HW\_AUD\_INPUT\_PATH\_NUM] = {

#if defined(SPEECH\_TX\_AEC\_CODEC\_REF)

// NOTE: If enable Ch5 and CH6, need to add channel\_num when setup

audioflinger stream

{ AUD\_INPUT\_PATH\_MAINMIC, CFG\_HW\_AUD\_INPUT\_PATH\_MAINMIC\_DEV |

AUD\_CHANNEL\_MAP\_ECMIC\_CH0, },

#else

{ AUD\_INPUT\_PATH\_MAINMIC, CFG\_HW\_AUD\_INPUT\_PATH\_MAINMIC\_DEV, },

#endif

{ AUD\_INPUT\_PATH\_LINEIN, CFG\_HW\_AUD\_INPUT\_PATH\_LINEIN\_DEV, },

#ifdef VOICE\_DETECTOR\_SENS\_EN

{ AUD\_INPUT\_PATH\_VADMIC, CFG\_HW\_AUD\_INPUT\_PATH\_VADMIC\_DEV, },

#else

{ AUD\_INPUT\_PATH\_ASRMIC, CFG\_HW\_AUD\_INPUT\_PATH\_ASRMIC\_DEV, },

#endif

{ AUD\_INPUT\_PATH\_ANC\_ASSIST,

CFG\_HW\_AUD\_INPUT\_PATH\_ANC\_ASSIST\_DEV, },

#if defined(SPEECH\_TX\_AEC\_CODEC\_REF)

{ AUD\_INPUT\_PATH\_HEARING, CFG\_HW\_AUD\_INPUT\_PATH\_HEARING\_DEV |

AUD\_CHANNEL\_MAP\_ECMIC\_CH0, },

#else

Rev 1.2 Page30 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.028.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

{ AUD\_INPUT\_PATH\_HEARING, CFG\_HW\_AUD\_INPUT\_PATH\_HEARING\_DEV, },

#endif

};

\- Volume level configuration

The capture channel configuration is used by default if the audio flinger's channel map is not configured when you start

a capture stream.

struct AF\_STREAM\_CONFIG\_T {

uint32\_t ext\_mclk\_freq;

enum AUD\_SAMPRATE\_T sample\_rate;

enum AUD\_CHANNEL\_MAP\_T channel\_map;

enum AUD\_CHANNEL\_NUM\_T channel\_num;

enum AUD\_BITS\_T bits;

enum AUD\_STREAM\_USE\_DEVICE\_T device;

enum AUD\_IO\_PATH\_T io\_path;

enum AUD\_DATA\_ALIGN\_T align;

enum AUD\_FS\_FIRST\_EDGE\_T fs\_edge;

uint16\_t fs\_cycles;

uint8\_t slot\_cycles;

bool chan\_sep\_buf;

bool sync\_start;

//should define type

uint8\_t vol;

AF\_STREAM\_HANDLER\_T handler;

uint8\_t \*data\_ptr;

uint32\_t data\_size;

};

For “CFG\_HW\_AUD\_INPUT\_PATH\_MAINMIC\_DEV (AUD\_CHANNEL\_MAP\_CH0 | VMIC\_MAP\_CFG)” parameters,

“AUD\_CHANNEL\_MAP\_CH0” represents the ADC channel index, and “VMIC\_MAP\_CFG” represents the Microphone

power supplier VMIC.

#if SPEECH\_CODEC\_CAPTURE\_CHANNEL\_NUM == 2

#define CFG\_HW\_AUD\_INPUT\_PATH\_MAINMIC\_DEV (AUD\_CHANNEL\_MAP\_CH0 |

AUD\_CHANNEL\_MAP\_CH1 | VMIC\_MAP\_CFG)

Rev 1.2 Page31 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.029.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

#elif SPEECH\_CODEC\_CAPTURE\_CHANNEL\_NUM == 3

#define CFG\_HW\_AUD\_INPUT\_PATH\_MAINMIC\_DEV (AUD\_CHANNEL\_MAP\_CH0 |

AUD\_CHANNEL\_MAP\_CH1 | AUD\_CHANNEL\_MAP\_CH4 | VMIC\_MAP\_CFG)

#elif SPEECH\_CODEC\_CAPTURE\_CHANNEL\_NUM == 4

#define CFG\_HW\_AUD\_INPUT\_PATH\_MAINMIC\_DEV (AUD\_CHANNEL\_MAP\_CH0 |

AUD\_CHANNEL\_MAP\_CH1 | AUD\_CHANNEL\_MAP\_CH2| AUD\_CHANNEL\_MAP\_CH3 |

AUD\_VMIC\_MAP\_VMIC1)

#else

#define CFG\_HW\_AUD\_INPUT\_PATH\_MAINMIC\_DEV (AUD\_CHANNEL\_MAP\_CH0 |

VMIC\_MAP\_CFG)

#endif

1. ` `**Hardware Abstract Layer Drives**
1. ` `**Use GPIO**

GPIOs can be properly configured to achieve the dedicated functions, wake up the system and serve as a power supply.

1. ` `**GPIO Configuration**

The following table describes the configuration items.

\- IOMUX configuration

**Table 2 GPIO IOMUX Coniguration**

**Item Description Notes**

enum HAL\_IOMUX\_PIN\_T GPIO index Depends on chipset models, normally HAL\_IOMUX\_PIN\_Px\_x or

HAL\_IOMUX\_PIN\_LEDx (Breathing LED).

enum GPIO Every GPIO can be assigned to several fixed functionalities. All of

HAL\_IOMUX\_FUNCTION\_T functionality the GPIOs can be configured as a general GPIO.

HAL\_IOMUX\_FUNC\_GPIO.

enum Voltage

enum HAL\_IOMUX\_PIN\_VOLTAGE\_DOMAINS\_T {

HAL\_IOMUX\_PIN\_VOLTAGE\_ domain

HAL\_IOMUX\_PIN\_VOLTAGE\_VIO = 0, // 1.8v voltage level

DOMAINS\_T HAL\_IOMUX\_PIN\_VOLTAGE\_MEM, // 3.3v voltage level

// For PMU LED pins only

HAL\_IOMUX\_PIN\_VOLTAGE\_VBAT,

};

enum Default pull

enum HAL\_IOMUX\_PIN\_PULL\_SELECT\_T {

HAL\_IOMUX\_PIN\_PULL\_SELE state

HAL\_IOMUX\_PIN\_NOPULL = 0,

CT\_T HAL\_IOMUX\_PIN\_PULLUP\_ENABLE,

HAL\_IOMUX\_PIN\_PULLDOWN\_ENABLE,

Rev 1.2 Page32 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.030.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

};

struct IOMUX struct HAL\_IOMUX\_PIN\_FUNCTION\_MAP {

HAL\_IOMUX\_PIN\_FUNC functions enum HAL\_IOMUX\_PIN\_T pin;

TION\_MAP enum HAL\_IOMUX\_FUNCTION\_T function;

enum HAL\_IOMUX\_PIN\_VOLTAGE\_DOMAINS\_T

volt;

enum HAL\_IOMUX\_PIN\_PULL\_SELECT\_T

pull\_sel;

};

Use the following sample code to configure GPIO\_3\_2 as a general GPIO in the 1.8v voltage domain, no pull state.

#define SAMPLE\_CODE\_TEST\_PIN (HAL\_IOMUX\_PIN\_P3\_2)

struct HAL\_IOMUX\_PIN\_FUNCTION\_MAP test\_pin[] =

{

{

.pin = SAMPLE\_CODE\_TEST\_PIN,

.function = HAL\_IOMUX\_FUNC\_AS\_GPIO,

.volt = HAL\_IOMUX\_PIN\_VOLTAGE\_VIO,

.pull\_sel = HAL\_IOMUX\_PIN\_NOPULL,

},

};

hal\_iomux\_init(&test\_pin[0],

sizeof(test\_pin)/sizeof(HAL\_IOMUX\_PIN\_FUNCTION\_MAP));

\- GPIO direction configuration

A GPIO can be configured as an output or an input. You can use the following sample code to configure the GPIO as an

output port with initial output high. When the direction is input, the third parameter of hal\_gpio\_pin\_set\_dir is ignored.

enum HAL\_GPIO\_DIR\_T {

HAL\_GPIO\_DIR\_IN = 0,

HAL\_GPIO\_DIR\_OUT = 1,

};

hal\_gpio\_pin\_set\_dir((enum HAL\_GPIO\_PIN\_T)SAMPLE\_CODE\_TEST\_PIN,

HAL\_GPIO\_DIR\_OUT, 1);

Rev 1.2 Page33 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.031.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.032.jpeg)*Software Development User Guide*

1. ` `**GPIO Interrupt**

When a GPIO is configured as a general GPIO in the input direction, it can be used for GPIO interrupt to wake up the

system. This feature can be used for sensor data ready to get notification, or waking up device from deep sleep mode,

etc.

The following properties of the GPIO interrupt can be configured:

Ø A specific GPIO that can trigger the interrupt. Multiple GPIOs can be monitored at the same time.

Ø Whether to enable the debounce of the GPIO state change (We recommend that you enable the debounce).

Ø GPIO trigger methods: edge trigger or voltage level trigger.

Ø Event types to trigger the interrupt, high to low or low to high.

Ø The call-back function to call when there is a GPIO state change.

Steps to configure a GPIO:

1. ` `Initialize the GPIO’s IOMUX as a general GPIO.

#define SAMPLE\_CODE\_TEST\_PIN (HAL\_IOMUX\_PIN\_P0\_5)

struct HAL\_IOMUX\_PIN\_FUNCTION\_MAP test\_pin[] =

{

{

.pin = SAMPLE\_CODE\_TEST\_PIN,

.function = HAL\_IOMUX\_FUNC\_AS\_GPIO,

.volt = HAL\_IOMUX\_PIN\_VOLTAGE\_VIO,

.pull\_sel = HAL\_IOMUX\_PIN\_NOPULL,

},

};

hal\_iomux\_init(&test\_pin[0],

sizeof(test\_pin)/sizeof(HAL\_IOMUX\_PIN\_FUNCTION\_MAP));

1. ` `Set up GPIO as an input

hal\_gpio\_pin\_set\_dir((enum HAL\_GPIO\_PIN\_T)SAMPLE\_CODE\_TEST\_PIN,

HAL\_GPIO\_DIR\_IN, 0);

1. ` `Configure GPIO wake-up irq. In this example, the debounce is enabled, edge trigger method is used, and

low to high state change makes the GPIO interrupt happen and the callback function

app\_sample\_code\_test\_gpio\_irq\_handler called.

const struct HAL\_GPIO\_IRQ\_CFG\_T test\_gpio\_cfg = {

.irq\_enable = true,

.irq\_debounce = true,

Rev 1.2 Page34 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.033.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.034.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.035.jpeg)*Software Development User Guide*

.irq\_type = HAL\_GPIO\_IRQ\_TYPE\_EDGE\_SENSITIVE,

.irq\_polarity = HAL\_GPIO\_IRQ\_POLARITY\_HIGH\_RISING,

.irq\_handler = app\_sample\_code\_test\_gpio\_irq\_handler,

};

hal\_gpio\_setup\_irq((enum HAL\_GPIO\_PIN\_T)SAMPLE\_CODE\_TEST\_PIN,

&test\_gpio\_cfg);

1. ` `Disable GPIO wake-up irq

const struct HAL\_GPIO\_IRQ\_CFG\_T disable\_test\_gpio\_cfg = {

.irq\_enable = false,

.irq\_debounce = false,

.irq\_polarity = HAL\_GPIO\_IRQ\_POLARITY\_HIGH\_RISING,

.irq\_handler = NULL,

.irq\_type = HAL\_GPIO\_IRQ\_TYPE\_EDGE\_SENSITIVE,

};

hal\_gpio\_setup\_irq((enum HAL\_GPIO\_PIN\_T)SAMPLE\_CODE\_TEST\_PIN,

&disable\_test\_gpio\_cfg);

**Sample Code 1: GPIO Wake-up**

The demo code is implemented in /apps/tests directory. The second string of the following line is the function name for

a specific demo. Tester can find actual implementation by looking into related cpp files under that directory.

{"gpio\_wakeup\_demo", gpio\_wakeup\_test},

The following line is the command to start the demo. Users need to set this macro: APP\_TRACE\_RX\_ENABLE=1to

enable related log printing for demo code.

[TEST, gpio\_wakeup\_demo]

1. ` `**GPIO Power Supply**

Use the following sample code to configure GPIO\_3\_2 as a general GPIO in the 1.8v voltage domain, pull up state.

#define SAMPLE\_CODE\_TEST\_PIN (HAL\_IOMUX\_PIN\_P3\_2)

struct HAL\_IOMUX\_PIN\_FUNCTION\_MAP test\_pin[] =

{

{

.pin = SAMPLE\_CODE\_TEST\_PIN,

.function = HAL\_IOMUX\_FUNC\_AS\_GPIO,

.volt = HAL\_IOMUX\_PIN\_VOLTAGE\_VIO,

Rev 1.2 Page35 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.036.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.037.jpeg)*Software Development User Guide*

.pull\_sel = HAL\_IOMUX\_PIN\_PULLUP\_ENABLE,

},

};

hal\_iomux\_init(&test\_pin[0],

sizeof(test\_pin)/sizeof(HAL\_IOMUX\_PIN\_FUNCTION\_MAP));

1. ` `**Use UART**

UART can be used for data interaction between the main board and peripherals.

1. ` `**UART Configuration**

The following table describes the configuration items.

\- UART configuration

**Table 3 UART Configuration**

**Item Description Notes**

Struct HAL\_UART\_CFG\_T Configurations struct HAL\_UART\_CFG\_T {

enum HAL\_UART\_PARITY\_T parity;

enum HAL\_UART\_STOP\_BITS\_T stop;

enum HAL\_UART\_DATA\_BITS\_T data;

enum HAL\_UART\_FLOW\_CONTROL\_T flow;

enum HAL\_UART\_FIFO\_LEVEL\_T rx\_level;

enum HAL\_UART\_FIFO\_LEVEL\_T tx\_level;

uint32\_t baud;

bool dma\_rx : 1;

bool dma\_tx : 1;

bool dma\_rx\_stop\_on\_err : 1;

};

enum HAL\_UART\_ID\_T enum HAL\_UART\_ID\_T {

#ifdef UART0\_BASE

HAL\_UART\_ID\_0,

#endif

#ifdef UART1\_BASE

HAL\_UART\_ID\_1,

#endif

#ifdef UART2\_BASE

HAL\_UART\_ID\_2,

#endif

#ifdef UART3\_BASE

Rev 1.2 Page36 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.038.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

HAL\_UART\_ID\_3,

#endif

#ifdef BT\_UART

HAL\_UART\_ID\_BT,

#endif

HAL\_UART\_ID\_QTY

};

union Interrupt of union HAL\_UART\_IRQ\_T {

HAL\_UART\_IRQ\_T UART struct {

uint32\_t RIM :1; // ri

uint32\_t CTSM :1; // cts

uint32\_t DCDM :1; // dcd

uint32\_t DSRM :1; // dsr

uint32\_t RX :1; // rx

uint32\_t TX :1; // tx

uint32\_t RT :1; // receive timeout

uint32\_t FE :1; // framing error

uint32\_t PE :1; // parity error

uint32\_t BE :1; // break error

uint32\_t OE :1; // overrun

};

uint32\_t reg;

};

The common configuration of UART1 is as follows.

struct HAL\_UART\_CFG\_T uart\_dma\_cfg = {

.parity = HAL\_UART\_PARITY\_NONE,

.stop = HAL\_UART\_STOP\_BITS\_1,

.data = HAL\_UART\_DATA\_BITS\_8,

.flow = HAL\_UART\_FLOW\_CONTROL\_NONE,

.rx\_level = HAL\_UART\_FIFO\_LEVEL\_1\_4,

.tx\_level = HAL\_UART\_FIFO\_LEVEL\_1\_2,

.baud = UART\_BAUD\_DEFAULT,

.dma\_rx = true,

.dma\_tx = true,

.dma\_rx\_stop\_on\_err = false,

};

ret = hal\_uart\_open(HAL\_UART\_ID\_1, &uart\_dma\_cfg);

Rev 1.2 Page37 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.039.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

1. ` `**Data Transceiver**

In the following example, the board sends the string 10 times via UART1, and then loses UART.

Steps to use UART:

1. ` `Set IOMUX of UART

hal\_iomux\_set\_uart1();

1. ` `Open UART. The parameters are as follows

struct HAL\_UART\_CFG\_T uart\_dma\_cfg = {

.parity = HAL\_UART\_PARITY\_NONE,

.stop = HAL\_UART\_STOP\_BITS\_1,

.data = HAL\_UART\_DATA\_BITS\_8,

.flow = HAL\_UART\_FLOW\_CONTROL\_NONE,

.rx\_level = HAL\_UART\_FIFO\_LEVEL\_1\_4,

.tx\_level = HAL\_UART\_FIFO\_LEVEL\_1\_2,

.baud = UART\_BAUD\_DEFAULT,

.dma\_rx = true,

.dma\_tx = true,

.dma\_rx\_stop\_on\_err = false,

};

ret = hal\_uart\_open(HAL\_UART\_ID\_1, &uart\_dma\_cfg);

1. ` `Configure the DMA interrupt handler. The interrupt handlers can be customized. The following code

serves as an example.

hal\_uart\_irq\_set\_dma\_handler(HAL\_UART\_ID\_1, test\_uart\_dma\_rx\_irq\_handler,

test\_uart\_dma\_tx\_irq\_handler);

static void test\_uart\_dma\_tx\_irq\_handler(uint32\_t xfer\_size, int

dma\_error)

{

if (dma\_error) {

}

g\_tx\_dma\_done = true;

}

static void test\_uart\_dma\_rx\_irq\_handler(uint32\_t xfer\_size, int

dma\_error, union HAL\_UART\_IRQ\_T status)

Rev 1.2 Page38 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.041.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

{

if (dma\_error) {

} else if (status.BE || status.FE || status.OE || status.PE) {

} else {

/\* user application after received the data. \*/

if (g\_tx\_dma\_done) {

g\_tx\_dma\_done = 0;

hal\_uart\_dma\_send(HAL\_UART\_ID\_1, g\_test\_rx\_buf, xfer\_size,

NULL, NULL);

}

{

union HAL\_UART\_IRQ\_T mask;

mask.reg = 0;

mask.BE = 1;

mask.FE = 1;

mask.OE = 1;

mask.PE = 0;

mask.RT = 1;

hal\_uart\_dma\_recv\_mask(HAL\_UART\_ID\_1, g\_test\_rx\_buf,

RX\_BUF\_MAX, NULL, NULL, &mask);

}

}

}

1. ` `Send data via DMA.

hal\_uart\_dma\_send(HAL\_UART\_ID\_1, (uint8\_t \*)UART\_TX\_STRING\_1,

sizeof(UART\_TX\_STRING\_1), NULL, NULL);

1. ` `Stop the receiver after finishing using it.

hal\_uart\_stop\_dma\_recv(HAL\_UART\_ID\_1);

**Sample Code 2: Use UART1**

{"uart1\_transmit\_demo", uart1\_demo\_test},

[TEST, uart1\_transmit\_demo]

1. ` `**Use I2C**

I2C (inter-integrated circuit) serves as an interface between the microcontroller and the serial I2C bus.

Rev 1.2 Page39 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.042.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**I2C Configuration**

The following table describes the configuration items.

\- I2C configuration

**Table 4 I2C Configuration**

**Item Description Notes**

struct Configuration struct HAL\_I2C\_CONFIG\_T {

HAL\_I2C\_CONFIG\_T enum HAL\_I2C\_API\_MODE\_T mode;

uint8\_t use\_sync : 1;

uint8\_t use\_dma : 1;

uint8\_t as\_master : 1;

uint16\_t rising\_time\_ns;

uint32\_t speed;

uint32\_t addr\_as\_slave;

};

enum HAL\_I2C\_ID\_T ID of I2c enum HAL\_I2C\_ID\_T {

HAL\_I2C\_ID\_0 = 0,

#ifdef I2C1\_BASE

HAL\_I2C\_ID\_1,

#endif

#ifdef I2C2\_BASE

HAL\_I2C\_ID\_2,

#endif

#ifdef I2C3\_BASE

HAL\_I2C\_ID\_3,

#endif

#ifdef I2C4\_BASE

HAL\_I2C\_ID\_4,

#endif

#ifdef I2C5\_BASE

HAL\_I2C\_ID\_5,

#endif

HAL\_I2C\_ID\_NUM,

};

enum Action after enum HAL\_I2C\_ACTION\_AFTER\_WRITE\_T {

HAL\_I2C\_ACTION\_AF write HAL\_I2C\_STOP\_AFTER\_WRITE = 0,

TER\_WRITE\_T HAL\_I2C\_RESTART\_AFTER\_WRITE,

};

Rev 1.2 Page40 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.043.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

Use the following sample code to configure I2C0

Steps to follow:

1. ` `Configure I2C. In this example, the mode is task mode, DMA is disabled (When DMA is enabled, the

macro:I2C\_USE\_DMA=1 needs to be added). Use isochronous transfer while the speed is 100000. And the

MCU is set as the master.

struct HAL\_I2C\_CONFIG\_T cfg;

memset(&cfg, 0, sizeof(cfg));

cfg.mode = HAL\_I2C\_API\_MODE\_TASK;

cfg.use\_dma = 0;

cfg.use\_sync = 1;

cfg.speed = 100 \* 1000;

cfg.as\_master = 1;

1. ` `Set I2C IOMUX.

hal\_iomux\_set\_i2c0();

1. ` `Open I2C and use the structure defined in step 1.

static uint8\_t i2c\_id = HAL\_I2C\_ID\_0

hal\_i2c\_open(i2c\_id, &cfg);

1. ` `Close I2C after finishing using it.

uint32\_t hal\_i2c\_close(i2c\_id);

1. ` `**Data Transceiver**
1. ` `Send data via I2C. The meaning of each parameter is shown in Table 5. Among these parameters

HAL\_I2C\_ID\_T id, device\_addr, buf and value\_len are necessary.

ret = hal\_i2c\_send(i2c\_id, lsm6dsox\_address, lsm6dsox\_buffer, 1, len, 0,

NULL);

**Table 5 Parameter List of Function hal\_i2c\_send**

**Item Description**

enum HAL\_I2C\_ID\_T id ID of I2C

uint32\_t device\_addr Device (such as various sensors) address

uint8\_t \*buf Data to be sent

uint32\_t reg\_len The starting address of data to be sent

uint32\_t value\_len Length of data sent

uint32\_t transfer\_id Transfer ID

HAL\_I2C\_TRANSFER\_HANDLER\_T handler Transfer handler

Rev 1.2 Page41 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.044.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.046.jpeg)*Software Development User Guide*

1. ` `Receive data from I2C. The meaning of each parameter is shown in Table 6. Among these parameters

HAL\_I2C\_ID\_T id, device\_addr, buf and value\_len are necessary.

ret = hal\_i2c\_recv(i2c\_id, lsm6dsox\_address, lsm6dsox\_buffer, 1, len,

HAL\_I2C\_RESTART\_AFTER\_WRITE, 0, 0);

**Table 6 Parameter List of Function hal\_i2c\_recv**

**Item Description**

enum HAL\_I2C\_ID\_T id ID of I2C

uint32\_t device\_addr Device (such as various sensors) address

uint8\_t \*buf The buffer which stored data received

uint32\_t reg\_len The starting address of data stored

uint32\_t value\_len Length of data

uint8\_t restart\_after\_write Action after write

uint32\_t transfer\_id Transfer ID

HAL\_I2C\_TRANSFER\_HANDLER\_T handler Transfer handler

1. ` `**Use SPI**

The serial peripheral interface (SPI) allows half/full-duplex, synchronous, serial communication with external devices.

The interface can be configured as the master and in this case it provides the communication clock (SCK) to the external

slave device. The interface is also capable of operating in multi-master mode.

It may be used for a variety of purposes, including simplex synchronous transfers on two lines with a possible

bidirectional data line or reliable communication using CRC checking.

There are two SPIs on the board, and two sets of application programming interfaces. One is with letters lcd in the

functions’ names, while another without them, for example, Hal\_iomux\_set\_spilcd() and Hal\_iomux\_set\_spi(). This

paper takes SPI1 as an example, which means functions without lcd in their names are used.

1. ` `**SPI Configuration**

The following table describes the configuration items.

\- SPI configuration

**Table 7 SPI Configuration**

**Item Description Notes**

struct SPI struct HAL\_SPI\_CFG\_T {

HAL\_SPI\_CFG\_T configurtion uint32\_t rate;

bool clk\_delay\_half :1;

bool clk\_polarity :1;

Rev 1.2 Page42 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.047.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

bool slave :1;

bool dma\_rx :1;

bool dma\_tx :1;

bool rx\_sep\_line :1;

bool ext\_dss\_rw :1;

bool skip\_en :1;

uint8\_t cs;

uint8\_t tx\_bits;

uint8\_t rx\_bits;

uint8\_t rx\_frame\_bits;

uint8\_t samp\_delay;

};

1. ` `Configure SPI. In this example, the main board is set as the master.

#define SPI\_AS\_MASTER

struct HAL\_SPI\_CFG\_T spi\_cfg;

spi\_cfg.clk\_delay\_half = true;

spi\_cfg.clk\_polarity = true;

#ifdef SPI\_AS\_MASTER

spi\_cfg.slave = false;

#else

spi\_cfg.slave = true;

#endif

#ifdef SPI\_ENABLE\_DMA

spi\_cfg.dma\_rx = true;

spi\_cfg.dma\_tx = true;

#else

spi\_cfg.dma\_rx = false;

spi\_cfg.dma\_tx = false;

#endif

spi\_cfg.rx\_sep\_line = false;

spi\_cfg.cs = 0;

#ifdef SPI\_AS\_MASTER

spi\_cfg.rate = 12 \* 1000 \* 1000;

#else

spi\_cfg.rate = 20 \* 1000 \* 1000;

#endif

spi\_cfg.rx\_bits = 8;

spi\_cfg.tx\_bits = 8;

Rev 1.2 Page43 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.048.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.049.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.050.jpeg)*Software Development User Guide*

spi\_cfg.rx\_frame\_bits = 0;

1. ` `Set SPI MUX.

Hal\_iomux\_set\_spilcd();

1. ` `Open SPI using the structure defined in step 1.

uint32\_t error = 0;

error = hal\_spilcd\_open(&spi\_cfg);

1. ` `Close SPI after finishing using it.

int hal\_spilcd\_close(uint32\_t cs)

1. ` `**Data Transceiver**

There are two ways to send or receive data, as shown below:

1. ` `The CPU sends and receives data directly

Transmit:

ret = hal\_spilcd\_send(pbuf, len);

Receive:

ret = hal\_spilcd\_recv(cmd, outBuf, len + 1);

1. ` `Send and receive data via DMA

Transmit:

ret = hal\_spilcd\_dma\_send(pbuf, len, NULL);

Receive:

ret = hal\_spilcd\_dma\_recv(cmd, outBuf, len + 1, NULL);

1. ` `**Use I2S**

The I2S bus is dedicated to data transmission between audio devices and is widely used in various multi-media systems.

It is designed to transmit clock and data signals along separate wires.

1. ` `**I2S Configuration**

The following table describes the configuration items.

\- I2S configuration

**Table 8 I2S Configuration**

**Item Description Notes**

Rev 1.2 Page44 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.051.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

struct I2S struct HAL\_I2S\_CONFIG\_T {

HAL\_I2S\_CONFIG\_T configuration bool use\_dma;

bool chan\_sep\_buf;

bool sync\_start;

uint8\_t cycles;

uint8\_t bits;

uint8\_t channel\_num;

enum AUD\_CHANNEL\_MAP\_T channel\_map;

uint32\_t sample\_rate;

uint32\_t ext\_mclk\_freq;

};

enum I2S mode enum HAL\_I2S\_MODE\_T {

HAL\_I2S\_MODE\_T setting HAL\_I2S\_MODE\_NULL,

HAL\_I2S\_MODE\_MASTER,

HAL\_I2S\_MODE\_SLAVE,

};

enum AUD\_STREAM\_T Audio stream enum AUD\_STREAM\_T {

AUD\_STREAM\_PLAYBACK = 0,

AUD\_STREAM\_CAPTURE,

AUD\_STREAM\_NUM,

};

I2S can be used for playing music or recording. Both functions can be tested in a board-to-board fashion. That means,

one board is used for recording, the other for playing, and the two transmit audio via I2S.

1. ` `**Data Transceiver**

I2S is a synchronous transmission protocol, and the clock must be synchronized before you use it. I2S supports full-

duplex communication, but there is only one data line, and the transmission direction must be configured before data

transmission.

Steps to configure I2S:

1. ` `Get the clock.

hal\_cmu\_pll\_enable(HAL\_CMU\_PLL\_AUD, HAL\_CMU\_PLL\_USER\_AUD);

1. ` `Open I2S. In this example, set I2S0 to slave mode and the audio stream is playback and capture.

#define SENS\_I2S\_ID HAL\_I2S\_ID\_0

int ret;

Rev 1.2 Page45 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.052.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

ret = hal\_i2s\_open(SENS\_I2S\_ID, AUD\_STREAM\_PLAYBACK, HAL\_I2S\_MODE\_SLAVE);

ret = hal\_i2s\_open(SENS\_I2S\_ID, AUD\_STREAM\_CAPTURE, HAL\_I2S\_MODE\_SLAVE);

1. ` `Set up the streams. No PLAYBACK exists without CAPTURE. The sync\_start should be set as true when

you set up the PLAYBACK stream.

struct HAL\_I2S\_CONFIG\_T i2s\_cfg;

memset(&i2s\_cfg, 0, sizeof(i2s\_cfg));

i2s\_cfg.use\_dma = true;

i2s\_cfg.sync\_start = true;

i2s\_cfg.chan\_sep\_buf = false;

i2s\_cfg.bits = 16;

i2s\_cfg.channel\_num = 2;

i2s\_cfg.channel\_map = AUD\_CHANNEL\_MAP\_CH0 | AUD\_CHANNEL\_MAP\_CH1;

i2s\_cfg.sample\_rate = AUD\_SAMPRATE\_192000;

ret = hal\_i2s\_setup\_stream(SENS\_I2S\_ID, AUD\_STREAM\_PLAYBACK, &i2s\_cfg);

i2s\_cfg.sync\_start = false;

ret = hal\_i2s\_setup\_stream(SENS\_I2S\_ID, AUD\_STREAM\_CAPTURE, &i2s\_cfg);

1. ` `Initialize DMA.

memset(&dma\_cfg, 0, sizeof(dma\_cfg));

dma\_cfg.dst = 0;

dma\_cfg.dst\_bsize = HAL\_DMA\_BSIZE\_4;

dma\_cfg.dst\_periph = SENS\_I2S\_TX\_NO;

dma\_cfg.dst\_width = HAL\_DMA\_WIDTH\_HALFWORD;

dma\_cfg.handler = i2s\_tx\_handler;

dma\_cfg.src\_bsize = HAL\_DMA\_BSIZE\_4;

dma\_cfg.src\_tsize = sizeof(i2s\_tx\_buf[0]) / 2;

dma\_cfg.src\_width = HAL\_DMA\_WIDTH\_HALFWORD;

dma\_cfg.try\_burst = 1;

dma\_cfg.type = HAL\_DMA\_FLOW\_M2P\_DMA;

dma\_cfg.ch = hal\_audma\_get\_chan(dma\_cfg.dst\_periph, HAL\_DMA\_HIGH\_PRIO);

for (i = 0; i < I2S\_FRAME\_NUM; i++) {

dma\_cfg.src = (uint32\_t)&i2s\_tx\_buf[i][0];

ret = hal\_audma\_init\_desc(&i2s\_tx\_dma\_desc[i], &dma\_cfg,

&i2s\_tx\_dma\_desc[(i + 1) % I2S\_FRAME\_NUM], (i + 1) % (I2S\_FRAME\_NUM / 2) ==

0);

ASSERT(ret == 0, "Failed to init dma desc for tx");

}

Rev 1.2 Page46 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.053.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

1. ` `Start DMA

ret = hal\_audma\_sg\_start(&i2s\_rx\_dma\_desc[0], &dma\_cfg);

1. ` `Start I2S streaming.

ret = hal\_i2s\_start\_stream(MCU\_I2S\_ID, AUD\_STREAM\_PLAYBACK);

ret = hal\_i2s\_start\_stream(SENS\_I2S\_ID, AUD\_STREAM\_CAPTURE);

1. ` `**Use ADC**

The Analog to Digital Converter converts an analog signal with continuous time and continuous amplitude into a digital

signal with discrete time and discrete amplitude.

1. ` `**GPADC Configurable Items**

The following table describes the configuration items.

**Table 9 GPADC Configurable Items**

**Item Description Notes**

enum Channels of enum HAL\_GPADC\_CHAN\_T {

HAL\_GPADC\_CHAN\_T GPADC HAL\_GPADC\_CHAN\_0 = 0,

HAL\_GPADC\_CHAN\_BATTERY = 1,

HAL\_GPADC\_CHAN\_2 = 2,

HAL\_GPADC\_CHAN\_3 = 3,

HAL\_GPADC\_CHAN\_4 = 4,

HAL\_GPADC\_CHAN\_5 = 5,

HAL\_GPADC\_CHAN\_6 = 6,

HAL\_GPADC\_CHAN\_ADCKEY = 7,

HAL\_GPADC\_CHAN\_QTY,

};

enum The time of enum HAL\_GPADC\_ATP\_T {

HAL\_GPADC\_ATP\_T signal HAL\_GPADC\_ATP\_NULL = 0,

acquisition HAL\_GPADC\_ATP\_125US = 125,

HAL\_GPADC\_ATP\_500US = 500,

HAL\_GPADC\_ATP\_1MS = 1000,

HAL\_GPADC\_ATP\_2MS = 2000,

HAL\_GPADC\_ATP\_5MS = 5000,

HAL\_GPADC\_ATP\_10MS = 10000,

HAL\_GPADC\_ATP\_20MS = 20000,

HAL\_GPADC\_ATP\_30MS = 30000,

HAL\_GPADC\_ATP\_40MS = 40000,

Rev 1.2 Page47 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.054.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.055.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

HAL\_GPADC\_ATP\_50MS = 50000,

HAL\_GPADC\_ATP\_60MS = 60000,

HAL\_GPADC\_ATP\_ONESHOT = -1,

};

1. ` `**Usage**

In order to use GPADCs, call the interface hal\_gpadc\_open to open GPADC.

int hal\_gpadc\_open(enum HAL\_GPADC\_CHAN\_T channel, enum HAL\_GPADC\_ATP\_T atp,

HAL\_GPADC\_EVENT\_CB\_T cb)

GPADCs can be configured as one shot mode or acquiring for a period of time.

hal\_gpadc\_open(HAL\_GPADC\_CHAN\_0, HAL\_GPADC\_ATP\_ONESHOT,

pmu\_ntc\_irq\_handler);

hal\_gpadc\_open(HAL\_GPADC\_CHAN\_3, HAL\_GPADC\_ATP\_20MS, gpadc\_key\_handler);

**Sample Code 3: Use GPADC**

{"gpadc\_test", gpadc\_test},

[TEST,gpadc\_test]

1. ` `**Use Hardware Timer**

There are slow timer and fast timer in the BES2700YP, and each timer has four modes, free-running, one-shot, periodic

and quantity.

**Table 10 Hardware Timer Type**

**Item Description Notes**

enum Timer type enum HAL\_TIMER\_TYPE\_T {

HAL\_TIMER\_TYPE\_T HAL\_TIMER\_TYPE\_FREERUNNING = 0,

HAL\_TIMER\_TYPE\_ONESHOT,

HAL\_TIMER\_TYPE\_PERIODIC,

HAL\_TIMER\_TYPE\_QTY

};

Steps to use a hardware timer:

1. ` `Initialize IOMUX.

static const struct HAL\_IOMUX\_PIN\_FUNCTION\_MAP gpio\_output\_tester[] = {

Rev 1.2 Page48 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.056.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.057.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.058.jpeg)*Software Development User Guide*

{(enum HAL\_IOMUX\_PIN\_T)PIN\_OUT\_1, HAL\_IOMUX\_FUNC\_AS\_GPIO,

AL\_IOMUX\_PIN\_VOLTAGE\_VIO, HAL\_IOMUX\_PIN\_PULLUP\_ENABLE},

{(enum HAL\_IOMUX\_PIN\_T)PIN\_OUT\_2, HAL\_IOMUX\_FUNC\_AS\_GPIO,

AL\_IOMUX\_PIN\_VOLTAGE\_VIO, HAL\_IOMUX\_PIN\_PULLUP\_ENABLE},

};

hal\_iomux\_init(gpio\_output\_tester, 2);

1. ` `Set a direction.

hal\_gpio\_pin\_set\_dir((enum HAL\_GPIO\_PIN\_T)gpio\_output\_tester[0].pin,

HAL\_GPIO\_DIR\_OUT, 0);

hal\_gpio\_pin\_set\_dir((enum HAL\_GPIO\_PIN\_T)gpio\_output\_tester[1].pin,

HAL\_GPIO\_DIR\_OUT, 0);

1. ` `Set up a hardware timer.

hal\_timer\_setup(HAL\_TIMER\_TYPE\_ONESHOT, slow\_timer\_irq\_handler);

1. ` `Start the hardware timer

#define ONESLOT\_MS\_DEFAULT (2000)

hal\_timer\_start(MS\_TO\_TICKS(ONESLOT\_MS\_DEFAULT));

**Sample Code 4: Hardware Timer**

{"test\_hw\_timer", hw\_timer\_test},

[TEST, test\_hw\_timer]

1. ` `**Use PWM**
1. ` `**PWM Configuration**

The following table describes the configuration items.

\- IOMUX configuration

**Table 11 PWM IOMuX Coniguration**

**Item Description Notes**

struct PWM struct HAL\_PWM\_CFG\_T {

HAL\_PWM\_CFG\_T configuration uint32\_t freq;

uint8\_t ratio;// Duty cycle

bool inv; //Whether to reverse

polarity

Rev 1.2 Page49 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.059.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.060.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

bool sleep\_on;//Whether enable PWM while

master clock sleeping

};

Use the following sample code to configure GPIO\_3\_4, GPIO\_3\_5 GPIO\_36 and GPIO\_37 as a PWM in the 1.8v voltage

domain, no pull state.

struct HAL\_IOMUX\_PIN\_FUNCTION\_MAP pinmux\_pwm[] = {

{HAL\_IOMUX\_PIN\_P3\_4, HAL\_IOMUX\_FUNC\_PWM0, HAL\_IOMUX\_PIN\_VOLTAGE\_VIO,

HAL\_IOMUX\_PIN\_NOPULL},

{HAL\_IOMUX\_PIN\_P3\_5, HAL\_IOMUX\_FUNC\_PWM1, HAL\_IOMUX\_PIN\_VOLTAGE\_VIO,

HAL\_IOMUX\_PIN\_NOPULL},

{HAL\_IOMUX\_PIN\_P3\_6, HAL\_IOMUX\_FUNC\_PWM2, HAL\_IOMUX\_PIN\_VOLTAGE\_VIO,

HAL\_IOMUX\_PIN\_NOPULL},

{HAL\_IOMUX\_PIN\_P3\_7, HAL\_IOMUX\_FUNC\_PWM3, HAL\_IOMUX\_PIN\_VOLTAGE\_VIO,

HAL\_IOMUX\_PIN\_NOPULL},

};

hal\_iomux\_init(pinmux\_pwm, ARRAY\_SIZE(pinmux\_pwm));

Steps to configure PWM0, PWM1, PWM2 and PWM3:

1. ` `Initialize the GPIO’s IOMUX as PWM.

void app\_sample\_code\_set\_pwm(void)

{

struct HAL\_IOMUX\_PIN\_FUNCTION\_MAP pinmux\_pwm[] = {

{HAL\_IOMUX\_PIN\_P3\_4, HAL\_IOMUX\_FUNC\_PWM0,

HAL\_IOMUX\_PIN\_VOLTAGE\_VIO, HAL\_IOMUX\_PIN\_NOPULL},

{HAL\_IOMUX\_PIN\_P3\_5, HAL\_IOMUX\_FUNC\_PWM1,

HAL\_IOMUX\_PIN\_VOLTAGE\_VIO, HAL\_IOMUX\_PIN\_NOPULL},

{HAL\_IOMUX\_PIN\_P3\_6, HAL\_IOMUX\_FUNC\_PWM2,

HAL\_IOMUX\_PIN\_VOLTAGE\_VBAT, HAL\_IOMUX\_PIN\_NOPULL},

{HAL\_IOMUX\_PIN\_P3\_7, HAL\_IOMUX\_FUNC\_PWM3,

HAL\_IOMUX\_PIN\_VOLTAGE\_VBAT, HAL\_IOMUX\_PIN\_NOPULL},

};

hal\_iomux\_init(pinmux\_pwm, ARRAY\_SIZE(pinmux\_pwm));

}

1. ` `Configure PWM parameters. For example, the frequency of PWM0 is set as 8kHz, the duty cycle is 25%,

not reverse the polarity, and PWM is banned when the master clock is sleeping.

int ret;

Rev 1.2 Page50 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.061.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

struct HAL\_PWM\_CFG\_T pwm\_cfg = {

.freq = 8000,

.ratio = 25,

.inv = false,

.sleep\_on = false,

};

app\_sample\_code\_set\_pwm();

TRACE(0, "PWM test has started...");

TRACE(0, "Please use an oscilloscope to view the set pin waveform!");

pwm\_cfg.freq = 8000;

ret = hal\_pwm\_enable(HAL\_PWM\_ID\_0, &pwm\_cfg);

ASSERT(ret == 0, "Failed to enable PWM0: %d", ret);

pwm\_cfg.freq = 4000;

ret = hal\_pwm\_enable(HAL\_PWM\_ID\_1, &pwm\_cfg);

ASSERT(ret == 0, "Failed to enable PWM1: %d", ret);

pwm\_cfg.freq = 2000;

ret = hal\_pwm\_enable(HAL\_PWM\_ID\_2, &pwm\_cfg);

ASSERT(ret == 0, "Failed to enable PWM2: %d", ret);

pwm\_cfg.freq = 1000;

ret = hal\_pwm\_enable(HAL\_PWM\_ID\_3, &pwm\_cfg);

ASSERT(ret == 0, "Failed to enable PWM3: %d", ret);

After configuration, use an oscilloscope to view the set pin waveform.

1. ` `**Breathing LED**

The following table describes the configuration items.

**Table 12 Breathing LED Configuration**

**Item Description Notes**

struct Breathing LED struct HAL\_PWM\_BR\_CFG\_T {

HAL\_PWM\_BR\_CFG\_T configuration uint16\_t off\_time\_ms;

uint16\_t on\_time\_ms;

uint16\_t fade\_time\_ms;

};

Use the following sample code to enable Breathing LED and set the off time as 100ms, on time 100ms, fade time

1500ms.

struct HAL\_PWM\_BR\_CFG\_T pwm\_br\_cfg = {

.off\_time\_ms = 100,

Rev 1.2 Page51 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.062.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

.on\_time\_ms = 100,

.fade\_time\_ms = 1500,

};

ret = hal\_pwm\_breathing\_led\_enable(HAL\_PWM\_ID\_0, &pwm\_br\_cfg);

TRACE(1, "open breath1:%d,%s", ret, ret ? "error" : "success");

ret = hal\_pwm\_breathing\_led\_enable(HAL\_PWM\_ID\_1, &pwm\_br\_cfg);

TRACE(1, "open breath2:%d,%s", ret, ret ? "error" : "success");

ret = hal\_pwm\_breathing\_led\_enable(HAL\_PWM\_ID\_2, &pwm\_br\_cfg);

TRACE(1, "open breath3:%d,%s", ret, ret ? "error" : "success");

ret = hal\_pwm\_breathing\_led\_enable(HAL\_PWM\_ID\_3, &pwm\_br\_cfg);

TRACE(1, "open breath4:%d,%s", ret, ret ? "error" : "success");

1. ` `**DMA**

Direct memory access (DMA) is used in order to provide high-speed data transfer between peripherals and memory as

well as from memory to memory. Data can be quickly moved by DMA without any CPU actions. This frees CPU

resources for other operations.

1. ` `**DMA Configuration**

The following table describes the configuration items.

\- DMA configuration

**Table 13 DMA Coniguration**

**Item Description Notes**

enum DMA return enum HAL\_DMA\_RET\_T {

HAL\_DMA\_RET\_T value HAL\_DMA\_OK,

HAL\_DMA\_ERR,

};

struct DMA channel struct HAL\_DMA\_CH\_CFG\_T {

HAL\_DMA\_CH\_CFG\_T configuration uint8\_t ch; /\* DMA

channel number \*/

uint8\_t try\_burst;

uint16\_t src\_tsize; /\*

Length/Size of transfer \*/

enum HAL\_DMA\_WDITH\_T src\_width;

enum HAL\_DMA\_WDITH\_T dst\_width;

enum HAL\_DMA\_BSIZE\_T src\_bsize;

enum HAL\_DMA\_BSIZE\_T dst\_bsize;

Rev 1.2 Page52 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.063.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

enum HAL\_DMA\_FLOW\_CONTROL\_T type; /\*

Transfer Type \*/

enum HAL\_DMA\_PERIPH\_T src\_periph;

enum HAL\_DMA\_PERIPH\_T dst\_periph;

uint32\_t src; /\*

Physical Source Address \*/

uint32\_t dst; /\*

Physical Destination Address \*/

HAL\_DMA\_IRQ\_HANDLER\_T handler;

HAL\_DMA\_START\_CALLBACK\_T start\_cb;

};

struct Transfer struct HAL\_DMA\_DESC\_T {

HAL\_DMA\_DESC\_T descriptor uint32\_t src; /\* Source address \*/

structure uint32\_t dst; /\* Destination address

\*/

uint32\_t lli; /\* Pointer to next

descriptor structure \*/

uint32\_t ctrl; /\* Control word that

has transfer size, type etc. \*/

};

enum DMA prioity enum HAL\_DMA\_GET\_CHAN\_T {

HAL\_DMA\_GET\_CHAN\_ HAL\_DMA\_HIGH\_PRIO,

T HAL\_DMA\_LOW\_PRIO,

HAL\_DMA\_LOW\_PRIO\_ONLY

};

1. ` `**DMA Usage**

DMA transfers copy data from one address space to another. When the CPU initiates the transfer, the transfer itself is

performed and completed by the DMA controller. A typical example is moving a block of external memory to a faster

memory area inside the chip. Operations like this will not stall processor work, but can be descheduled to handle other

work. DMA transfers are important for high performance embedded system algorithms and networks.

Steps to use DMA:

1. ` `Configure DMA return struct.

enum HAL\_DMA\_RET\_T ret = HAL\_DMA\_OK;

1. ` `Clear destination buffers and set source destination.

uint32\_t i = 0;

Rev 1.2 Page53 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.064.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

for (i = 0; i < SRC\_BUF\_MAX; i++) {

dst\_buf[i] = 0;

src\_buf[i] = (i<<16) | i;

}

1. ` `Open DMA.

hal\_dma\_open();

1. ` `Configure DMA description.

struct HAL\_DMA\_CH\_CFG\_T cfg = {0};

cfg.type = DMA\_TYPE;

cfg.src = (uint32\_t)src\_buf;

cfg.src\_tsize = SRC\_BUF\_MAX / DMA\_SRC\_BUSRT\_SIZE;

cfg.src\_bsize = DMA\_SRC\_BUSRT\_SIZE;

cfg.src\_width = DMA\_SRC\_XFER\_WIDTH;

cfg.src\_periph = DMA\_SRC\_PERIPH;

cfg.dst = (uint32\_t)dst\_buf;

cfg.dst\_bsize = DMA\_DST\_BUSRT\_SIZE;

cfg.dst\_width = DMA\_DST\_XFER\_WIDTH;

cfg.dst\_periph = DMA\_DST\_PERIPH;

cfg.try\_burst = 1;

cfg.handler = dma\_handler;

cfg.start\_cb = dma\_start\_cb;

cfg.ch = hal\_dma\_get\_chan(DMA\_PERIPH, HAL\_DMA\_HIGH\_PRIO);

1. ` `Configure transfer descriptor structure, which includes source address, destination address, pointer to

next descriptor structure and control word that has transfer size, type, etc.

ret = hal\_dma\_init\_desc(&g\_dma\_desc, &cfg, NULL, DMA\_TC\_IRQ\_ENABLE);

1. ` `Start DMA.

ret = hal\_dma\_sg\_start(&g\_dma\_desc, &cfg);

Stop.

1. ` `**Memory Map**

This section describes the logic address map and the method to use it.

Rev 1.2 Page54 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.066.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Logic Address Map**

Although the logic addresses of these cores are different, some of them point to the same physical address: BTH RAM

and BTH RAMX/FRAMX. The sensor hub RAM and sensor hub RAMX point to another physical address. BTH FLASH, BTH

FLASH\_NC and BTH FLASHX point to the same physical address, too.

The cores with X in their names integrate ITCM (Instruction Tightly Memory) and the cores without it integrate DTCM

(Data Tightly Memory). It is recommended to put instruction in cores with X in names while putting data in cores

without it.

The logic address map of BES2700YP is as follows.

*Shared memory*

**Figure 16 Logical Address Map**

1. ` `**Flash Memory Map**

There are four main flash sections:

**Secondary bootloader:**

Once programmed, never changed, in charge of image mapping and jumping to the dedicated image.

FLASH\_OTA\_BOOT\_INFO\_T is located at 0x1000, to tell the secondary bootloader which Image area shall be mapped

and jumped to.

**A area and B area:**

Dual copy sections include the application image, voice prompt and other user binaries that needs to be updated all-

together over the air.

A and B areas have the same size and same start offset of each sub-sections.

Rev 1.2 Page55 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.067.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

As the BES QSPI controller support flash physical->logic address mapping, OTA procedure could program the new image

to the area flip-flop according the current applied area.

**Volatile sections:**

Store the information that changes all over the life time. E.g. TWS&mobile pairing information, volume, etc.

**Non-volatile sections:**

Never changed once programmed on the production line.

The factory section is always located at the last 4KB flash page, for the BES download tool to program the non-volatile

information: classic BT mac address, BT name. BLE mac address, BLE name, and XTAL trim value.

The ANC audio configuration section is to store the ANC configuration and the ANC related calibration values gathered

from the production line.

The flash memory map is as follows:

**Figure 17 Flash Memory Map for OTA**

1. ` `**Audio Buffer Usage**

All the free RAM can be used as audio buffer. Audio buffer is divided into audio buffer and capture audio buffer. There

are two macros: APP\_AUDIO\_BUFFER\_SIZE and APP\_CAPTURE\_AUDIO\_BUFFER\_SIZE. The former one is the size of

audio buffer and the last one is the size of capture audio buffer. Audio buffer ranges from the top of the free RAM

Rev 1.2 Page56 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.068.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.037.jpeg)*Software Development User Guide*

space to "top + APP\_AUDIO\_BUFFER\_SIZE" while capture audio buffer rangers from "tail -

APP\_CAPTURE\_AUDIO\_BUFFER\_SIZE" to the tail of the free RAM space. Audio buffer uses syspool from the beginning,

and capture buffer uses syspool from the end. Make sure that they are not overlapped with each other.

Steps to allocate memory to audio buffer (Take playing music as example):

1. ` `Initialize the memory pool with a specific size.

app\_audio\_mempool\_init\_with\_specific\_size(APP\_AUDIO\_BUFFER\_SIZE);

1. ` `Get the address of memory that was allocated to audio buffer.

app\_audio\_mempool\_get\_buff(&bt\_audio\_buff, stream\_cfg.data\_size);

Steps to allocate memory to capture audio buffer (Take voice wake-up as example):

1. ` `Initialize the capture audio memory pool.

app\_capture\_audio\_mempool\_init();

1. ` `Get the address of memory that was allocated to capture audio buffer.

app\_capture\_audio\_mempool\_get\_buff(&buf,APP\_CAPTURE\_AUDIO\_BUFFER\_SIZE)

In scenarios where both decoding and encoding exist, allocate memory as follows:

1. ` `Initialize the memory pool.

app\_audio\_mempool\_init();

1. ` `Get the address.

app\_audio\_mempool\_get\_buff(&bt\_audio\_buff, stream\_cfg.data\_size);

1. ` `**Memory Usage in Link Script**

In our project, the link script is generated from the template file. For example, in the project of BES2700YP, the

template file is named best1000.lds.S which is located in scripts\link\ best1000.lds.S. The link script generated from

template file is named \_best1000.lds which is located in out\best1600\_ibrt\\_best1000.lds.

Template of memory part:

MEMORY

{

ROM (rx) : ORIGIN = ROM\_BASE, LENGTH = ROM\_SIZE

FLASH (r) : ORIGIN = FLASH\_REGION\_BASE, LENGTH =

FLASH\_REGION\_SIZE

Rev 1.2 Page57 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.069.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

FLASH\_NC (r) : ORIGIN = FLASH\_NC\_REGION\_BASE, LENGTH =

FLASH\_REGION\_SIZE

#ifdef USE\_MULTI\_FLASH

FLASH1 (r) : ORIGIN = FLASH1\_REGION\_BASE, LENGTH =

FLASH1\_REGION\_SIZE

FLASH1\_NC (r) : ORIGIN = FLASH1\_NC\_REGION\_BASE, LENGTH =

FLASH1\_REGION\_SIZE

#endif

#ifndef FLASHX

FLASHX (rx) : ORIGIN = FLASHX\_REGION\_BASE, LENGTH =

FLASH\_REGION\_SIZE

#endif

#ifdef MAIN\_RAM\_USE\_TCM

RAM (rwx) : ORIGIN = RAM\_BASE, LENGTH = RAM\_SIZE

RAMX (rx) : ORIGIN = RAMX\_BASE, LENGTH = RAMX\_SIZE

#else

RAM (rwx) : ORIGIN = RAM\_BASE, LENGTH = RAM\_SIZE -

FAST\_XRAM\_SECTION\_SIZE

RAMX (rx) : ORIGIN = RAMX\_BASE, LENGTH = RAM\_SIZE -

FAST\_XRAM\_SECTION\_SIZE

FRAMX (rwx) : ORIGIN = RAMX\_BASE + RAM\_SIZE -

FAST\_XRAM\_SECTION\_SIZE, LENGTH = FAST\_XRAM\_SECTION\_SIZE

#endif

#ifdef RAM\_NC\_BASE

RAM\_NC (rw) : ORIGIN = RAM\_NC\_BASE, LENGTH = RAM\_NC\_SIZE

#endif

#if defined(ARM\_CMSE) && defined(INTSRAM\_RUN)

RAMX\_NSC (rx) : ORIGIN = RAMX\_BASE + RAM\_S\_SIZE, LENGTH =

RAM\_NSC\_SIZE

#endif

#if (defined(PSRAM\_ENABLE) || defined(PSRAM\_HEAP\_ONLY)) &&defined(PSRAM\_BASE) && (PSRAM\_SIZE > 0)

PSRAM (rwx) : ORIGIN = PSRAM\_BASE, LENGTH =

PSRAM\_REGION\_SIZE

PSRAM\_NC (rwx) : ORIGIN = PSRAM\_NC\_BASE, LENGTH =

PSRAM\_REGION\_SIZE

#ifndef PSRAMX

PSRAMX (rwx) : ORIGIN = PSRAMX\_BASE, LENGTH =

PSRAM\_REGION\_SIZE

Rev 1.2 Page58 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.070.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

#endif

#endif

#if defined(PSRAMUHS\_ENABLE) && defined(PSRAMUHS\_BASE) &&

(MCU\_PSRAMUHS\_SIZE > 0)

PSRAMUHS (rwx) : ORIGIN = MCU\_PSRAMUHS\_BASE, LENGTH =

MCU\_PSRAMUHS\_SIZE

PSRAMUHS\_NC (rwx) : ORIGIN = MCU\_PSRAMUHS\_NC\_BASE, LENGTH =

MCU\_PSRAMUHS\_SIZE

#ifndef PSRAMUHSX

PSRAMUHSX (rx) : ORIGIN = MCU\_PSRAMUHSX\_BASE, LENGTH =

MCU\_PSRAMUHS\_SIZE

#endif

#endif

#if defined(CP\_IN\_SAME\_EE) && (RAMCP\_SIZE > 0)

RAMCP (rwx) : ORIGIN = RAMCP\_BASE, LENGTH = RAMCP\_SIZE

RAMCPX (rwx) : ORIGIN = RAMCPX\_BASE, LENGTH = RAMCPX\_SIZE

#endif

#ifdef MEM\_POOL\_BASE

MEM\_POOL (rwx) : ORIGIN = MEM\_POOL\_BASE, LENGTH =

MEM\_POOL\_SIZE

#endif

}

Memory part in the link script:

MEMORY

{

ROM (rx) : ORIGIN = 0x00020000, LENGTH = 0x00018000

FLASH (r) : ORIGIN = (0x34000000), LENGTH = (0x800000 - ((0x34000000) -

0x34000000))

FLASH\_NC (r) : ORIGIN = (((0x34000000)) - 0x34000000 + 0x30000000), LENGTH

= (0x800000 - ((0x34000000) - 0x34000000))

FLASHX (rx) : ORIGIN = (((0x34000000)) - 0x34000000 + 0x14000000), LENGTH

= (0x800000 - ((0x34000000) - 0x34000000))

RAM (rwx) : ORIGIN = 0x20500000, LENGTH = 0xE0000 - 0x15500

RAMX (rx) : ORIGIN = (0x20500000 - 0x20500000 + 0x00500000), LENGTH =

0xE0000 - 0x15500

FRAMX (rwx) : ORIGIN = (0x20500000 - 0x20500000 + 0x00500000) + 0xE0000 -

0x15500, LENGTH = 0x15500

}

Rev 1.2 Page59 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.071.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

In order to revise the memory map, modify the value of FAST\_XRAM\_SECTION\_SIZE. Do not modify other macros. The

detailed method is described in section 5.6.

1. ` `**Define a Specific Section and Use it**

In order to define a specific section and use it, you can define a section in the template of link script and use it in the

code.

Here is an example:

1. ` `Define a specific section.

\_\_core\_bridge\_task\_cmd\_table\_start = .;

KEEP(\*(.core\_bridge\_task\_cmd\_table))

\_\_core\_bridge\_task\_cmd\_table\_end = .;

. = ALIGN(4);

1. ` `Use it in the code.

\_\_attribute\_\_((used, section(".core\_bridge\_task\_cmd\_table")) =

app\_esehll\_bridge\_tx\_done\_handler;

1. ` `**Coordinate Ram Size**

Fast ram sections can be coordinated to give more space to ram/ramx sections. In order to do this, you are supposed to

coordinate FAST\_XRAM\_SECTION\_SIZE.

Steps to coordinate ram size:

1. ` `Search \_\_free\_ in out\best1600\_ibrt\best1600\_ibrt.map to check if there is still free fast ram. As the

following code shows, the preceding number is the free size of fast ram. The second number means the

space of the whole fast ram.

0x000000000000e660 \_\_free\_fram = (0x21800 - (\_\_fast\_sram\_end\_\_

\- \_\_fast\_sram\_text\_data\_start\_\_))

0x00000000000527a0 \_\_free\_ram = (\_\_StackLimit - \_\_HeapLimit)

0x000000000053b4d8 \_\_free\_flash = (((\_\_tail\_section\_start -

0x30000000) + 0x34000000) - \_\_flash\_end)

1. ` `Define macro FAST\_XRAM\_SECTION\_SIZE, whose value is the second number found in Step 1 minus the

size that you want to give to other sections. Be careful not to subtract more than the size of free ram.

##define FAST\_XRAM\_SECTION\_SIZE 0x15500

Rev 1.2 Page60 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.072.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Overlay Usage**

Since a program does not access all parts of the program and data at all times (especially for large programs), the user

space can be divided into a fixed area and several coverage areas. Put the frequently active parts in the fixed area, and

the rest are segmented according to the calling relationship. First, put those segments to be accessed in the coverage

area, and other segments are placed in the external memory. Before they need to be called, the system calls them into

the coverage area, which replaces the original segment in the coverage area.

The role of the overlay technology is to divide the program into several program segments with relatively independent

functions, and make program segments not running at the same time share the same memory area according to their

own logical structure.

For example, audio buffer of music and that of call cannot be used at the same time. In this case, this section can be

overlaid. The overlay section can not only be distinguished by functional types, but also by encoding such as AAC, SBC,

LDPC, etc. Whichever way it is, be sure that they don’t use the same section of ram at the same time. The overlay

section is separated from fast ram.

The following table describes the configuration items.

\- Overlay configuration

**Table 14 Overlay Configuration**

**Item Description Notes**

enum Overlay ID Depends on how it is coded and how it works such as

APP\_OVERLAY\_ID\_T APP\_OVERLAY\_HFP = HAL\_OVERLAY\_ID\_0.

See services\overlay\app\_overlay.h for details

There are 12 overlay\_text sections and 12 overlay\_data sections. As the name suggests, the former is used for code and

the latter is used for data.

Steps to add a custom overlay:

1. ` `Find a section that is unused, and put files generated after compilation here. In this example, data of

flac\_com.o is used.

.overlay\_data10

{

LONG(0);

\*:flac\_com.o(.data\* .rodata\*)

\*(.overlay\_data10 .overlay\_rodata10)

. = ALIGN(4);

}

Rev 1.2 Page61 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.073.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

1. ` `Select an overlay method. In this example, A2DP LHDC encoder is specified.

app\_overlay\_select(APP\_OVERLAY\_A2DP\_LHDC\_ENCODER);

1. ` `After use, unload overlay.

app\_overlay\_unloadall();

1. ` `**System API**
1. ` `**System Ticks**
1. ` `**RTC Setting**

System ticks are in the unit of 16000 Hz lower power clock ticks: 1/16000 seconds. The API to get passed system ticks

since the system powers on is as follows:

#define GET\_CURRENT\_TICKS() hal\_sys\_timer\_get()

The API to get passed system mill-seconds since the system powers on is as follows:

#define GET\_CURRENT\_MS() TICKS\_TO\_MS(GET\_CURRENT\_TICKS())

**Sample Code 5: Get Current Time**

{"get\_current\_ticks", get\_current\_ticks\_test},

[TEST, get\_current\_ticks]

{"get\_current\_ms", get\_current\_ms\_test},

[TEST, get\_current\_ms]

1. ` `**Automatically Calibrate the Clock**

BES2700YP can calibrate the slave clock with the help of the slave clock. If the slave clock is found to be inaccurate, just

open the macros OSTICK\_USE\_FAST\_TIMER and FAST\_TIMER\_COMPENSATE.

For example:

export OSTICK\_USE\_FAST\_TIMER ?= 1

export FAST\_TIMER\_COMPENSATE ?= 1

1. ` `**Battery Management**
1. ` `**Charger Event Handler**

The charger event handler is registered by the interface app\_battery\_register. Use the following code to register the

IBRT battery callback.

Rev 1.2 Page62 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.074.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.037.jpeg)*Software Development User Guide*

app\_battery\_register(app\_ibrt\_battery\_callback);

void app\_ibrt\_battery\_callback(APP\_BATTERY\_MV\_T currvolt, uint8\_t

currlevel,enum APP\_BATTERY\_STATUS\_T curstatus,uint32\_t status, union

APP\_BATTERY\_MSG\_PRAMS prams)

{

switch (curstatus)

{

case APP\_BATTERY\_STATUS\_NORMAL:

case APP\_BATTERY\_STATUS\_CHARGING:

app\_ibrt\_battery\_handle\_process\_normal(status,prams);

break;

default:

break;

}

}

1. ` `**Battery Level Measurement**

You can change the following configurations based on actual scenarios.

The battery level is divided into nine levels.

#define APP\_BATTERY\_LEVEL\_MAX (9)

When the battery is full, the voltage is 4200 mV.

#define APP\_BATTERY\_MAX\_MV (4200)

When the battery is exhausted and the earphone automatically powers down, the voltage is 3100 mV

#ifndef APP\_BATTERY\_PD\_MV

#define APP\_BATTERY\_PD\_MV (3100)

#endif

The difference between the maximum voltage and power down voltage is divided into several equal parts, and the

macro APP\_BATTERY\_MV\_BASE in the value of each part.

#define APP\_BATTERY\_LEVEL\_MIN (0)

#define APP\_BATTERY\_LEVEL\_NUM (APP\_BATTERY\_LEVEL\_MAX-

APP\_BATTERY\_LEVEL\_MIN+1)

#define APP\_BATTERY\_MV\_BASE ((APP\_BATTERY\_MAX\_MV-

APP\_BATTERY\_PD\_MV)/(APP\_BATTERY\_LEVEL\_NUM)).

Rev 1.2 Page63 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.075.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

If you want to use their own battery management, set the value of macro IS\_BES\_BATTERY\_MANAGER\_ENABLED to

zero.

**Sample Code 6: Get Current Battery Level**

{"current\_battery\_level", get\_current\_battery\_level\_test},

[TEST, current\_battery\_level]

1. ` `**UART Data Path**
1. ` `**UART Data Path**

**Figure 18 UART Data Path**

For the UART data path, the PC connects to the main board via the data cable. The PC acts as an upper-computer while

the main board is lower-computer. For downstream data transmission, the PC transfers data to the main board. For

upstream data transmission, the main board transfers data to the PC.

1. ` `**UART Loopback Data Path**

A loopback test is a test in which a signal from a communication device is returned to its original place. A loopback test

is to determine whether there is a breakpoint in the line or port by shorting the transceiver of the equipment under test

or the line to let the equipment under test receive the signal sent by itself. It can also hang a test instrument on the

loopback line to test the transmission quality.

There is a macro TEST\_UART\_LOOP\_BACK which controls the loopback test. To enable a loopback test, change its value

to 1.

#define TEST\_UART\_LOOP\_BACK 1

Rev 1.2 Page64 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.076.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

In the test, APP\_UART\_ID is the ID of UART to be tested, and CONFIG\_UART\_BAUDRATE is baud rate. Use the following

sample code to set UART0 for the looptest, and the baud rate is 1152000.

#define APP\_UART\_ID HAL\_UART\_ID\_0

#define CONFIG\_UART\_BAUDRATE 1152000

The following function registers a callback. Once the main board receives the data sent from upper-computer,

app\_process\_uart prints it via the debug port.

app\_uart\_register\_data\_receiver(app\_process\_uart);

static void app\_process\_uart(uint8\_t \*ptr, uint32\_t len)

{

TRACE(0, "app\_process\_uart: %s", ptr);

}

After registration, the board starts receiving data.

app\_uart\_start\_receiving\_data();

After receiving data from upper-computer, the board transfers it back.

uart\_dma\_send\_data(ptr, bytesInBuffer);

1. ` `**Add UART Test Command**

Steps to add UART test command and use it:

1. ` `Register UART command callback function.

app\_trace\_rx\_register("AOB", ble\_audio\_uart\_cmd\_callback);

unsigned int ble\_audio\_uart\_cmd\_callback(unsigned char \*cmd, unsigned int

cmd\_length)

{

int param\_len = 0;

char\* cmd\_param = NULL;

char\* cmd\_end = (char \*)cmd + cmd\_length;

cmd\_param = strstr((char\*)cmd, (char\*)"|");

if (cmd\_param)

{

\*cmd\_param = '\0';

cmd\_length = cmd\_param - (char \*)cmd;

cmd\_param += 1;

param\_len = cmd\_end - cmd\_param;

Rev 1.2 Page65 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.077.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

ble\_audio\_uart\_cmd\_with\_param\_handler((char \*)cmd, cmd\_length,

cmd\_param, param\_len);

}

else

{

ble\_audio\_uart\_cmd\_handler((unsigned char\*)cmd,strlen((char\*)cmd));

}

return 0;

}

1. ` `Define UART command handler that used in step1.

int ble\_audio\_uart\_cmd\_with\_param\_handler(

char\* cmd, uint32\_t cmdLen, char\* cmdParam, uint32\_t cmdParamLen)

{

int ret = 0;

ble\_audio\_uart\_test\_function\_handle\_with\_param handl\_function =

ble\_audio\_test\_find\_uart\_handle\_with\_param(cmd);

if(handl\_function)

{

handl\_function(cmdParam, cmdParamLen);

}

else

{

ret = -1;

TRACE(0,"can not find handle function");

}

return ret;

}

int ble\_audio\_uart\_cmd\_handler(unsigned char \*buf, unsigned int length)

{

int ret = 0;

ble\_audio\_uart\_test\_function\_handle handl\_function =

ble\_audio\_test\_find\_uart\_handle(buf);

if(handl\_function)

{

app\_bt\_start\_custom\_function\_in\_bt\_thread(0, 0,

(uint32\_t)handl\_function);

}

Rev 1.2 Page66 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.078.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.035.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.079.jpeg)*Software Development User Guide*

else

{

ret = -1;

TRACE(0,"can not find handle function");

}

return ret;

}

1. ` `Find handle function with UART command.

ble\_audio\_uart\_test\_function\_handle handl\_function =

ble\_audio\_test\_find\_uart\_handle(buf);

ble\_audio\_uart\_test\_function\_handle

ble\_audio\_test\_find\_uart\_handle(unsigned char\* buf)

{

ble\_audio\_uart\_test\_function\_handle p = NULL;

for(uint32\_t i = 0; i < ARRAY\_SIZE(aob\_uart\_test\_handle); i++)

{

if (strncmp((char\*)buf, aob\_uart\_test\_handle[i].string,

strlen(aob\_uart\_test\_handle[i].string))==0 ||

strstr(aob\_uart\_test\_handle[i].string, (char\*)buf))

{

TRACE(1, "AOB cmd:%s", aob\_uart\_test\_handle[i].string);

p = aob\_uart\_test\_handle[i].function;

break;

}

}

return p;

}

1. ` `Define UART handle struct, and add command in the UART command table.

typedef struct

{

const char\* string;

ble\_audio\_uart\_test\_function\_handle function;

} ble\_audio\_uart\_handle\_t;

static const ble\_audio\_uart\_handle\_t aob\_uart\_test\_handle[] = {

{"start\_adv",ble\_audio\_start\_advertising},

}

1. ` `Define handler for the command.

Rev 1.2 Page67 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.080.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.037.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.081.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.082.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

static void ble\_audio\_stop\_adv()

{

if(!aob\_conn\_stop\_adv())

TRACE(2, "%s:stop adv fail", \_\_func\_\_);

}

While sending UART commands, it should be noted that the command should be wrapped in brackets [], the first

parameter of the UART command is defined when registering UART command callback function, and the second

parameter is defined in the UART command table.

There are two examples of how to use UART command:

1. ` `Use UART command without parameter.

[AOB,start\_adv]

1. ` `Use UART command with parameter. Please note that the first parameter for the handler and the handler should

be separated by | , and the remaining parameters should be separated by space.

[AOB,update\_timing|1 2 4 1 2 4 1 8]

1. ` `**Dynamic Frequency**

The system frequency uses the vote mechanism for the choice of frequency when multiple users may request different

frequencies.

Basically, the highest requested frequency will be the configured value if several users ask for different frequencies. If a

user doesn’t need a frequency anymore, it will release the frequency and the existing frequency request list will be

went through again to choose the highest one.

\- Dynamic frequency setting

**Table 15 Dynamic Frequency Setting**

**Item Description Notes**

enum Users The users can be found in emulator list:

APP\_SYSFREQ\_USER\_T requesting

frequencies

enum Frequency Configurable clock frequency can be found in

APP\_SYSFREQ\_FREQ\_T apps\common\app\_utils.h

You can use the following function to request a specific frequency.

int app\_sysfreq\_req(enum APP\_SYSFREQ\_USER\_T user, enum APP\_SYSFREQ\_FREQ\_T

freq);

Rev 1.2 Page68 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.083.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

By default, each user is assigned with APP\_SYSFREQ\_32K and the system frequency is 32KHz, which means that the

system can enter into deep sleep mode.

If any user requests a frequency higher that 32KHz, the system cannot enter into deep sleep mode.

For example:

The user app\_1 needs 24MHz. The system frequency is switched to 24MHz.

app\_sysfreq\_req(APP\_SYSFREQ\_USER\_APP\_1, APP\_SYSFREQ\_26M);

The user app\_2 needs 48MHz. The system frequency is switched to 48MHz.

app\_sysfreq\_req(APP\_SYSFREQ\_USER\_APP\_2, APP\_SYSFREQ\_48M);

The user app\_1 finishes the operation and releases the request. While app\_2 still needs 48MHz, the system frequency is

kept at 48MHz, and the system cannot enter into deep sleep mode.

app\_sysfreq\_req(APP\_SYSFREQ\_USER\_APP\_1, APP\_SYSFREQ\_32K);

The user app\_2 finishes the operation and releases the request. No user needs active mode frequency, so the system

can enter into deep sleep mode that uses low power 32KHz only.

app\_sysfreq\_req(APP\_SYSFREQ\_USER\_APP\_2, APP\_SYSFREQ\_32K);

1. ` `**Core Bridge**

Core Bridge is implemented as the communication data path between the MCU and sensor hub core or M55.

The core bridge handling flow is as follows.

Rev 1.2 Page69 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.084.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 19 Core Bridge Communication Datapath between MCU and Sensor Hub Core**

The MCU and sensor hub cores communicate via the hardware intersys bus. To manage the communication and

support multiple communications triggered at the same time, a top level core bridge command layer is designed.

There are two kinds of core bridge commands: task command and instant command.

They differ in receiving the data from the peer core. If the data belongs to the task command, it is pushed into the

queue and a signal is sent to the RX thread for command handling.

If the data belongs to the instant command, the data is immediately processed in the data receiving interrupt handler.

The task command definition is as follows:

typedef struct

{

uint16\_t cmdcode;

const char \*log\_cmd\_code\_str;

app\_core\_bridge\_cmd\_transmit\_handler\_t

core\_bridge\_cmd\_transmit\_handler;

app\_core\_bridge\_cmd\_receivd\_handler\_t cmdhandler;

uint32\_t wait\_rsp\_timeout\_ms;

Rev 1.2 Page70 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.085.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.057.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.035.jpeg)*Software Development User Guide*

app\_core\_bridge\_wait\_rsp\_timeout\_handle\_t

app\_core\_bridge\_wait\_rsp\_timeout\_handle;

app\_core\_bridge\_rsp\_handle\_t app\_core\_bridge\_rsp\_handle;

app\_core\_bridge\_cmd\_transmission\_done\_handler\_t

app\_core\_bridge\_transmisson\_done\_handler;

} \_\_attribute\_\_((aligned(4))) app\_core\_bridge\_task\_cmd\_instance\_t;

The instant command definition is as follows:

typedef struct

{

uint16\_t cmdcode;

app\_core\_bridge\_cmd\_transmit\_handler\_t

core\_bridge\_cmd\_transmit\_handler;

app\_core\_bridge\_cmd\_receivd\_handler\_t cmdhandler;

} \_\_attribute\_\_((aligned(4))) app\_core\_bridge\_instant\_cmd\_instance\_t;

There are two sample task command entries in “mcu\_sensor\_hub\_app.cpp”.

\- No-wait-response task command:

CORE\_BRIDGE\_TASK\_COMMAND\_TO\_ADD(MCU\_SENSOR\_HUB\_TASK\_CMD\_DEMO\_REQ\_NO\_RSP,

"demo no rsp req to sensor hub core",

app\_mcu\_sensor\_hub\_transmit\_demo\_no\_rsp\_cmd\_handler,

app\_mcu\_sensor\_hub\_demo\_no\_rsp\_cmd\_received\_handler,

0,

NULL,

NULL,

app\_mcu\_sensor\_hub\_demo\_no\_rsp\_cmd\_tx\_done\_handler);

\- Wait-response TWS custom command:

CORE\_BRIDGE\_TASK\_COMMAND\_TO\_ADD(MCU\_SENSOR\_HUB\_TASK\_CMD\_DEMO\_REQ\_WITH\_RSP,

"demo with rsp req to sensor hub core",

app\_mcu\_sensor\_hub\_transmit\_demo\_wait\_rsp\_cmd\_handler,

app\_mcu\_sensor\_hub\_demo\_wait\_rsp\_cmd\_received\_handler,

APP\_CORE\_BRIDGE\_DEFAULT\_WAIT\_RSP\_TIMEOUT\_MS,

Rev 1.2 Page71 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.086.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.057.jpeg)*Software Development User Guide*

app\_mcu\_sensor\_hub\_demo\_wait\_rsp\_cmd\_wait\_rsp\_timeout,

app\_mcu\_sensor\_hub\_demo\_wait\_rsp\_cmd\_rsp\_received\_handler,

app\_mcu\_sensor\_hub\_demo\_with\_rsp\_cmd\_tx\_done\_handler);

The implementation of the core bridge between the MCU and M55 is similar to that of the sensor hub.

The following example shows how to use the core bridge between the MCU and M55. The specific implementation is to

define the transmitting and receiving command entry on the M55 and MCU, respectively.

The MCU defines the data transmitting command in a2dp\_decoder\_cc\_bth.cpp.

RPC\_CROSS\_CORE\_TASK\_CMD\_TO\_ADD(CROSS\_CORE\_TASK\_CMD\_A2DP\_INIT\_WAITING\_RSP,

"CC\_A2DP\_INIT\_WAITING\_RSP",

a2dp\_decoder\_bth\_init\_req\_transmit\_handler,

NULL,

3000,

a2dp\_decoder\_bth\_init\_wait\_rsp\_timeout\_handler,

a2dp\_decoder\_bth\_init\_rsp\_received\_handler,

NULL);

The M55 defines the data receiving command in a2dp\_decoder\_cc\_off\_bth.cpp.

RPC\_CROSS\_CORE\_TASK\_CMD\_TO\_ADD(CROSS\_CORE\_TASK\_CMD\_A2DP\_INIT\_WAITING\_RSP,

"CC\_A2DP\_INIT\_WAITING\_RSP",

NULL,

a2dp\_decoder\_cc\_init\_req\_received\_handler,

0,

NULL,

NULL,

NULL);

1. ` `**Sensor Hub**

Sensor hub is a stand-alone M33 CPU which has peripheral resources like I2C/SPI/UART/etc for the external

components and sensors' mounting. The sensor hub gathers sensor data and process them when the main MCU is in

sleep or deep sleep mode. Considering that the sensor hub has far less hardware modules than the main MCU, by the

time the system wakes up to process sensor data, the current of the sensor hub is far smaller than main MCU. Such a

work mode can decrease the whole system power consumption compared with gathering and processing sensor data

on main MCU.

Rev 1.2 Page72 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.087.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)*Software Development User Guide*

\- How to use the sensor hub

Build a sensor hub project: make T=sensor\_hub -j8

Main project to add the macro to enable the sensor hub features: SENSOR\_HUB=1

Trace relay for the sensor hub: If the main board has only one UART output, the sensor hub's logs are forwarded to the

MCU through the core bridge to avoid the conflict between sensor hub log printing and MCU log printing. The MCU

merges the sensor hub's logs into the trace buffer and prints them out together.

Macro to enable the trace relay between two projects: SENS\_TRC\_TO\_MCU=1

The sensor hub boot-up log is shown in the following picture.

**Figure 20 Log Printing of Sensor Hub Bootup**

\- Usage of the sensor hub

The sensor hub's project folder list: tests\sensor\_hub. The main entry is in “sensor\_hub\_main.c”.

1. ` `The sensor hub is running on RTOS. You can create processing threads just like on the main MCU.
1. ` `Come to the cross core communication. A pair of cross core command handlers can be defined, one on the main

MCU, and the other one on the sensor hub. The demo can be directly taken as the reference in the section 5.2.1.

The API to dynamically power on and power off the sensor hub: The sensor hub is powered on by default for sensor

data processing.

// power off sensor hub

void app\_sensor\_hub\_deinit(void)

// power on sensor hub

void app\_sensor\_hub\_init(void)

// reset sensor hub

void app\_mcu\_reset\_sesor\_hub(void)

Note that the sensor hub can call “app\_sysfreq\_req” to change its CPU frequency.

int app\_sysfreq\_req(enum APP\_SYSFREQ\_USER\_T user, enum APP\_SYSFREQ\_FREQ\_T

freq)

{

int ret;

Rev 1.2 Page73 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.088.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

// if user is qos user

if ((1 << user) & QOS\_USERS) {

ret = app\_qosfreq\_req(user, freq);

} else { // if user is NOT qos user

ret = hal\_sysfreq\_req((enum HAL\_SYSFREQ\_USER\_T)user, (enum

HAL\_CMU\_FREQ\_T)freq);

}

return ret;

}

1. ` `**M55**

M55 is a stand-alone M55 CPU which is used for co-processing of high calculation requirement algorithms. Because of

its high performance and efficient instruction sets, M55 has lower MIPS costs and lower power consumption compared

with M33 when processing the algorithms with the same complexity. Generally, the music decoding and phone call

algorithms are running on M55.

\- How to use M55

Build a M55 project: make T=dsp\_m55 -j8

Main project to add the macro to enable M55 features: DSP\_M55=1

Trace relay for M55: If the main board has only one UART output, M55’s logs are forwarded to the MCU through the

core bridge to avoid the conflict between M55 log printing and MCU log printing. The MCU merges the M55's logs into

the trace buffer and prints them out together.

Macro to enable the trace relay between two projects: DSP\_M55\_TRC\_TO\_MCU = 1, RMT\_TRC\_IN\_MSG\_CHAN = 1

The M55 boot-up log is shown in the following picture.

**Figure 21 Log Printing of M55 Bootup**

Rev 1.2 Page74 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.089.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

\- Usage of M55

The M55's project folder list: tests\dsp\_m55. The main entry is in dsp\_m55\_main.c

1. ` `M55 is running on RTOS. You can create processing threads just like on the main MCU.
1. ` `To use cross core communication, a pair of cross core command handlers can be defined. One is on the main MCU,

and the other one is on M55. The demo can be directly taken as the reference in the section 5.2.1.

M55 defines different users in enum APP\_DSP\_M55\_USER\_E.

typedef enum {

APP\_DSP\_M55\_USER\_INIT = 0,

APP\_DSP\_M55\_USER\_A2DP = 1,

APP\_DSP\_M55\_USER\_CALL = 2,

APP\_DSP\_M55\_USER\_SMF\_RPC = 3,

APP\_DSP\_M55\_USER\_DMA\_AUDIO = 4,

APP\_DSP\_M55\_USER\_VOICE\_ASSIST = 5,

APP\_DSP\_M55\_USER\_LEA\_AUDIO = 6,

APP\_DSP\_M55\_USER\_AUDIO\_TEST = 7,

APP\_DSP\_M55\_USER\_QTY

} APP\_DSP\_M55\_USER\_E;

The API for M55 control: When multiple users are using M55, a voting mechanism is used to ensure that M55 is

powered off without any users.

// power on M55

void app\_dsp\_m55\_init(APP\_DSP\_M55\_USER\_E user);

// power off M55

void app\_dsp\_m55\_deinit(APP\_DSP\_M55\_USER\_E user);

// forced power off M55

void app\_dsp\_m55\_force\_deinit(void);

// Check whether the M55 is running

bool app\_dsp\_m55\_is\_running(void);

Note that M55 can call “app\_sysfreq\_req” in “app\_utils.c” to change its CPU frequency.

1. ` `**Co-processor**

There is an example to show how to add a custom calculation module into the co-processor.

In the function gaf\_audio\_lc3\_start\_cp\_process, cp\_accel\_open is used to execute the function \_cp\_aob\_codec\_main.

static void gaf\_audio\_lc3\_start\_cp\_process(void)

{

if (0 == gaf\_codec\_cp\_user\_cnt)

Rev 1.2 Page75 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.090.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

{

norflash\_api\_flush\_disable(NORFLASH\_API\_USER\_CP,(uint32\_t)cp\_accel\_init\_don

e);

cp\_accel\_open(CP\_TASK\_AOB\_CODEC, &TASK\_DESC\_AOB\_CODEC);

while (cp\_accel\_init\_done() == false)

{

LOG\_D("[%s] Delay...", \_\_func\_\_);

osDelay(1);

}

norflash\_api\_flush\_enable(NORFLASH\_API\_USER\_CP);

LOG\_D("[%s]", \_\_func\_\_);

}

gaf\_codec\_cp\_user\_cnt++;

}

To link the function to the logical address where CP belongs, the macro CP\_TEXT\_SRAM\_LOC is added before the

function \_cp\_aob\_codec\_main.

CP\_TEXT\_SRAM\_LOC

static unsigned int \_cp\_aob\_codec\_main(uint8\_t event)

When different operations such as encode and decode need to be performed, the function

cp\_accel\_send\_event\_mcu2cp is called to send an event to CP. Then, gaf\_audio\_lc3\_start\_cp\_process executes the

corresponding callback.

static int32\_t gaf\_codec\_audio\_decode\_over\_cp(

GAF\_CODEC\_CP\_PROCESSING\_TYPE\_E processor\_type,

uint32\_t processor\_func,

void\* lc3\_dec\_instance,

void\* scratch,

void\* input\_bytes,

int32\_t num\_bytes,

void\* output\_samples,

int32\_t bfi\_ext)

{

gaf\_codec\_wait\_for\_cp\_idle();

gaf\_codec\_cp\_processing\_info.processing\_type = processor\_type;

GAF\_CODEC\_CP\_DECODING\_INFO\_T\* pDecodingInfo =

&(gaf\_codec\_cp\_processing\_info.cp\_decoding\_info);

Rev 1.2 Page76 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.091.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

pDecodingInfo->processor\_func = processor\_func;

pDecodingInfo->lc3\_dec\_instance = lc3\_dec\_instance;

pDecodingInfo->scratch = scratch;

pDecodingInfo->input\_bytes = input\_bytes;

pDecodingInfo->num\_bytes = num\_bytes;

pDecodingInfo->output\_samples = output\_samples;

pDecodingInfo->bfi\_ext = bfi\_ext;

gaf\_codec\_cp\_state = GAF\_CODEC\_CP\_STATE\_IN\_DECODING;

cp\_accel\_send\_event\_mcu2cp(CP\_BUILD\_ID(CP\_TASK\_AOB\_CODEC,

CP\_EVENT\_AOB\_CODEC\_PROCESSING));

gaf\_codec\_wait\_for\_cp\_idle();

return gaf\_codec\_cp\_processing\_result;

}

1. ` `**Power Management**
1. ` `**Low Power Mode**

The following table describes the low power mode.

\- Low power introduction:

**Table 16 Lower Power Mode**

**Mode Entry condition Operation**

OS is idle but still stay in - No active thread In active mode

active mode - CPU wake lock users are still active

\- Low power unit is still busy

Light Sleep - System wake lock users are still active WFI

\- Active system frequency allocated and occupied

by users

\- DMA transaction is on-going

\- UART trace logging is busy

Register deep sleep hooker blocks the system

from entering deep sleep mode

System deep sleep - Chip wake lock users are still active Power down everything except:

\- PLLs occupied by PLL users

\- Set sleep deep bit of Cortex-M

system control register

Chip deep sleep - No blocking item - Power down everything

Rev 1.2 Page77 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.092.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.093.jpeg)*Software Development User Guide*

The process of entering into low power mode is shown in the following figure.

**Figure 22 Sleep and Wake-up**

“Can CPU sleep” checks whether there is an on-going sys clk switch.

“Can System sleep” checks the following items:

Ø Any CPU freq >= 24MHz occupied?

Ø Any software hook locks sleep mode?

Sample code to register a sleep hook user:

enum HAL\_SLEEP\_HOOK\_USER\_T {

… …

HAL\_SLEEP\_HOOK\_TEST, // add sleep hook user

HAL\_SLEEP\_HOOK\_USER\_QTY

};

Rev 1.2 Page78 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.094.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

int test\_sleep\_hooker\_func(void)

{

// handling pre-enter sleep mode

return -1; // return -1 to disallow entering sleep mode

or

return 0; // return 0 to allow entering sleep mode

}

void enable\_sleep\_hooker(void)

{

hal\_sleep\_set\_sleep\_hook(HAL\_SLEEP\_HOOK\_TEST,

test\_sleep\_hooker\_func);

}

void disable\_sleep\_hooker(void)

{

hal\_sleep\_set\_sleep\_hook(HAL\_SLEEP\_HOOK\_TEST, NULL);

}

Ø Any DMA running?

WFI wake-up sources:

Ø Timer: OS timer or HW timer

Ø VBUS event: Charger plug-in and plug-out

Ø GPIO Wake-up event: GPIO irq

Ø Intersys IRQ: Bt controller or sensor-hub traffic

\- Wake lock type introduction:

**Table 17 Wake Lock Types**

**Type Purpose**

CPU wake lock Prevent CPU from entering WFI

e.g.

Across audio dma data handling

Light Sleep WFI

System wake lock Prevent system from entering deep sleep mode

e.g.

Intersys bus between bt controller and main MCU

Rev 1.2 Page79 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.095.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.096.jpeg)*Software Development User Guide*

Chip wake lock Prevent chipset from enter deep sleep mode

e.g.

ANC, VAD

1. ` `**Power on**

System power on procedure:

1. ` `Main MCU flow 1: jump to ram run

**Figure 23 Jump to Ram Run**

1. ` `Main MCU flow 2: jump to the secondary bootloader in flash

Rev 1.2 Page80 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.097.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 24 Jump to Secondary Bootloader in Flash**

1. ` `Main MCU flow 3: initialize the application image

Rev 1.2 Page81 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.098.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 25 Application Image Init**

Rev 1.2 Page82 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.099.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `Sensor core flow

**Figure 26 Sensor Core Flow**

M55 and HIFI is a dynamic switch, and it does not occupy the system boot time.

There are two callbacks which can be customized. The app\_reset\_gpio\_status is used to initialize the GPIO states to

avoid the possible current leakage from the mounted external components over the GPIO. The

system\_power\_on\_callback can be customized to do anything immediately after booting.

Use the following sample code to configure GPIO\_2\_0 as a general GPIO in the 1.8v voltage domain, enable pull up.

WEAK void app\_reset\_gpio\_status(void)

{

struct HAL\_IOMUX\_PIN\_FUNCTION\_MAP test\_pin[] =

{

{

.pin = HAL\_IOMUX\_PIN\_P2\_0,

.function = HAL\_IOMUX\_FUNC\_AS\_GPIO,

.volt = HAL\_IOMUX\_PIN\_VOLTAGE\_MEM,

.pull\_sel = HAL\_IOMUX\_PIN\_PULLUP\_ENABLE,

},

};

hal\_iomux\_init(&test\_pin[0],

sizeof(test\_pin)/sizeof(HAL\_IOMUX\_PIN\_FUNCTION\_MAP));

Rev 1.2 Page83 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.100.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.101.jpeg)*Software Development User Guide*

}

Use the following code to print Hello after power-on.

WEAK void system\_power\_on\_callback(void)

{

TRACE(0,"==========Hello===========");

}

Functions decorated with WEAK can be redefined elsewhere. system\_power\_on\_callback and app\_reset\_gpio\_status

can also be redefined.

1. ` `**Power off**

In order to turn off the board, call the interface app\_shudown. The specific shutdown procedure is as follows.

1. ` `Call the interface app\_shutdown. The signal flags of the main thread are set.

int app\_shutdown(void)

TR\_INFO(TR\_MOD(MAIN), "system\_shutdown!!");

osThreadSetPriority(main\_thread\_tid, osPriorityRealtime);

osSignalSet(main\_thread\_tid, 0x4);

1. ` `After the boot, the main thread waits until any single signal flag set. Once the main thread receives the

signal flag 0x4, the value of sys\_case is set as 1.

if(evt.value.signals & 0x04)

{

sys\_case = 1;

break;

}

1. ` `The main thread calls app\_deinit.

app\_deinit(ret);

1. ` `The callback system\_power\_off\_callback can be customized to do anything before shutdown.

WEAK void system\_power\_off\_callback(uint8\_t sys\_case)

{

if (1 == sys\_case){

TRACE(0,"==========Poweroff==========");

}

else if (2 == sys\_case){

Rev 1.2 Page84 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.102.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.101.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.101.jpeg)*Software Development User Guide*

TRACE(0,"==========Reboot==========");

}

else {

TRACE(0,"==========ERRROR!!!==========");

}

}

1. ` `In the end, the power manage unit is shut down.

pmu\_shutdown();

1. ` `**Software Reset**

Software reset indicates using a series of instructions to imitate the hardware reset function. In order to reset software,

call the interface app\_reset. The specific shutdown procedure is as follows.

1. ` `Call the interface app\_shutdown. Then, the signal flags of the main thread are set.

int app\_reset (void)

osThreadSetPriority(main\_thread\_tid, osPriorityRealtime);

osSignalSet(main\_thread\_tid, 0x8);

1. ` `After the boot, the main thread waits until any single signal flag set. Once the main thread receives the

signal flag 0x8, the value of sys\_case is set as 2.

if(evt.value.signals & 0x08)

{

sys\_case = 2;

break;

}

1. ` `The main thread calls app\_deinit.

app\_deinit(ret);

1. ` `The callback system\_power\_off\_callback can be customized to do anything before software reset

WEAK void system\_power\_off\_callback(uint8\_t sys\_case)

{

if (1 == sys\_case){

TRACE(0,"==========Poweroff==========");

}

else if (2 == sys\_case){

Rev 1.2 Page85 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.103.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.101.jpeg)*Software Development User Guide*

TRACE(0,"==========Reboot==========");

}

else {

TRACE(0,"==========ERRROR!!!==========");

}

}

1. ` `In the end, the power manage unit is shut down.

pmu\_reboot ();

1. ` `**Button Action Handler**

There are two kinds of buttons, the normal button called GPIO button in the code and the power on button.

1. ` `**GPIO Button**

The GPIO button can be customized by customers for key positions, pressing actions, triggering methods and functions.

The following table describes the configuration items:

\- GPIO button

**Table 18 GPIO Button Configuration**

**Item Description Notes**

struct GPIO button struct HAL\_KEY\_GPIOKEY\_CFG\_T {

HAL\_KEY\_GPIOKEY\_CFG\_T configuration enum HAL\_KEY\_CODE\_T key\_code;

struct HAL\_IOMUX\_PIN\_FUNCTION\_MAP

key\_config;

enum HAL\_KEY\_GPIOKEY\_VAL\_T key\_down;

};

enum HAL\_KEY\_CODE\_T Key code enum HAL\_KEY\_CODE\_T {

HAL\_KEY\_CODE\_NONE = 0,

HAL\_KEY\_CODE\_PWR = (1 << 0),

HAL\_KEY\_CODE\_FN1 = (1 << 1),

HAL\_KEY\_CODE\_FN2 = (1 << 2),

HAL\_KEY\_CODE\_FN3 = (1 << 3),

HAL\_KEY\_CODE\_FN4 = (1 << 4),

HAL\_KEY\_CODE\_FN5 = (1 << 5),

HAL\_KEY\_CODE\_FN6 = (1 << 6),

HAL\_KEY\_CODE\_FN7 = (1 << 7),

HAL\_KEY\_CODE\_FN8 = (1 << 8),

HAL\_KEY\_CODE\_FN9 = (1 << 9),

Rev 1.2 Page86 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.104.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

HAL\_KEY\_CODE\_FN10 = (1 << 10),

HAL\_KEY\_CODE\_FN11 = (1 << 11),

HAL\_KEY\_CODE\_FN12 = (1 << 12),

HAL\_KEY\_CODE\_FN13 = (1 << 13),

HAL\_KEY\_CODE\_FN14 = (1 << 14),

HAL\_KEY\_CODE\_FN15 = (1 << 15),

};

enum Trigger level enum HAL\_KEY\_GPIOKEY\_VAL\_T {

HAL\_KEY\_GPIOKEY\_VAL\_T HAL\_KEY\_GPIOKEY\_VAL\_LOW = 0,

HAL\_KEY\_GPIOKEY\_VAL\_HIGH,

};

struct APP\_KEY\_STATUS Key status typedef struct APP\_KEY\_STATUS {

uint32\_t code;

uint8\_t event;

} APP\_KEY\_STATUS;

APP\_KEY\_HANDLE Key handler typedef struct {

APP\_KEY\_STATUS key\_status;

const char\* string;

APP\_KEY\_HANDLE\_CB\_T function;

void \*param;

} APP\_KEY\_HANDLE;

Use the following sample code to configure GPIO\_1\_3 as KEY1, GPIO\_1\_2 as KEY2 and GPIO\_0\_7 as KEY3, low level

trigger. The macro CFG\_HW\_GPIOKEY\_NUM is the number of GPIO buttons.

const struct HAL\_KEY\_GPIOKEY\_CFG\_T cfg\_hw\_gpio\_key\_cfg[CFG\_HW\_GPIOKEY\_NUM]

= {

#if (CFG\_HW\_GPIOKEY\_NUM > 0)

{HAL\_KEY\_CODE\_FN1,{HAL\_IOMUX\_PIN\_P1\_3, HAL\_IOMUX\_FUNC\_AS\_GPIO,

HAL\_IOMUX\_PIN\_VOLTAGE\_VIO, HAL\_IOMUX\_PIN\_PULLUP\_ENABLE}},

{HAL\_KEY\_CODE\_FN2,{HAL\_IOMUX\_PIN\_P1\_2, HAL\_IOMUX\_FUNC\_AS\_GPIO,

HAL\_IOMUX\_PIN\_VOLTAGE\_VIO, HAL\_IOMUX\_PIN\_PULLUP\_ENABLE}},

{HAL\_KEY\_CODE\_FN3,{HAL\_IOMUX\_PIN\_P0\_7, HAL\_IOMUX\_FUNC\_AS\_GPIO,

HAL\_IOMUX\_PIN\_VOLTAGE\_VIO, HAL\_IOMUX\_PIN\_PULLUP\_ENABLE}},

#endif

}

Steps to use the GPIO button:

1. ` `Configure GPIO as button in the button mapping table.

Rev 1.2 Page87 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.105.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

const struct HAL\_KEY\_GPIOKEY\_CFG\_T

cfg\_hw\_gpio\_key\_cfg[CFG\_HW\_GPIOKEY\_NUM] = {

#if (CFG\_HW\_GPIOKEY\_NUM > 0)

{HAL\_KEY\_CODE\_FN1,{HAL\_IOMUX\_PIN\_P1\_3, HAL\_IOMUX\_FUNC\_AS\_GPIO,

HAL\_IOMUX\_PIN\_VOLTAGE\_VIO, HAL\_IOMUX\_PIN\_PULLUP\_ENABLE}},

{HAL\_KEY\_CODE\_FN2,{HAL\_IOMUX\_PIN\_P1\_2, HAL\_IOMUX\_FUNC\_AS\_GPIO,

HAL\_IOMUX\_PIN\_VOLTAGE\_VIO, HAL\_IOMUX\_PIN\_PULLUP\_ENABLE}},

{HAL\_KEY\_CODE\_FN3,{HAL\_IOMUX\_PIN\_P0\_7, HAL\_IOMUX\_FUNC\_AS\_GPIO,

HAL\_IOMUX\_PIN\_VOLTAGE\_VIO, HAL\_IOMUX\_PIN\_PULLUP\_ENABLE}},

#endif

}

1. ` `Register the button handler table. For the TWS project, the table is registered in app\_key\_init by default.

void app\_key\_init(void)

{

#if defined(IBRT) && defined(IBRT\_UI\_V1)

app\_ibrt\_ui\_test\_key\_init();

#elif defined(BLE\_WALKIE\_TALKIE)

app\_walkie\_talkie\_key\_init();

#elif defined(IBRT) && defined(IBRT\_CORE\_V2\_ENABLE)

app\_tws\_ibrt\_raw\_ui\_test\_key\_init();

#else

uint8\_t i = 0;

TRACE(1,"%s",\_\_func\_\_);

app\_key\_handle\_clear();

for (i = 0; i < ARRAY\_SIZE(app\_key\_handle\_cfg); i++) {

app\_key\_handle\_registration(&app\_key\_handle\_cfg[i]);

}

#endif

}

const APP\_KEY\_HANDLE app\_ibrt\_ui\_v2\_test\_key\_cfg[] =

{

{{APP\_KEY\_CODE\_FN1,APP\_KEY\_EVENT\_CLICK},"app\_ibrt\_service\_test\_key",

app\_tws\_ibrt\_test\_key\_io\_event, NULL},

Rev 1.2 Page88 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.106.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

{{APP\_KEY\_CODE\_FN1,APP\_KEY\_EVENT\_DOUBLECLICK},"app\_ibrt\_service\_test\_ke

y", app\_tws\_ibrt\_test\_key\_io\_event, NULL},

{{APP\_KEY\_CODE\_FN2,APP\_KEY\_EVENT\_CLICK},"app\_ibrt\_service\_test\_key",

app\_tws\_ibrt\_test\_key\_io\_event, NULL},

{{APP\_KEY\_CODE\_FN2,APP\_KEY\_EVENT\_DOUBLECLICK},"app\_ibrt\_service\_test\_ke

y", app\_tws\_ibrt\_test\_key\_io\_event, NULL},

{{APP\_KEY\_CODE\_FN3,APP\_KEY\_EVENT\_CLICK},"app\_ibrt\_service\_test\_key",

app\_tws\_ibrt\_test\_key\_io\_event, NULL},

{{APP\_KEY\_CODE\_FN3,APP\_KEY\_EVENT\_DOUBLECLICK},"app\_ibrt\_service\_test\_ke

y", app\_tws\_ibrt\_test\_key\_io\_event, NULL},

};

void app\_tws\_ibrt\_raw\_ui\_test\_key\_init(void)

{

#ifdef APP\_KEY\_ENABLE

TRACE(0,"app\_tws\_ibrt\_raw\_ui\_test\_key\_init");

app\_key\_handle\_clear();

for (uint8\_t i=0; i<ARRAY\_SIZE(app\_ibrt\_ui\_v2\_test\_key\_cfg); i++)

{

app\_key\_handle\_registration(&app\_ibrt\_ui\_v2\_test\_key\_cfg[i]);

}

#endif

#ifdef IS\_ENABLE\_RSSI\_LOG\_PRINT

app\_ibrt\_rssi\_print\_timer\_id =

osTimerCreate(osTimer(IBRT\_UI\_RSSI\_PRINT\_TIMER), \

osTimerPeriodic, NULL);

osTimerStart(app\_ibrt\_rssi\_print\_timer\_id, 1000);

#endif

}

When the button is triggered, app\_tws\_ibrt\_test\_key\_io\_event handles it.

void app\_tws\_ibrt\_test\_key\_io\_event(APP\_KEY\_STATUS \*status, void \*param)

Rev 1.2 Page89 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.069.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

{

TRACE(0,"app\_tws\_ibrt\_test\_key\_io\_event");

TRACE(3, "%s 000%d,%d",\_\_func\_\_, status->code, status->event);

#if defined(IBRT\_UI\_V2)

switch(status->event)

{

case APP\_KEY\_EVENT\_CLICK:

if (status->code== APP\_KEY\_CODE\_FN1)

{

app\_ibrt\_if\_event\_entry(IBRT\_MGR\_EV\_CASE\_OPEN);

}

else if (status->code== APP\_KEY\_CODE\_FN2)

{

app\_ibrt\_if\_event\_entry(IBRT\_MGR\_EV\_UNDOCK);

}

else

{

app\_ibrt\_if\_event\_entry(IBRT\_MGR\_EV\_WEAR\_UP);

}

break;

case APP\_KEY\_EVENT\_DOUBLECLICK:

if (status->code== APP\_KEY\_CODE\_FN1)

{

app\_ibrt\_if\_event\_entry(IBRT\_MGR\_EV\_CASE\_CLOSE);

}

else if (status->code== APP\_KEY\_CODE\_FN2)

{

app\_ibrt\_if\_event\_entry(IBRT\_MGR\_EV\_DOCK);

}

else

{

app\_ibrt\_if\_event\_entry(IBRT\_MGR\_EV\_WEAR\_DOWN);

}

break;

case APP\_KEY\_EVENT\_LONGPRESS:

if (status->code== APP\_KEY\_CODE\_FN1)

{

Rev 1.2 Page90 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.107.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

}

else if (status->code== APP\_KEY\_CODE\_FN2)

{

}

else

{

}

break;

case APP\_KEY\_EVENT\_TRIPLECLICK:

break;

case HAL\_KEY\_EVENT\_LONGLONGPRESS:

break;

case APP\_KEY\_EVENT\_ULTRACLICK:

break;

case APP\_KEY\_EVENT\_RAMPAGECLICK:

break;

}

#endif

}

You can also customize the button event handler. The handler function can be registered by using the following code.

app\_key\_handle\_clear();

for (i = 0; i < ARRAY\_SIZE(app\_key\_handle\_cfg); i++) {

app\_key\_handle\_registration(&app\_key\_handle\_cfg[i]);

}

1. ` `**Power on Button**

The usage is the same as GPIO button except that it doesn't need to be added into the button mapping table in

tgt\_hardware.c. The configuration methods can be found in 10.1

The power on button handling table registration is as follows.

Rev 1.2 Page91 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.108.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

{{APP\_KEY\_CODE\_PWR,APP\_KEY\_EVENT\_CLICK},"app\_ibrt\_ui\_test\_key",

app\_ibrt\_raw\_ui\_test\_key, NULL},

1. ` `**Nor-Flash API**
1. ` `**Flash Program/Erase**

The Nor-Flash can store data and instructions. Before you use it, register flash module with the interface

app\_flash\_register\_module.

**Table 19 Flash Module ID**

**Item Description Notes**

enum Flash module ID enumNORFLASH\_API\_MODULE\_ID\_T

NORFLASH\_API\_MODULE\_ID\_T {

NORFLASH\_API\_MODULE\_ID\_LOG\_DUMP,

NORFLASH\_API\_MODULE\_ID\_USERDATA,

NORFLASH\_API\_MODULE\_ID\_BOOTUP\_INFO,

NORFLASH\_API\_MODULE\_ID\_OTA,

NORFLASH\_API\_MODULE\_ID\_UPGRADE\_LOG,

#if defined(\_AUTO\_TEST\_)

NORFLASH\_API\_MODULE\_ID\_CUSTOM\_PARAMETER,

NORFLASH\_API\_MODULE\_ID\_FREE,

NORFLASH\_API\_MODULE\_ID\_RESERVED,

NORFLASH\_API\_MODULE\_ID\_AUD,

#endif

NORFLASH\_API\_MODULE\_ID\_CRASH\_DUMP,

NORFLASH\_API\_MODULE\_ID\_COREDUMP,

NORFLASH\_API\_MODULE\_ID\_RAMDUMP,

NORFLASH\_API\_MODULE\_ID\_FACTORY,

NORFLASH\_API\_MODULE\_ID\_HOTWORD\_MODEL,

NORFLASH\_API\_MODULE\_ID\_INTERACTION\_OTA,

NORFLASH\_API\_MODULE\_ID\_GMA\_OTA,

NORFLASH\_API\_MODULE\_ID\_AUDIO,

NORFLASH\_API\_MODULE\_ID\_TEST1,

NORFLASH\_API\_MODULE\_ID\_TEST2,

NORFLASH\_API\_MODULE\_ID\_COUNT,

};

enum Nor flash enum NORFLASH\_API\_OPRATION\_TYPE

NORFLASH\_API\_OPRATI operation type. {

ON\_TYPE NORFLASH\_API\_WRITTING = 0x01,

Rev 1.2 Page92 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.109.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.110.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

NORFLASH\_API\_ERASING = 0x02,

NORFLASH\_API\_ALL = 0x03

};

The parameter module is flash module ID, dev\_id can be gotten with the interface app\_flash\_get\_dev\_id\_by\_addr

usually, baseAddr is the base address of the module, len is the length of the module, and imageHandler is a callback

function which is called when the flash is flushed.

void app\_flash\_register\_module(uint8\_t module,

enum HAL\_FLASH\_ID\_T dev\_id,

uint32\_t baseAddr,

uint32\_t len,

uint32\_t imageHandler);

app\_flash\_register\_module((uint8\_t)NORFLASH\_API\_MODULE\_ID\_OTA,

app\_flash\_get\_dev\_id\_by\_addr(OTA\_FLASH\_LOGIC\_ADDR +

NEW\_IMAGE\_FLASH\_OFFSET),

OTA\_FLASH\_LOGIC\_ADDR + NEW\_IMAGE\_FLASH\_OFFSET,

hal\_norflash\_get\_flash\_total\_size(HAL\_FLASH\_ID\_0) -

NEW\_IMAGE\_FLASH\_OFFSET - 2\*4096,

0);

This interface is flush pending flash operation. The parameter module is flash module ID, type is lash operation refer to

enum NORFLASH\_API\_OPRATION\_TYPE for more information.

Flash operation is usually pended in order to minimize the physical flash operation, so sometimes, the flash is not

changed after you call a flash operation. This function will force the flash controller to execute pended operation.

void app\_flash\_flush\_pending\_op(enum NORFLASH\_API\_MODULE\_ID\_T module,

enum NORFLASH\_API\_OPRATION\_TYPE type);

app\_flash\_flush\_pending\_op(mod, NORFLASH\_API\_ALL);

This interface checks it whether the flash is clean or not. The parameter is flash start address, flashOffset is length of

checking. If the flash is clean, it will return true, otherwise return false.

bool app\_flash\_is\_clean(uint32\_t addr, uint32\_t len);

This interface erases the whole sector (4K bytes) according to the incoming flash offset. The parameter module is flash

module, flashOffset is offset according to the flash module base address.

void app\_flash\_sector\_erase(enum NORFLASH\_API\_MODULE\_ID\_T module, uint32\_t

flashOffset);

Rev 1.2 Page93 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.111.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

app\_flash\_sector\_erase(mod, flashOffset);

This interface erases all blocks (32k bytes or 64k bytes) and sectors in the specified range according to the incoming

flash offset and length. The parameter module is flash module, flashOffset is offset according to the flash module base

address, len is erase length.

void app\_flash\_erase(enum NORFLASH\_API\_MODULE\_ID\_T module, uint32\_t

flashOffset, uint32\_t len);

This interface writes data to flash according to incoming flash module and offset. The parameter module is flash

module, flashOffset is offset according to the flash module base address, ptr is pointer of data to write, len is length of

data to be written, syncWrite is sync or async flag of write operation. If syncWrite is true, flash driver will flush the

incoming data to flash; if syncWrite is false, the data you write probably will not present in flash immediately, if you

read the flash now, you may get unexpected result. So if you want read flash right after write opeation, you should

either write flash in sync way (syncWrite is ture) or flush the pending flash operation (call app\_flash\_flush\_pending\_op)

after write.

void app\_flash\_program(enum NORFLASH\_API\_MODULE\_ID\_T module,

uint32\_t flashOffset,

uint8\_t \*ptr,

uint32\_t len,

bool synWrite);

app\_flash\_program(mod,

offsetInFlashToProgram,

ptrSource,

preBytes,

false);

This interface reads flash according to incoming flash module and offset. The parameter module flash module,

flashOffset is offset according to the flash module base address, ptr is pointer of data to read, len is length of data to

read.

void app\_flash\_read(enum NORFLASH\_API\_MODULE\_ID\_T module,

uint32\_t flashOffset,

uint8\_t \*ptr,

uint32\_t len);

app\_flash\_read(mod,

flashOffset,

ota\_control\_env.dataBufferForBurning,

Rev 1.2 Page94 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.112.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

FLASH\_SECTOR\_SIZE\_IN\_BYTES);

This interface reads flash according to incoming flash module and offset.

The parameter module flash module, flashOffset is offset according to the

flash module base address, ptr is pointer of data to read, len is length of

data to read.

void app\_flash\_sync\_read(enum NORFLASH\_API\_MODULE\_ID\_T module,

uint32\_t flashOffset,

uint8\_t \*ptr,

uint32\_t len);

This interface gets flash id by flash module addr, the parameter addr is flash module address. Usually it is used when

register module.

enum HAL\_FLASH\_ID\_T app\_flash\_get\_dev\_id\_by\_addr(uint32\_t addr);

All interrupts need to be suspended during flash programing/erasing. Our products support synchronous

programing/erasing by default.

1. ` `**Async Flash Erasing/Programing**

The async flash erase/program operation makes use of Nor-flash suspend/resume commands to allow the timing

restricted threads to be scheduled if its corresponding IRQ happens during erasing/programing.

After call application flash erase/program API, if the operation queue is not full, flash erase/program into operation

queue, when OS enters idle state, it will fetch operation from the queue, if the operation was suspended, OS will

resume it, then excute the operation. At this time if spicific IRQ happens, the operation will be suspended until the end

of IRQ handler. If the operation queue is full and it is not cleared, OS will excute operation and then push

erase/program into operation queue. At the same time, f spicific IRQ happens, the operation will be suspended and

delay 10ms to continue.

Following is an example of async flash erase/program.

app\_flash\_sector\_erase(mod, sectorIndexInFlash \*

FLASH\_SECTOR\_SIZE\_IN\_BYTES);

app\_flash\_program(mod,

sectorIndexInFlash \* FLASH\_SECTOR\_SIZE\_IN\_BYTES,

ptrSource + sector \* FLASH\_SECTOR\_SIZE\_IN\_BYTES,

FLASH\_SECTOR\_SIZE\_IN\_BYTES,

false);

app\_flash\_flush\_pending\_op(mod, NORFLASH\_API\_ALL);

Rev 1.2 Page95 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.113.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 27 Async Flash Erasing/Programing**

1. ` `**Sync Flash Erasing/Programing**

The sync flash erase/program operation disables global IRQ and keeps waiting until the operation is completed. So if

the operation costs longer time than a codec DMA interval, the codec DMA chain will miss one chunk’s feeding and

audio glitches may occur.

Following is an example of sync flash erase/program.

app\_flash\_sector\_erase(mod, flashOffset);

app\_flash\_program(mod,

flashoffset,

ota\_control\_env.dataBufferForBurning,

FLASH\_SECTOR\_SIZE\_IN\_BYTES,

true);

Rev 1.2 Page96 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.114.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 28 Sync Flash Erasing/Programing**

1. ` `**Sync Flash Erasing/Programing Influence on DMA chain**

Long time global IRQ disabling from sync flash erasing may cause that the audio thread misses filling PCM data into

DMA buffer.

As the figure shows, if sync erase interface is called when audio thread fill PCM data into DMA Ping Buffer, global IRQ

will be disabled, Ping Buffr Done DMA IRQ can not be triggered, thus audio thread cannot play PING buffer.

Rev 1.2 Page97 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.115.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 29 Sync Flash Erasing/Programing Influence on DMA Chain**

1. ` `**Factory Section**

The factory section is used to store data that never changes during the lifetime.

1. **Location**

For the location of the factory section, refer to 5.2 Flash memory map. The details can be found in the map. Search

\_\_factory\_start in the map for the start address of the factory section and \_\_factory\_end for the end. For example, here

is the location of best1600\_ibrt.

.factory 0x00000000307ff000 0x1000

0x00000000307ff000 \_\_factory\_start = .

0x0000000000001000 . = 0x1000

\*fill\* 0x00000000307ff000 0x1000

0x0000000030800000 \_\_factory\_end = .

1. **Usage**

The information about data storage in the factory section is shown in the follow table.

Rev 1.2 Page98 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.116.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Table 20 Factory Section Information**

**Item Description Notes**

factory\_section\_t Factory section typedef struct {

section\_head\_t head;

factory\_section\_data\_t data;

}factory\_section\_t;

factory\_section\_data\_t Data stored in typedef struct {

the factory unsigned char device\_name[248+1]

section ALIGN4;

unsigned char bt\_address[8] ALIGN4;

unsigned char ble\_address[8]

ALIGN4;

` `// connector addr of the dldtool isthe default peer bt address unsigned char

default\_peer\_bt\_address[8] ALIGN4; unsigned int xtal\_fcap ALIGN4; unsigned int rev1\_data\_len; unsigned int rev2\_data\_len; unsigned int rev2\_crc;

` `unsigned int rev2\_reserved0; unsigned int rev2\_reserved1; unsigned int rev2\_bt\_name[63]; unsigned int rev2\_bt\_addr[2]; unsigned int rev2\_ble\_addr[2]; // connector addr of the dldtool isthe default peer bt address unsigned char

rev2\_default\_peer\_bt\_address[6]; unsigned char rev2\_u8\_reserved0; unsigned char

rev2\_default\_bt\_nv\_role;

` `unsigned int rev2\_xtal\_fcap; unsigned int rev2\_ble\_name[8];}factory\_section\_data\_t;

The clock required for flash storage is provided by a 24MHz external crystal oscillator which can be accurately trimmed.

Here are several application programing interfaces:

Rev 1.2 Page99 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.117.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

Get the original address of Bluetooth stored in the factory section.

void factory\_section\_original\_btaddr\_get(uint8\_t \*btAddr);

Set the name of Bluetooth.

int factory\_section\_set\_bt\_name(const char \*name,int len);

Get the frequency of the external crystal oscillator.

int factory\_section\_xtal\_fcap\_get(unsigned int \*xtal\_fcap);

Set the frequency of the external crystal oscillator.

int factory\_section\_xtal\_fcap\_set(unsigned int xtal\_fcap);

Get the address of Bluetooth stored in the factory section.

uint8\_t\* factory\_section\_get\_bt\_address(void);

Get the address of Bluetooth Low Energy stored in the factory section.

uint8\_t\* factory\_section\_get\_ble\_address(void);

Set the address of Bluetooth.

int factory\_section\_set\_bt\_address(uint8\_t\* btAddr);

Set the address of Bluetooth Low Energy.

int factory\_section\_set\_ble\_address(uint8\_t \* bleAddr);

Get the name of Bluetooth.

uint8\_t\* factory\_section\_get\_bt\_name(void);

Get the name of Bluetooth Low Energy.

uint8\_t\* factory\_section\_get\_ble\_name(void);

Get current version.

uint32\_t factory\_section\_get\_version(void);

Get the address of the default peer.

uint8\_t\* factory\_section\_get\_default\_peer\_bt\_address(void);

Get the default Bluetooth non-volatile memory role.

Rev 1.2 Page100 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.118.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.119.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.120.jpeg)*Software Development User Guide*

uint8\_t factory\_section\_get\_default\_bt\_nv\_role(void);

1. ` `**User Section**

The user section is used to store data that does not change during use.

1. ` `**Location**

For the location of the user section, refer to 5.2 Flash memory map. The details can be found in the map. Search

\_\_userdata\_start in the map for the start address of the user section and \_\_userdata\_end for the end. For example,

here is the location of best1600\_ibrt.

.userdata 0x00000000307fc000 0x2000

0x00000000307fc000 \_\_userdata\_start = .

0x0000000000002000 . = 0x2000

\*fill\* 0x00000000307fc000 0x2000

0x00000000307fe000 \_\_userdata\_end = .

1. ` `**Usage**

Use the following interface to get extension entries.

NV\_EXTENSION\_RECORD\_T \*nv\_record\_get\_extension\_entry\_ptr(void);

In order to update the user data section, call the interface nv\_record\_btdevicevolume\_set\_hfp\_vol.

void nv\_record\_btdevicevolume\_set\_hfp\_vol(btdevice\_volume\* device\_vol,

int8\_t vol)

{

uint32\_t lock = nv\_record\_pre\_write\_operation();

if (vol != device\_vol->hfp\_vol)

{

nv\_record\_update\_runtime\_userdata();

device\_vol->hfp\_vol = vol;

}

nv\_record\_post\_write\_operation(lock);

}

The times of flash programing/erasing are limited, data in the flash memory is flushed only when dirty data is available.

The dirty user data section may be flushed into the flash in the following cases:

1. ` `Normal shut-down
1. ` `Normal reset
1. ` `Crash and reboot
1. ` `Initiative sync flushing

Rev 1.2 Page101 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.121.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

void nv\_record\_flash\_flush(void);

1. ` `Initiative async flushing

void nv\_record\_execute\_async\_flush(void);

1. ` `Periodical self-check and flushing when the OS is in the idle state

#define NV\_RECORD\_FLUSH\_EXECUTION\_INTERVAL\_MS (20\*60\*1000)

1. ` `**Custom Parameter Section**

This section provides an interface to save and acquire the parameters unique by device and non-volatile across the

product’s lifetime.

**Location of custom parameters**

The location is fixed in the flash, ahead of the user data sector.

**Figure 30 Location of Parameter Sector**

**Data format of custom parameters**

**Table 21 Data Format of Custom Parameters**

Magic Version Total Parameter Parameter entry 0 - (count-1)

number number length entries count

Parameter Parameter length Parameter content

index

4 bytes 2 bytes 2 bytes 2 bytes 2 bytes 2 bytes Depends on

parameter length

Define parameters in the file with the .csv suffix. Here is an example:

Magic number,"0x42,0x45,0x53,0x54",

Version,1,

SN,0,"0x00, 0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,x00a,0x0b,0x0c,0x0d,0x0e,0x0f"

Rev 1.2 Page102 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.122.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

**Table 22 Example of Custom Parameters**

Magic number Value, small endian. E.g. “0x42,0x45,0x53,0x54” means that value of the

parameter is: parameter[0]=0x42,

parameter[1]=0x45,parameter[2]=0x53,parameter[3]=0x54

Version Value

Name of the parameter entry Index of the parameter entry Value of the parameter, small

endian. E.g. “0x12, 0x34” means

that value of the parameter is:

parameter[0]=0x12,

parameter[1]=0x34

Steps to download the product serial number:

1. ` `Fill the custom parameter into custom\_parameters.csv
1. ` `Generate the custom parameter binary file via ~$ python .\custom\_parameters\_bin\_convertor.py

custom\_parameters.csv

1. ` `Program the generated binary file into the fixed flash offset (FLASH\_SIZE-0x3000-AUD\_SECTION\_SIZE).

Note that the dldtool since rev 1.2.1 can support this feature. The "ChipVersion" needs to be chosen as

"1000" for 2000 series, while "2000" for 2000i series.

1. ` `Define the custom parameters in customparam\_section.c/h

In the firmware, call nv\_custom\_parameter\_section\_get\_entry to get the parameter content.

1. ` `**PMU Watchdog**

The watchdog is a timer circuit. The watchdog counter starts to count automatically when the system is running. If the

watchdog is not cleared after the specified time, the watchdog counter will overflow, which causes the watchdog to

interrupt and the system to reset.

The watchdog can make the MCU system work non-stop even in an unguarded state, preventing the program from

running away or falling into an infinite loop. The PMU watchdog can also protect the power and data.

In order to open a PMU watchdog, call the interface app\_wdt\_open. Note that the time set by app\_wdt\_open is 2.2

times the incoming parameter.

int app\_wdt\_open(int seconds)

After opening the watchdog, it needs to be cleared before the watchdog counter reaches the maximum value. The

interface watchdog\_ping is used to feed the watchdog.

void watchdog\_ping(void)

Since the watchdog handler is handled by the SDK, the application code does not need to call watchdog\_ping unless

otherwise required.

Rev 1.2 Page103 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.123.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.057.jpeg)*Software Development User Guide*

1. ` `**TWS Synchronization Operation API**

The synchronization operation is required between the left and right of TWS devices. The code for TWS synchronization

is as follows.

**Table 23 TWS Synchronization Operation Code**

**Item Description Notes**

typedef enum Bluetooth typedef enum

APP\_BT\_SYNC\_OP\_CODE\_E synchronous {

operation APP\_BT\_SYNC\_OP\_RETRIGGER =

code 0x00000000,

APP\_BT\_SYNC\_OP\_VOLUME =

0x00000001,

APP\_BT\_SYNC\_OP\_VOLUME\_OFFSET =

0x00000002,

} APP\_BT\_SYNC\_OP\_CODE\_E;

This macro addes commands to a table. opCode is the TWS synchronization operation code, cmdhandler is the

command handler, and statusNotify is the synchronization status notification

#define APP\_BT\_SYNC\_COMMAND\_TO\_ADD(opCode, cmdhandler, statusNotify)

\

static const app\_bt\_sync\_instance\_t syncOp##opCode##\_entry

\

\_\_attribute\_\_((used, section(".app\_bt\_sync\_command\_handler\_table"))) =

\

{(opCode), (cmdhandler), (statusNotify)};

Use the following function to enable the triggering feature of both buds. opCode is the pointer to the expected callback

handler, length is the length of information shared between TWS devices, and p\_buff is the pointer to the shared

information.

bool app\_bt\_sync\_enable(uint32\_t opCode, uint8\_t length, uint8\_t \*p\_buff)

Here is an example of registering a synchronization volume state handler and enabling it.

APP\_BT\_SYNC\_COMMAND\_TO\_ADD(APP\_BT\_SYNC\_OP\_VOLUME,

aob\_tws\_sync\_volume\_status\_handler, NULL);

if (!app\_bt\_sync\_enable(APP\_BT\_SYNC\_OP\_VOLUME,

sizeof(app\_gaf\_arc\_vcs\_volume\_ind\_t), (uint8\_t\*)&p\_volume\_ind)){

aob\_tws\_sync\_volume\_status\_handler();

Rev 1.2 Page104 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.124.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

}

1. ` `**Dynamic Heap Usage**

When the size of the heap is found to be too small, it can be dynamically adjusted.

The heap information is as follows:

**Table 24 Heap Information**

**Item Description Notes**

typedef struct Metadata typedef struct multi\_heap\_info {

multi\_heap\_info header for the void \*lock;

heap, stored size\_t total\_bytes;

at the size\_t free\_bytes;

beginning of size\_t minimum\_free\_bytes;

the heap heap\_block\_t \*last\_block;

space heap\_block\_t first\_block; /\* initial

'free block', never allocated \*/

#if defined(MULTI\_HEAP\_DEFAULT\_INT\_LOCK)

size\_t int\_lock;

#endif

};

The following interfaces can be called to dynamically resize the heap:

1. ` `This function initializes a heap at the specified address, and returns a handle for future heap operations.

The parameter start is the start address of the memory to use for a new heap, and the parameter size is

the size (in bytes) of the new heap. The return value is the handle of a new heap ready for use, or NULL if

the heap region is too small to be initialized.

typedef struct multi\_heap\_info \*multi\_heap\_handle\_t;

multi\_heap\_handle\_t heap\_register(void \*start, size\_t size);

1. ` `This function allocates a buffer in a given heap. Its semantics are the same as standard malloc(), and the

returned buffer is allocated in the specified heap. The parameter heap is a handle to a registered heap,

and the parameter size is the size of the desired buffer.

bool heap\_malloc (multi\_heap\_handle\_t heap, size\_t size);

1. ` `This function frees a buffer in a given heap. Semantics are the same as standard free(), but the argument

'p' must be NULL or have been allocated in the specified heap. The parameter heap is the handle to a

registered heap.

void heap\_free(multi\_heap\_handle\_t heap, void \*p);

Rev 1.2 Page105 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.125.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

1. ` `This function checks if it is available to allocate a buffer in a given head. The parameter heap is a handle

to a registered heap, and the parameter size is the size of the desired buffer.

bool heap\_check\_size\_malloc\_available(multi\_heap\_handle\_t heap, size\_t

size);

1. ` `This function returns the size that a particular pointer is allocated with. The parameter heap is a handle

to a registered heap. The parameter p is a pointer, and it must have been previously returned from

heap\_malloc or hrap\_relloc for the same heap. The return value is the size of the memory allocated at

this block.

size\_t heap\_get\_allocated\_size(multi\_heap\_handle\_t heap, void \*p);

1. ` `**Retention Information Management**

There are two ways to retain certain information during the reboot, retention bits and retention ram.

1. ` `**Retention Bits**

There are 32 bits that can be set before reboot. The mode can be found in platform\hal\hal\_bootmode.h.

In order to set a bit before reboot, call the interface hal\_sw\_bootmode\_set. Use the following code to set boot mode as

HAL\_SW\_BOOTMODE\_REBOOT and HAL\_SW\_BOOTMODE\_REBOOT\_FROM\_CRASH after the crash.

#ifdef CRASH\_REBOOT

hal\_sw\_bootmode\_set(HAL\_SW\_BOOTMODE\_REBOOT|HAL\_SW\_BOOTMODE\_REBOOT\_FROM\_CRAS

H);

After rebooting, call the interface hal\_sw\_bootmode\_get get the bit that has been set.

if (hal\_sw\_bootmode\_get() & HAL\_SW\_BOOTMODE\_REBOOT\_FROM\_CRASH){

hal\_sw\_bootmode\_clear(HAL\_SW\_BOOTMODE\_REBOOT\_FROM\_CRASH);

TRACE(0,"Crash happened!!!");

#ifdef VOICE\_DATAPATH

gsound\_dump\_set\_flag(true);

#endif

}

1. ` `**Retention Ram Usage**

In order to remain certain information in ram, a section can be defined in the link script.

.reboot\_param (NOLOAD) :

{

KEEP(\*(.reboot\_param))

Rev 1.2 Page106 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.126.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.057.jpeg)*Software Development User Guide*

. = REBOOT\_PARAM\_SECTION\_SIZE;

. = ALIGN(4);

#if defined(ASIC\_SIMU)

. = ALIGN(1024\*4);

#endif

} > RAM

Then use attribute to modify the information you want to keep during rebooting in the code.

typedef struct

{

uint32\_t magicCode;

uint8\_t bleBdAddr[BLE\_BD\_ADDR\_LEN];

} BLE\_BD\_ADDR\_FOR\_OTA\_T;

BLE\_BD\_ADDR\_FOR\_OTA\_T \_\_attribute((section(".reboot\_param")))

bleBdAddrForOta;

If the size of this section is not enough, modify the value of REBOOT\_PARAM\_SECTION\_SIZE or redefine a paragraph.

The method of defining a section can be found in 5.5.

1. ` `**RTOS**
1. ` `**Multi-task**

In CMSIS-RTOS2, the basic unit of execution is a "Thread". Once started, an RTOS thread must contain a loop so that it

never terminates, i.e. it runs forever. With the Arm Compiler, it is possible to optimize a thread by using a

\_\_NO\_RETURN macro. This attribute reduces the cost of calling a function that never returns.

An RTOS program is made up of a number of threads, which are controlled by the RTOS scheduler. This scheduler uses

the SysTick timer to generate a periodic interrupt as a time base. The scheduler does not allot a certain amount of

execution time to each thread. So thread1 runs for one system tick period and then be re-scheduled to allow thread2 to

run for a similar period; thread2 gives way to thread3 and finally controls passes back to thread1. By allocating these

slices of runtime to each thread in a round-robin fashion, you can get the appearance of all three threads running in

parallel to each other.

Conceptually, you can think of each thread as performing a specific functional unit of our program with all threads

running simultaneously. When a thread is created, it is also allocated with its own thread ID. This is a variable which

acts as a handle for each thread and is used when you want to manage the activity of the thread.

1. ` `**Task Scheduler**

RTX5 implements a low-latency preemptive scheduler. Major parts of RTX5 are executed in handler mode:

SysTick\_Handler used for time-based scheduling.

Rev 1.2 Page107 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.127.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

SVC\_Handler used for lock-based scheduling.

PendSV\_Handler used for interrupt-based scheduling.

In order to be low-latency with respect to ISR execution those system exceptions are configured to use the lowest

priority groups available. The priorities are configured so that no preemption happens between them. Thus no interrupt

critical sections (i.e. interrupt locks) are needed to protect the scheduler.

**Figure 31 Thread Scheduling and Interrupt Execution**

The scheduler combines priority and round-robin based context switches. The example depicted in the preceding figure

contains four threads (1, 2, 3, and 4). Threads 1 and 2 share the same priority, thread 3 has a higher one and thread 4

the highest (osThreadAttr\_t::priority). As long as threads 3 and 4 are blocked, the scheduler switches between thread 1

and 2 on a time-slice basis (round-robin).

Thread 2 unblocks thread 3 by an arbitrary RTOS-call (executed in SVC handler mode) at time index 2. The scheduler

switches to thread 3 immediately because thread 3 has the highest priority. Thread 4 is still blocked.

At time index 4, an interrupt (ISR) occurs and preempts the SysTick\_Handler. RTX does not add any latency to the

interrupt service execution. The ISR routine uses an RTOS-call that unblocks thread 4. Instead of switching to thread 4

immediately, the PendSV flag is set to defer the context switching. The PendSV\_Handler is executed right after the

SysTick\_Handler returns and the deferred context switch to thread 4 is carried out. As soon as highest priority thread 4

blocks again by using a blocking RTOS-call, the execution is switched back to thread 3 immediately during time index 5.

At time index 5, thread 3 uses a blocking RTOS-call as well. Thus the scheduler switches back to thread 2 at time index

1. ` `At time index 7, the scheduler uses the round-robin mechanism to switch to thread 1.

Rev 1.2 Page108 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.128.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**OS Abstract Layer**

OS Abstract Layer is a generic API that is agnostic of the underlying RTOS kernel. Application programmers call CMSIS-

RTOS2 API functions in the user code to ensure maximum portability from one RTOS to another. Middleware using OS

Abstract Layer takes advantages of this approach by avoiding unnecessary porting efforts.

For the application layer, you can call “osThreadCreate” to create a thread's external interface, but the implementation

of this function is different for different OS (FreeRTOS, Nuttx, RTX5, etc.). In this way, the application layer code does

not need to be changed when porting between different OS.

In “cmsis\_os1.c”

osThreadId osThreadCreate (const osThreadDef\_t \*thread\_def, void \*argument)

{

if (thread\_def == NULL) {

return (osThreadId)NULL;

}

return osThreadNew((osThreadFunc\_t)thread\_def->pthread, argument,

&thread\_def->attr);

}

In “nuttx\_os.c”

osThreadId osThreadCreate (osThreadDef\_t \*thread\_def, void \*argument)

{

swarn("thread name:%s\n",thread\_def->name);

pthread\_attr\_t attr = {0};

thread\_def->mutex = (pthread\_mutex\_t \*)malloc(sizeof(pthread\_mutex\_t));

thread\_def->cond = (pthread\_cond\_t \*)malloc(sizeof(pthread\_cond\_t));

pthread\_mutex\_init(thread\_def->mutex, NULL);

pthread\_cond\_init(thread\_def->cond,NULL);

pthread\_attr\_init(&attr);

thread\_def->argument = argument;

attr.priority = thread\_def->priority;

attr.stacksize = thread\_def->stacksize;

#ifndef CHIP\_A7\_DSP

#if USE\_PTHREAD\_PORTING

int ret =

pthread\_create(&thread\_def->thread,&attr,pthread\_proxy,thread\_def);

swarn("thread name:%s, thread=%d,ret=%d,

stackaddr:%x\n",thread\_def->name,thread\_def->thread,ret,attr.stackaddr);

Rev 1.2 Page109 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.129.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.057.jpeg)*Software Development User Guide*

if (ret != OK)

serr("ret=%d,errno=%d ERROR PLEASE CHECK!!!!!\n",ret,errno);

#else

int ret;

void \*argv[3];

char arg1[16];

snprintf(arg1, 16, "0x%" PRIxPTR, (uintptr\_t)thread\_def);

argv[0] = "";

argv[1] = arg1;

argv[2] = NULL;

/\* Create the task \*/

ret = kthread\_create\_with\_stack(thread\_def->name, thread\_def->priority,

attr.stackaddr, attr.stacksize, main\_proxy, (char \*const\*)argv);

if (ret < OK)

{

serr("ret=%d,errno=%d ERROR PLEASE CHECK!!!!!\n",ret,errno);

return NULL;

}

thread\_def->thread = ret;

#endif

return (osThreadId)thread\_def;

}

1. ` `**Create a Task**

As we can see in the first example, the “app\_main()” thread is used as a launcher thread to create the application

threads. This is done in two stages. First, a thread structure is defined. The thread structure allows us to define the

thread operating parameters.

typedef struct {

const char \*name; ///< name of the thread

uint32\_t attr\_bits; ///< attribute bits

void \*cb\_mem; ///< memory for control block

uint32\_t cb\_size; ///< size of provided memory for

control block

Rev 1.2 Page110 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.130.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.035.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)*Software Development User Guide*

void \*stack\_mem; ///< memory for stack

uint32\_t stack\_size; ///< size of stack

osPriority\_t priority; ///< initial thread priority (default:

osPriorityNormal)

TZ\_ModuleId\_t tz\_module; ///< TrustZone module identifier

uint32\_t reserved; ///< reserved (must be 0)

} osThreadAttr\_t;

The thread structure requires us to define the name of the thread function, its thread priority, any special attribute bits,

its TrustZone\_ID and its memory allocation. Once the thread structure is defined, the thread can be created by calling

the osThreadNew() API. Then the thread is created from within the application code.

#if !defined(os1\_Disable\_Thread)

osThreadId osThreadCreate (const osThreadDef\_t \*thread\_def, void \*argument)

{

if (thread\_def == NULL) {

return NULL;

}

return osThreadNew((osThreadFunc\_t)thread\_def->pthread, argument,

&thread\_def->attr);

}

#endif

**Sample Code 7: OS\_Thread Creation**

{"os\_thread\_create\_demo", os\_thread\_create\_demo\_test},

[TEST,os\_thread\_create\_demo]

1. ` `**OS Event**

Event flags operate in a similar fashion to thread flags but must be created and then act as a global RTOS object that

can be used by all the running threads.

First, create a set of event flags. This is a similar process to creating a thread. You can define an event flag attribute

structure. The attribute structure specifies an ASCII name string, attribute bits, and memory detention if we are using

the static memory model.

typedef struct {

const char \*name; ///< name of the event flags

uint32\_t attr\_bits; ///< attribute bits

void \*cb\_mem; ///< memory for control block

Rev 1.2 Page111 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.131.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

uint32\_t cb\_size; ///< size of provided memory for

control block

} osEventFlagsAttr\_t;

Next, a handle to control access of the event flags shall be created. Then we can create the event flag object:

osEventFlagsId\_t osEventFlagsNew (const osEventFlagsAttr\_t \*attr) {

EventGroupHandle\_t hEventGroup;

int32\_t mem;

hEventGroup = NULL;

if (!IS\_IRQ()) {

mem = -1;

if (attr != NULL) {

if ((attr->cb\_mem != NULL) && (attr->cb\_size >=

sizeof(StaticEventGroup\_t))) {

mem = 1;

}

else {

if ((attr->cb\_mem == NULL) && (attr->cb\_size == 0U)) {

mem = 0;

}

}

}

else {

mem = 0;

}

if (mem == 1) {

hEventGroup = xEventGroupCreateStatic (attr->cb\_mem);

}

else {

if (mem == 0) {

hEventGroup = xEventGroupCreate();

}

}

}

Rev 1.2 Page112 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.132.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

return ((osEventFlagsId\_t)hEventGroup);

}

**Figure 32 Simple Event Communication**

Here is a simple example to show how two threads can communicate with each other using event flags.

**Sample Code 8 : OS Event**

{"os\_event\_demo", os\_event\_demo\_test},

[TEST, os\_event\_demo]

1. ` `**OS Mailbox**

To create a zero copy mail box system, you can combine a memory pool to store the data with a message queue which

is used to transfer a pointer of the allocated memory pool slot. This way, the message data stays static and a pointer is

passed between threads.

typedef struct os\_mailQ\_def {

uint32\_t queue\_sz; ///< number of elements in the queue

uint32\_t item\_sz; ///< size of an item

void \*mail; ///< pointer to mail

osMemoryPoolAttr\_t mp\_attr; ///< memory pool attributes

osMessageQueueAttr\_t mq\_attr; ///< message queue attributes

} osMailQDef\_t;

The Mailbox can be created by calling the osMailCreate() API.

Rev 1.2 Page113 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.133.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)*Software Development User Guide*

osMailQId osMailCreate (const osMailQDef\_t \*queue\_def, osThreadId

thread\_id) {

os\_mail\_queue\_t \*ptr;

(void)thread\_id;

if (queue\_def == NULL) {

return (osMailQId)NULL;

}

ptr = queue\_def->mail;

if (ptr == NULL) {

return (osMailQId)NULL;

}

ptr->mp\_id = osMemoryPoolNew (queue\_def->queue\_sz, queue\_def->item\_sz,

&queue\_def->mp\_attr);

ptr->mq\_id = osMessageQueueNew(queue\_def->queue\_sz, sizeof(void \*),

&queue\_def->mq\_attr);

if ((ptr->mp\_id == (osMemoryPoolId\_t)NULL) || (ptr->mq\_id ==

(osMessageQueueId\_t)NULL)) {

if (ptr->mp\_id != (osMemoryPoolId\_t)NULL) {

osMemoryPoolDelete(ptr->mp\_id);

}

if (ptr->mq\_id != (osMessageQueueId\_t)NULL) {

osMessageQueueDelete(ptr->mq\_id);

}

return (osMailQId)NULL;

}

return (osMailQId)ptr;

}

Here is an example to show the simple use of mailbox: Different users use app\_mailbox\_pull to fill in information to the

structure. “app\_thread” takes the information through app\_mailbox\_get from the structure and stores it into

mod\_handler.

static void app\_thread(void const \*argument)

{

while(1){

APP\_MESSAGE\_BLOCK \*msg\_p = NULL;

Rev 1.2 Page114 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.134.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

if (!app\_mailbox\_get(&msg\_p)) {

if (msg\_p->mod\_id < APP\_MODUAL\_NUM) {

if (mod\_handler[msg\_p->mod\_id]) {

int ret = mod\_handler[msg\_p->mod\_id](&(msg\_p->msg\_body));

if (ret)

TRACE(2,"mod\_handler[%d] ret=%d", msg\_p->mod\_id, ret);

}

}

app\_mailbox\_free(msg\_p);

}

}

}

1. ` `**OS Timer**

The CMSIS-RTOS API can be used to define any number of virtual timers which act as count down timers. When they

expire, they run a user call-back function to perform a specific action. Each timer can be configured as a one shot or

repeat timer. A virtual timer is created by first defining a timer structure. The timer must then be instantiated by an

RTOS thread.

Note that do not use osDelay and time-consuming operations in the timer callback function, which may block other

timer responses. It is recommended to send a message directly to the processing thread through the timer to trigger

task processing.

This creates the timer and defines it as a periodic timer (osTimerPeriodic) or a single shot timer (osTimerOnce). The

next parameter passes an argument to the callback function when the timer expires:

osTimerId osTimerCreate (const osTimerDef\_t \*timer\_def, os\_timer\_type type,

void \*argument) {

if (timer\_def == NULL) {

return (osTimerId)NULL;

}

return osTimerNew((osTimerFunc\_t)timer\_def->ptimer, type, argument,

&timer\_def->attr);

}

The timer can then be started at any point in a thread the timer start function invokes the timer by its handle and

defines a count period in kernel ticks. Each timer can be configured as a one-shot or a periodic timer. A periodic timer

repeats its operation until it is deleted or stopped. All timers can be started, restarted, or stopped.

Rev 1.2 Page115 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.135.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)*Software Development User Guide*

// start a timer

osStatus\_t osTimerStart (osTimerId\_t timer\_id, uint32\_t ticks);

// stop a timer

osStatus\_t osTimerStop (osTimerId\_t timer\_id);

**Sample Code 9: OS Timer**

{"os\_timer\_demo", os\_timer\_demo\_test},

[TEST, os\_timer\_demo]

1. ` `**OS Semaphore**

Semaphores are used to manage and protect access to shared resources. Semaphores are very similar to Mutexes.

Whereas a Mutex permits just one thread to access a shared resource at a time, a semaphore can be used to permit a

fixed number of threads/ISRs to access a pool of shared resources. Using semaphores, access to a group of identical

peripherals can be managed (such as multiple DMA channels).

**Figure 33 CMSIS-RTOS Semaphore**

To use a semaphore in the CMSIS-RTOS, you must first declare the semaphore attributes.

typedef struct {

const char \*name; ///< name of the semaphore

uint32\_t attr\_bits; ///< attribute bits

void \*cb\_mem; ///< memory for control block

uint32\_t cb\_size; ///< size of provided memory for

control block

} osSemaphoreAttr\_t;

Next, declare the semaphore handle. Then, within a thread the semaphore container can be initialized with a number

of tokens:

Rev 1.2 Page116 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.136.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

osSemaphoreId osSemaphoreCreate (const osSemaphoreDef\_t \*semaphore\_def,

int32\_t count) {

if (semaphore\_def == NULL) {

return (osSemaphoreId)NULL;

}

return osSemaphoreNew(osRtxSemaphoreTokenLimit, (uint32\_t)count,

semaphore\_def);

}

A semaphore object should be initialized to the maximum number of available tokens. This number of available

resources is specified as the parameters of the osSemaphoreNew function. Each time a semaphore token is obtained

with osSemaphoreAcquire (in available state), the semaphore count is decremented. When the semaphore count is 0

(i.e. depleted state), no more semaphore tokens can be obtained. The thread/ISR that tries to obtain the semaphore

token needs to wait until the next token is free. Semaphores are released with osSemaphoreRelease incrementing the

semaphore count.

Here is an example to show the simple use of Semaphore.

**Sample Code 10: OS Semaphore**

{"os\_semaphore\_demo", os\_semaphore\_demo\_test},

[TEST, os\_semaphore\_demo]

1. ` `**OS Delay**

Timer delay is the most basic function of these timing services. This is an easy way of providing timing delays within

your application. Although the RTOS kernel size is quoted as 5 KB, features such as delay loops and simple scheduling

loops are often part of a non-RTOS application and consume code bytes anyway, so the overhead of the RTOS can be

less than it immediately appears.

This call puts the calling thread into the WAIT\_DELAY state for the specified number of milliseconds. The scheduler

passes the execution request to the next thread in the READY state.

When the timer expires, the thread leaves the WAIT\_DELAY state and enters the READY state. The thread will resume

running when the scheduler moves it to the RUNNING state. If the thread then continues executing without any further

blocking OS calls, it is descheduled at the end of its time slice and be placed in the ready state, assuming another thread

of the same priority is ready to run.

In addition to the osDelay() function which gives a relative time delay starting from the instant it is called, there is also a

delay function which halts a thread until a specific point in time:

osStatus\_t osDelayUntil (uint32\_t ticks) {

Rev 1.2 Page117 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.137.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

osStatus\_t status;

EvrRtxDelayUntil(ticks);

if (IsIrqMode() || IsIrqMasked()) {

EvrRtxDelayError((int32\_t)osErrorISR);

status = osErrorISR;

} else {

status = \_\_svcDelayUntil(ticks);

}

return status;

}

The osDelayUntil() function will halt a thread until a specific value of kernel timer ticks is reached.

1. ` `**OS Thread Statistics**

By calculating the time of thread swap-in and swap-out, the statistics of thread usage can be obtained.

#if \_\_RTX\_CPU\_STATISTICS\_\_

uint32\_t swap\_in\_time; ///< the task schedule in time

uint32\_t swap\_out\_time; ///< the task schedule out time

uint32\_t rtime; ///< the task runing time after startup

uint32\_t step\_rtime; ///< the task runing time tile last

show

There is a simple example for thread statistics in the function “rtx\_show\_all\_threads” of “rtx\_thread\_dump.c”. The

function prints information about all threads in different states like current, next, ready, delay, wait, terminate, and the

state of timer and memory. The log information printed by the function “rtx\_show\_all\_threads” is defined in Table 25.

**Table 25 Threads Statistics Introduction**

**Item Information Description**

id Object thread Identifier

name Object thread Name

thread The first pointer to memory corresponding to the struct osRtxThread\_s

priority Thread Priority

||Thread||<p>thread\_addr Thread entry address</p><p>thread\_next Link pointer to next Thread in Object list</p>|
| :- | :- | :- | :- |
thread\_prev Link pointer to previous Thread in Object list

delay\_next Link pointer to next Thread in Delay list

delay\_prev Link pointer to previous Thread in Delay list

thread\_join Thread waiting to Join

Rev 1.2 Page118 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.138.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

flags\_options Thread/Event Flags Options

wait\_flags Waiting Thread/Event Flags

thread\_flags Thread Flags

stack\_mem Stack Memory

stack\_size Stack Size

sp Current Stack Pointer

min\_stack\_free Minimum remaining stack space

swap\_in\_time the task schedule in time

swap\_out\_time the task schedule out time

task runtime the task running time

frame Register address

Timer Object timer Name

Timer state Object timer State

Timer Timer type Timer Type (Periodic/One-shot)

Current tick Timer current tick

Load Timer load value

||Memory||<p>Memory size Memory Pool size</p><p>Used Used memory</p>|
| :- | :- | :- | :- |
The following figure shows the thread log demo:

**Figure 34 Thread Statistics Log Demo**

OS\_THREAD\_TIMING\_STATISTICS\_ENABLE

Rev 1.2 Page119 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.139.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Audio Function Usage Guide**
1. ` `**Audio Flinger**
1. ` `**Common Introduction**

Audio flinger is an audio policy executor, responsible for the management of I/O STREAM devices and the processing

and transmission of PCM data.

The following configuration items are available:

\- Playback configuration

\- Capture configuration

1. ` `**Capture Configuration**

**Table 26 Capture Configuration**

**Item Description Notes**

||enum AUD\_BITS\_T||<p>bit width of</p><p>PCM data</p>||<p>The bit width of PCM data is 0, 8, 12, 16, 20, 24, 32.</p><p>The default channel is AUD\_BITS\_16.</p>|
| :- | :- | :- | :- | :- | :- |
||<p>enum</p><p>AUD\_CHANNEL\_NUM\_T</p>||channel number||<p>The number of channels ranges from 0 to 8.</p><p>The default channel is AUD\_CHANNEL\_NUM\_1.</p>|
||enum AUD\_SAMPRATE\_T||<p>sample rate of</p><p>audio sample</p>||<p>The audio sampling rate ranges from 7350 to 812500 and DIV</p><p>must be a multiple of 32.</p><p>The default channel is AUD\_SAMPRATE\_8000.</p>|
Rev 1.2 Page120 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.140.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.035.jpeg)*Software Development User Guide*

enum AUD\_STREAM\_USE\_DEVICE\_T{

AUD\_STREAM\_USE\_DEVICE\_NULL = 0,

AUD\_STREAM\_USE\_EXT\_CODEC,

AUD\_STREAM\_USE\_INT\_CODEC,

AUD\_STREAM\_USE\_INT\_CODEC2,

AUD\_STREAM\_USE\_INT\_CODEC3,

AUD\_STREAM\_USE\_I2S0\_MASTER,

AUD\_STREAM\_USE\_I2S0\_SLAVE,

||<p>enum</p><p>AUD\_STREAM\_USE\_DEVIC</p><p>E\_T</p>||codec device||<p>AUD\_STREAM\_USE\_I2S1\_MASTER,</p><p>AUD\_STREAM\_USE\_I2S1\_SLAVE,</p><p>AUD\_STREAM\_USE\_TDM0\_MASTER,</p><p>AUD\_STREAM\_USE\_TDM0\_SLAVE,</p>|
| :- | :- | :- | :- | :- | :- |
AUD\_STREAM\_USE\_TDM1\_MASTER,

AUD\_STREAM\_USE\_TDM1\_SLAVE,

AUD\_STREAM\_USE\_SPDIF0,

AUD\_STREAM\_USE\_SPDIF1,

AUD\_STREAM\_USE\_BT\_PCM,

AUD\_STREAM\_USE\_DPD\_RX,

AUD\_STREAM\_USE\_MC,

}; here we use AUD\_STREAM\_USE\_EXT\_CODEC.

||<p>enum</p><p>TGT\_VOLUME\_LEVEL\_T</p>||volume The default channel is TGT\_VOLUME\_LEVEL\_15.|
| :- | :- | :- | :- |
||<p>enum</p><p>AUD\_IO\_PATH\_T</p>||io\_path The default channel is AUD\_INPUT\_PATH\_MAINMIC|
||<p>App\_factorymode\_data\_c</p><p>ome</p>||handler The callback function when mic data comes(capture stream)|
||<p>BT\_AUDIO\_CACHE\_2\_UN</p><p>CACHE</p>||data\_ptr The pointer of buffer to cache the capture data|
||<p>BT\_AUDIO\_FACTORMODE</p><p>\_BUFF\_SIZE</p>||data\_size The size of the data cache buffer. The default setting is 1024\*2.|
Use the following sample code to configure the Capture stream.

struct AF\_STREAM\_CONFIG\_T stream\_cfg;

memset(&stream\_cfg, 0, sizeof(stream\_cfg));

stream\_cfg.bits = AUD\_BITS\_16;

#ifdef SPEECH\_TX\_AEC\_CODEC\_REF

stream\_cfg.channel\_num = AUD\_CHANNEL\_NUM\_2;

#else

Rev 1.2 Page121 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.141.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

stream\_cfg.channel\_num = AUD\_CHANNEL\_NUM\_1;

#endif

#if defined(\_\_AUDIO\_RESAMPLE\_\_) && defined(SW\_CAPTURE\_RESAMPLE)

stream\_cfg.sample\_rate = AUD\_SAMPRATE\_8463;

#else

stream\_cfg.sample\_rate = AUD\_SAMPRATE\_8000;

#endif

#if FPGA==0

stream\_cfg.device = AUD\_STREAM\_USE\_INT\_CODEC;

#else

stream\_cfg.device = AUD\_STREAM\_USE\_EXT\_CODEC;

#endif

stream\_cfg.vol = TGT\_VOLUME\_LEVEL\_15;

stream\_cfg.io\_path = AUD\_INPUT\_PATH\_MAINMIC;

stream\_cfg.handler = app\_factorymode\_data\_come;

stream\_cfg.data\_ptr = BT\_AUDIO\_CACHE\_2\_UNCACHE(buff\_capture);

stream\_cfg.data\_size = BT\_AUDIO\_FACTORMODE\_BUFF\_SIZE;

af\_stream\_open(AUD\_STREAM\_ID\_0, AUD\_STREAM\_CAPTURE, &stream\_cfg);

1. ` `**Playback Configuration**

The configurations of Playback and Capture are mostly common, except for ‘io\_path’, ‘handler’, ‘data\_ptr’and

‘data\_size’.

**Table 27 Playback Configuration**

**Item Description Notes**

||enum AUD\_IO\_PATH\_T io\_path||<p>The default channel is</p><p>AUD\_OUTPUT\_PATH\_SPEAKER</p>|
| :- | :- | :- | :- |
||app\_factorymode\_more\_data handler||<p>callback function when playback ask for</p><p>more data(playback stream)</p>|
||BT\_AUDIO\_CACHE\_2\_UNCACHE data\_ptr||<p>pointer of buffer to cache the playback</p><p>data</p>|
||<p>BT\_AUDIO\_FACTORMODE\_BUFF\_S</p><p>IZE</p>||data\_size||<p>size of the data cache buffer. The default</p><p>setting is 1024\*4.</p>|
Use the following sample code to configure the Playback stream.

stream\_cfg.channel\_num = AUD\_CHANNEL\_NUM\_2;

stream\_cfg.io\_path = AUD\_OUTPUT\_PATH\_SPEAKER;

stream\_cfg.handler = app\_factorymode\_more\_data;

Rev 1.2 Page122 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.142.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

stream\_cfg.data\_ptr = BT\_AUDIO\_CACHE\_2\_UNCACHE(buff\_play);

stream\_cfg.data\_size = BT\_AUDIO\_FACTORMODE\_BUFF\_SIZE\*2;

af\_stream\_open(AUD\_STREAM\_ID\_0, AUD\_STREAM\_PLAYBACK, &stream\_cfg);

1. ` `**Audio Loopback Test**
1. ` `Configure the system frequency to match the audio stream process: `app\_sysfreq\_req`.

if (freq < APP\_SYSFREQ\_52M) {

freq = APP\_SYSFREQ\_52M;

}

app\_sysfreq\_req(APP\_SYSFREQ\_USER\_APP\_0, freq);

1. ` `Initialize the audio-dedicated memory pool `app\_audio\_mempool\_init`.

app\_audio\_mempool\_init();

1. ` `Allocate buffer from the audio memory pool.

Parameter info:

\- buff: the pointer of audio buffer to allocate.

\- size: the size of audio buffer to allocate.

app\_audio\_mempool\_get\_buff(&buff\_capture, BT\_AUDIO\_FACTORMODE\_BUFF\_SIZE);

app\_audio\_mempool\_get\_buff(&buff\_play,

BT\_AUDIO\_FACTORMODE\_BUFF\_SIZE\*2);

1. ` `Configure the stream.

Use the structure `struct AF\_STREAM\_CONFIG\_T` to configure the stream. Description of the parameters:

\- .bit: the bit width of PCM data. The type is `enum AUD\_BITS\_T`.

\- .channel\_num: the channel number.

\- .sample\_rate: the sample rate of audio sample.

\- .device: the codec device. Here, `AUD\_STREAM\_USE\_INT\_CODEC` is used for the internal codec.

\- .vol: the volume, which is used to configure the gain of the audio data.

\- .io\_path: the input/output path, `AUD\_INPUT\_PATH\_MAINMIC` for capture and `AUD\_OUTPUT\_PATH\_SPEAKER`

for playback.

\- .handler: the callback function when mic data comes (capture stream) or playback requests more data (playback

stream).

\- .data\_ptr: the pointer of the buffer to cache the capture/playback data.

\- .data\_size: the size of the data cache buffer.

Rev 1.2 Page123 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.143.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

struct AF\_STREAM\_CONFIG\_T stream\_cfg;

memset(&stream\_cfg, 0, sizeof(stream\_cfg));

stream\_cfg.bits = AUD\_BITS\_16;

#ifdef SPEECH\_TX\_AEC\_CODEC\_REF

stream\_cfg.channel\_num = AUD\_CHANNEL\_NUM\_2;

#else

stream\_cfg.channel\_num = AUD\_CHANNEL\_NUM\_1;

#endif

#if defined(\_\_AUDIO\_RESAMPLE\_\_) && defined(SW\_CAPTURE\_RESAMPLE)

stream\_cfg.sample\_rate = AUD\_SAMPRATE\_8463;

#else

stream\_cfg.sample\_rate = AUD\_SAMPRATE\_8000;

#endif

#if FPGA==0

stream\_cfg.device = AUD\_STREAM\_USE\_INT\_CODEC;

#else

stream\_cfg.device = AUD\_STREAM\_USE\_EXT\_CODEC;

#endif

stream\_cfg.vol = TGT\_VOLUME\_LEVEL\_15;

stream\_cfg.io\_path = AUD\_INPUT\_PATH\_MAINMIC;

stream\_cfg.handler = app\_factorymode\_data\_come;

stream\_cfg.data\_ptr = BT\_AUDIO\_CACHE\_2\_UNCACHE(buff\_capture);

stream\_cfg.data\_size = BT\_AUDIO\_FACTORMODE\_BUFF\_SIZE;

1. ` `Open stream with `af\_stream\_open`.

Parameter info:

\- id: the stream ID.

\- stream: the stream type(capture or playback).

\- cfg: the stream configurations. Pass in the configurations in step 4.

af\_stream\_open(AUD\_STREAM\_ID\_0, AUD\_STREAM\_CAPTURE, &stream\_cfg);

1. ` `Start the stream with `af\_stream\_start`.

Start the configured stream with the incoming stream ID and stream type, and the audio flinger starts running.

af\_stream\_start(AUD\_STREAM\_ID\_0, AUD\_STREAM\_CAPTURE);

1. ` `Audio data input/output is triggered by DMA interrupt.

The mic data is handled (or playback data is loaded) in the `.handler` configured in step 4.

Rev 1.2 Page124 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.144.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

static uint32\_t app\_factorymode\_data\_come(uint8\_t \*buf, uint32\_t len)

{

app\_audio\_pcmbuff\_put(buf, len);

if (a2dp\_cache\_status == APP\_AUDIO\_CACHE\_QTY){

a2dp\_cache\_status = APP\_AUDIO\_CACHE\_OK;

}

return len;

}

static uint32\_t app\_factorymode\_more\_data(uint8\_t \*buf, uint32\_t len)

{

if (a2dp\_cache\_status != APP\_AUDIO\_CACHE\_QTY){

app\_audio\_pcmbuff\_get((uint8\_t \*)app\_audioloop\_play\_cache, len/2);

app\_bt\_stream\_copy\_track\_one\_to\_two\_16bits((int16\_t \*)buf,

app\_audioloop\_play\_cache, len/2/2);

}

return len;

}

1. ` `Stop the audio stream.

Call `af\_stream\_stop` to stop a specific audio stream according to the stream ID and stream type.

af\_stream\_stop(AUD\_STREAM\_ID\_0, AUD\_STREAM\_CAPTURE);

af\_stream\_stop(AUD\_STREAM\_ID\_0, AUD\_STREAM\_PLAYBACK);

1. ` `Close the audio stream.

Call `af\_stream\_close` to close a specific audio stream according to the stream ID and stream type

af\_stream\_close(AUD\_STREAM\_ID\_0, AUD\_STREAM\_CAPTURE);

af\_stream\_close(AUD\_STREAM\_ID\_0, AUD\_STREAM\_PLAYBACK);

**Sample Code 11: Audio Loopback Test**

{"factorymode\_audioloop", factorymode\_audioloop\_test},

[TEST, factorymode\_audioloop]

Rev 1.2 Page125 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.145.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

1. ` `**Audio Data Path Introduction**
1. ` `**Phone Call**

**Figure 35 Audio Path Flow of Phone Call**

The same source clock is used for audio RX/TX and speaker/mic, and also the sco link uses the reserved time slot for BT

data packet TX and RX, so the BT controller audio streaming and codec’s ticks are synchronized via hardware.

All the handling is in the audio thread.

By default, one frame is 7.5ms.

The sco delay measurement result is: 40ms for playback, less than 40ms for capturing.

**Key functions:**

\- **Call the capture DMA IRQ handler**

bt\_sco\_player()->bt\_sco\_codec\_capture\_data

stream\_cfg.handler = bt\_sco\_codec\_capture\_data;

\- **Call the playback DMA IRQ handler**

bt\_sco\_player()->bt\_sco\_codec\_playback\_data

stream\_cfg.handler = bt\_sco\_codec\_playback\_data;

Rev 1.2 Page126 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.146.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Music Playback**

**Audio path:**

**Figure 36 Audio Path Flow of Music Playback**

Sample count for each audio data entry: AAC/1024, SBC/128, Scalable/864.

There is no additional PCM buffer for buffering the PCM data from decoder. The decoder’s output PCM data is directly

fed into the Codec.

**Audio Info Sync:**

Rev 1.2 Page127 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.147.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.037.jpeg)*Software Development User Guide*

**Figure 37 Audio Info Sync of Music Playback**

\- The codec triggering accuracy on BES2700YP is 1 us. The codec feeding unit size (DMA irq chunk size) is configured

as exactly the one AAC frame (1024 samples), five SBC smallest sequence (5\*128 samples), or one scalable frame

(864 samples)

\- Every 25 DMA irqs interval, both sides collects the sync Info of the same frame. The master sends the info of last

interval to the slave for synchronizing.

\- The L/R sync detection is done during sync info processing.

\- Audio delay is in the unit of codec frame. E.g., 23ms\*5 = 115ms for AAC codec. Re-sampling factor tuning is applied

to assure that the delay is within the range.

**Key functions:**

\- **call playback dma irq handler**

bt\_sbc\_player()-> bt\_sbc\_player\_more\_data

stream\_cfg.handler = bt\_sbc\_player\_more\_data;

1. ` `**Left and Right Playback Channel Configuration**

The left and right playback channel configuration is implemented in the app\_ibrt\_ui\_v2\_test\_config\_load and

app\_tws\_ibrt\_reconfig\_Role function. The parameter is ibrt\_config\_t.

app\_ibrt\_init -> app\_ibrt\_ui\_v2\_test\_config\_load

typedef struct

{

ibrt\_role\_e nv\_role;

bt\_bdaddr\_t local\_addr;

bt\_bdaddr\_t peer\_addr;

bt\_bdaddr\_t mobile\_addr;

uint32\_t audio\_chnl\_sel;

} ibrt\_config\_t;

1. ` `**Configuration Steps**
1. ` `Get the configuration parameters from NV.

ibrt\_config\_t \*ibrt\_config = (ibrt\_config\_t \*)config;

struct nvrecord\_env\_t \*nvrecord\_env;

nv\_record\_env\_get(&nvrecord\_env);

factory\_section\_original\_btaddr\_get(ibrt\_config->local\_addr.address);

Rev 1.2 Page128 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.148.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

1. ` `The master and slave are judged according to the mantissa of the local address. If it's 1, it's the master. If it's 0, it's

slave. Finally, the program writes the result to NV.

app\_ibrt\_initialize\_nv\_role\_callback(ibrt\_config, nvrecord\_env);

1. ` `In the app\_tws\_ibrt\_reconfig\_Role (), configure the left and right playback channel.

void app\_tws\_ibrt\_reconfig\_role(uint32\_t role, const uint8\_t \*pMasterAddr,

const uint8\_t \*pSlaveAddr, bool

isRightMasterSidePolicy)

{

... ...

if (isRightMasterSidePolicy)

{

if (IBRT\_MASTER == role)

{

p\_ibrt\_ctrl->audio\_chnl\_sel = AUDIO\_CHANNEL\_SELECT\_RCHNL;

app\_ibrt\_middleware\_set\_side(EAR\_SIDE\_RIGHT);

}

else if (IBRT\_SLAVE == role)

{

p\_ibrt\_ctrl->audio\_chnl\_sel = AUDIO\_CHANNEL\_SELECT\_LCHNL;

app\_ibrt\_middleware\_set\_side(EAR\_SIDE\_LEFT);

}

}

else

{

if (IBRT\_SLAVE == role)

{

p\_ibrt\_ctrl->audio\_chnl\_sel = AUDIO\_CHANNEL\_SELECT\_RCHNL;

app\_ibrt\_middleware\_set\_side(EAR\_SIDE\_RIGHT);

}

else if (IBRT\_MASTER == role)

{

p\_ibrt\_ctrl->audio\_chnl\_sel = AUDIO\_CHANNEL\_SELECT\_LCHNL;

app\_ibrt\_middleware\_set\_side(EAR\_SIDE\_LEFT);

}

}

Rev 1.2 Page129 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.149.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.035.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

APP\_TWS\_SIDE\_T custom\_side = app\_ibrt\_ui\_get\_earbud\_side();

if (EAR\_SIDE\_NUM != custom\_side)

{

TRACE(0, "app\_tws\_side\_info!");

ibrt\_ui\_v2\_audio\_chnl\_custom\_config(custom\_side, p\_ibrt\_ctrl);

}

... ...

1. ` `You can reconfigure channels by using WEAK APP\_TWS\_SIDE\_T APP\_iBRT\_UI\_geT\_earbud\_side (void).

WEAK APP\_TWS\_SIDE\_T app\_ibrt\_ui\_get\_earbud\_side(void)

{

return EAR\_SIDE\_NUM;

}

void ibrt\_ui\_v2\_audio\_chnl\_custom\_config( APP\_TWS\_SIDE\_T earbudSize,

ibrt\_config\_t \*ibrt\_config, struct nvrecord\_env\_t \*nvrecord\_env)

{

if (EAR\_SIDE\_LEFT == earbudSize)

{

TRACE(0, "EAR\_SIDE\_LEFT!");

p\_ibrt\_ctrl->audio\_chnl\_sel = AUDIO\_CHANNEL\_SELECT\_LCHNL;

app\_ibrt\_if\_set\_side(EAR\_SIDE\_LEFT);

}

else if (EAR\_SIDE\_RIGHT == earbudSize)

{

TRACE(0, "EAR\_SIDE\_RIGHT!");

p\_ibrt\_ctrl->audio\_chnl\_sel = AUDIO\_CHANNEL\_SELECT\_RCHNL;

app\_ibrt\_if\_set\_side(EAR\_SIDE\_RIGHT);

}

}

1. ` `**Configuration of Stereo**

In order to enable stereo, you need to turn A2DP\_AUDIO\_STEREO\_MIX\_CTRL into 1 in target.mk.

export A2DP\_AUDIO\_STEREO\_MIX\_CTRL ?= 1

Rev 1.2 Page130 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.150.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

1. ` `**Configure Music Jitter Buffer Length**
1. ` `**Initial Jitter Buffer Length**

The initial Jitter buffer Length is determined by the macro. The Initial Jitter buffer Length varies with the decoding

mode. Take SCALABLE as an example.

#define A2DP\_PLAYER\_PLAYBACK\_DELAY\_SCALABLE\_HIRES\_MTU (13)

#define A2DP\_PLAYER\_PLAYBACK\_DELAY\_SCALABLE\_HIRES\_BASE (9000)

#define A2DP\_PLAYER\_PLAYBACK\_DELAY\_SCALABLE\_HIRES\_US

(A2DP\_PLAYER\_PLAYBACK\_DELAY\_SCALABLE\_HIRES\_BASE\*A2DP\_PLAYER\_PLAYBACK\_DELAY\_

SCALABLE\_HIRES\_MTU)

#define A2DP\_PLAYER\_PLAYBACK\_DELAY\_SCALABLE\_BASERES\_MTU ((8-

A2DP\_PLAYER\_PLAYBACK\_WATER\_LINE\_BASE\_LINE))

#define A2DP\_PLAYER\_PLAYBACK\_DELAY\_SCALABLE\_BASERES\_BASE (19500)

#define A2DP\_PLAYER\_PLAYBACK\_DELAY\_SCALABLE\_BASERES\_US

(A2DP\_PLAYER\_PLAYBACK\_DELAY\_SCALABLE\_BASERES\_BASE\*A2DP\_PLAYER\_PLAYBACK\_DELA

Y\_SCALABLE\_BASERES\_MTU)

if(stream\_cfg->sample\_rate > AUD\_SAMPRATE\_48000){

tg\_trigger\_time = A2DP\_PLAYER\_PLAYBACK\_DELAY\_SCALABLE\_HIRES\_US \*

a2dp\_audio\_latency\_factor\_get();

tg\_trigger\_time +=

offset\*A2DP\_PLAYER\_PLAYBACK\_DELAY\_SCALABLE\_HIRES\_BASE;

}else{

tg\_trigger\_time = A2DP\_PLAYER\_PLAYBACK\_DELAY\_SCALABLE\_BASERES\_US

\* a2dp\_audio\_latency\_factor\_get();

tg\_trigger\_time +=

offset\*A2DP\_PLAYER\_PLAYBACK\_DELAY\_SCALABLE\_BASERES\_BASE;

}

1. ` `**Run-time Update of Jitter Buffer Length**

You can use the following interface to update the jitter buffer length during running.

void sbm\_update\_target\_jitter\_buf\_length(uint16\_t targetMs)

The system calculates targetBufCount based on targetMs, so the actual target time is based on the calculated

targetBufCount . The minimum value of targetBufCount defaults to 5.

Rev 1.2 Page131 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

targetBufCount = (targetMs\*currentSampleRate/1000)/sampleCountPerBuf;

**Sample Code 12: Music Jitter Buffer Length**

{"a2dp\_change\_jitter\_buf", a2dp\_change\_jitter\_buf\_test},

[TEST, a2dp\_change\_jitter\_buf|<parameter>]

1. ` `**Callback API**
1. ` `**Prompt Usage Guide**
1. ` `**General Introduction**

This section describes the audio prompts of the project. Audio prompts are generally used to indicate event that is

happening or the current status of device to the users. For example, when the device is turned on, a piece of specific

audio indicating “power on” will be played. The audio can be customized to either a piece of music or recorded human

voice, according to different needs.

The current default audio prompt provided is voice recordings in English. A total of two packages of prompts are

supported right now. User can switch between the two packages while using the device. To switch to more packages or

to update the current language package, using OTA to upgrade the device is required.

The following specification is designed to show the design of two types of voice prompt supported, i.e.: embedded

prompt and prompt in flash, customization of voice prompts, and using OTA to upgrade the prompt in flash.

1. ` `**Design Discussion**

Initally, the audio prompt files are desgined to be integrated into the general image file. By transforming prerecorded

wav files to txt files, and then include them into header files, the preset audio prompts are encoded and built into the

main image alongside with other promgrams and data. Those prompts are called **embedded promtp**s. Each audio is

encoded into binary data and initalized to an array, and then the array is mapped to a sound mapping struct and thus

they can be called and played when necessary. They can be customized before they are built and programmed into the

flash of the device.

With the introduce of the OTA functionaility and the need for supporting multiple language packages to provide better

user experience, the second way of integrating audio prompt: **prompt in flash**, is desgined and implemented. This type

implementation of integrating audio prompt will consider each package of audio prompt as a whole and promgram

them into a fix area of the flash. Currently, two slots in flash are reserved for two packages of audio prompts. By

default, the English voice prompt is promgramed initially in the first slot and the other slot in flash is left empty.

Comparing to the original embedded prompts, the new prompt in flash has more flexibility when it comes to upgrading

audio prompt package or increasing supported languages, since it won’t need to rebuild and reprogram the whole

image, it just need to create the prompt package binary file and then use OTA to program the binary file to certain

location of the flash. It also provides the functionaility of switching between different audio prompt packages while

using the device, without rebooting it.

Rev 1.2 Page132 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.151.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.152.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.152.jpeg)*Software Development User Guide*

To summarize, for simplier built and smaller total image size, embedded prompts is recommended, and for more

flexibility and maintainability, prompt in flash should be applied.

1. ` `**Audio File Format Conversion and Inclusion**
1. ` `*RAW AUDIO FILE CONVERSION*

Audio prompts package should be first transformed from *wav* audio format to sbc array in *txt* format, so as to be

included by the program.

A format conversion tool called “*wav2sbcArray.exe”*, is provided. It should run in the Windows command prompt, e.g.:

PowerShell, by using the following command:

wav2sbcArray.exe Target.wav ParaA

Target.wav is the audio file to be conversed and ParaA indicates the ratio of the compression. The default SBC bitpool is

39 when ParaA is absent. The tools only support audio files with the sample frequency of 16000, 32000, 44100 or

Files are created with the name as Target\_8k.sbc, Target\_16k.sbc or Target\_44.1k.sbc according to the sample

frequency of the original files along with another named Target\_XXk.txt.

**Figure 38 Convert Command**

2. ` `*RESOURCE FILE RELOCATION*

Rev 1.2 Page133 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.153.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

Project folder as shown in the following figure has many subfolders which indicate the different operation

environments of the voice prompts. Move the generated Target\_XXk.txt into one as needed. For example, “en”

contains the English prompts and “cn” contains the Chinese ones.

**Figure 39 File Relocation**

In this case, the ljcg\_16k.wave\_16k.txt file is copied into the “en” folder.

Note: The directory of the resource file is located in the following address by default.

./config/\_default\_cfg\_src\_/res/

2. ` `*AUDIO RESOURCE FILE INCLUSION*

This part is specified for customizing embedded prompts. Since the resource files are directly included by header file in

when using embedded prompt, the promgram files should be modified to replace original resource files to customized

new ones.

**Firstly**, the new converted *txt* file should be added to the header file called res\_audio\_data\_XX.h. The directory is the

following:

./services/audio\_bt/res\_audio\_data.h

**Secondly**, add the new item to the header file *res\_audio\_data.h* according to its corresponding content. In this

example, the EN\_POWER\_ON item is modified. To replace the old prompt file, change the txt file name.

const uint8\_t EN\_POWER\_ON [] = {

#include "res/en/SOUND\_POWER\_ON.txt"

};

To create new prompts additional to the originals, two extra steps should be performed.

**Step 1**: In the header file *res\_audio\_data.h,* add customized array name.

**Step 2**: Look into the file *“app\_media\_player.cpp”* for the function:

Rev 1.2 Page134 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.154.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.155.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.156.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.157.jpeg)*Software Development User Guide*

“void media\_runtime\_audio\_prompt\_update(uint16\_t id, uint8\_t\*\* ptr, uint32\_t\*

len)”.

Change the corresponding “*case*” item of “*switch( ptr->aud\_id)*” to a customized ID if necessary.

switch (id) {

case AUD\_ID\_POWER\_ON:

get\_sound\_id\_info(POWER\_ON, &sound\_data, &length);

break;

Please be noted that the default audio sample rate of the voice prompts is 16000. To replace the original ones with new

sample rate, the code should be adjusted at the same time.

For stand-alone voice prompt, it’s located in the function “int app\_play\_audio\_onoff(bool onoff, APP\_AUDIO\_STATUS\*

status)” of file “App\_media\_player.cpp”.

stream\_cfg.sample\_rate = AUD\_SAMPRATE\_16000;

2. ` `*AUDIO RESOURCE FILE CONVERSION TO BINARY*

To use the prompt in flash functionaility, the audio resource file should be further convered from txt file to binary files,

so as to be programmed or upgraded to flash separately.

The tool for convertion is called *“prompt\_bin\_generate.py”*, it is located under the following directory:

tools/prompt\_bin\_generate

The command to use to generate the binary file is the following:

python <directory-of-the-conversion-file>\prompt\_bin\_generate.py -i <prompt

ID> -v <version> -c <directory-of-configuration-file>/prompt\_gen.csv -d

<directory-of-resource-file>\en

Here is an example of the command:

python E:\workbench\mcu-sw\tools\prompt\_bin\_generate\prompt\_bin\_generate.py -

i 0x00000001 -v 0x00000001 -c ./prompt\_gen.csv -d E:\workbench\mcu-

sw\config\\_default\_cfg\_src\_\res\en

The default output file is *“combined\_bin.bin”*. The output directory is shown in the output info by the

*“prompt\_bin\_generate.py”.* For detailed instruction, please check the readMe file under the same directory with the

python converstion file.

Rev 1.2 Page135 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.158.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

Note: When generating the binary file, pay attention to the “-i” argument. This argument is short for “--id”, which

indicates the prompt ID. In the default setting, the English prompt ID is set to 1. While other language prompt package

ID are listed in the following code snippet:

typedef enum

{

LANGUAGE\_ID\_INVALID = 0,

LANGUAGE\_ID\_EN = 1,

LANGUAGE\_ID\_CN = 2,

LANGUAGE\_ID\_GN = 3,

LANGUAGE\_ID\_FN = 4,

LANGUAGE\_ID\_KN = 5,

LANGUAGE\_ID\_JN = 6,

LANGUAGE\_ID\_RN = 7,

LANGUAGE\_ID\_NUM = 0xFF,

} LANGUAGE\_ID\_E;

The above code snipped is in file “app\_media\_player.h”. If new language prompt package to be added, please be

guided that there is a default mapping between some certain language and its ID.

1. ` `**VOICE PROMPT API**

The Voice Prompt API amid at providing services for playing certain voice prompt audio when necessary. For example,

when there is an income phone call, the promgram can call a certain function to play a voice audio indicating this event

to the user. Functions of different purposes are listed in the following table. Generally, when calling those functions,

prompt ID and target device ID need to be specified as input parameters. Those functions are decleared in header file

“app\_media\_player”.

**Table 28 APIs of Voice Prompt Module**

**Item Description parameters**

\- Prompt will be played on the The APP\_STATUS\_INDICATION\_T

||<p>**media\_PlayAudio(AUD\_ID\_E**</p><p>**NUM id, uint8\_t device\_id);**</p>||<p>both sides if they're</p><p>connected.</p><p>- If there are music/phone call</p>||<p>enumeration type parameter represents the prompt</p><p>tone number and is used to index the prompt tone</p><p>ID.</p>|
| :- | :- | :- | :- | :- | :- |
on-going, the prompt will be typedef enum {

mixed. AUD\_ID\_INVALID,

**media\_PlayAudio\_locally(A** - Prompt will be played locally AUD\_ID\_POWER\_ON,

**UD\_ID\_ENUM id, uint8\_t** no matter whether earbuds AUD\_ID\_POWER\_OFF,

**device\_id);** are connected or not AUD\_ID\_LANGUAGE\_SWITCH,

Rev 1.2 Page136 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.159.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

\- If there are music/phone call AUD\_ID\_NUM\_0,

on-going, the prompt will be AUD\_ID\_NUM\_1,

mixed. AUD\_ID\_NUM\_2,

\- Prompt will be played on AUD\_ID\_NUM\_3,

peer device only if they're AUD\_ID\_NUM\_4,

**media\_PlayAudio\_remotely** connected. AUD\_ID\_NUM\_5,

**(AUD\_ID\_ENUM id, uint8\_t** - If there are music/phone call AUD\_ID\_NUM\_6,

**device\_id);** on-going, the music or phone AUD\_ID\_NUM\_7,

call output will be stopped AUD\_ID\_NUM\_8,

until the prompt playing is AUD\_ID\_NUM\_9,

completed.

\- Prompt will be played on the AUD\_ID\_BT\_PAIR\_ENABLE,

both sides if they're AUD\_ID\_BT\_PAIRING,

||<p>**media\_PlayAudio\_standalon**</p><p>**e(AUD\_ID\_ENUM id, uint8\_t**</p><p>**device\_id);**</p>||<p>connected.</p><p>- If there are music/phone call</p><p>on-going, the music or phone</p><p>call output will be stopped</p>||<p>AUD\_ID\_BT\_PAIRING\_SUC,</p><p>AUD\_ID\_BT\_PAIRING\_FAIL,</p><p>AUD\_ID\_BT\_CALL\_REFUSE,</p><p>AUD\_ID\_BT\_CALL\_OVER,</p>|
| :- | :- | :- | :- | :- | :- |
until the prompt playing is AUD\_ID\_BT\_CALL\_ANSWER,

completed. AUD\_ID\_BT\_CALL\_HUNG\_UP,

**media\_PlayAudio\_standalon** - Prompt will be played locally

AUD\_ID\_BT\_CALL\_INCOMING\_CALL,

**e\_locally(AUD\_ID\_ENUM id,** no matter whether earbuds

AUD\_ID\_BT\_CALL\_INCOMING\_NUMBER,

**uint8\_t device\_id);** are connected or not

AUD\_ID\_BT\_CHARGE\_PLEASE,

\- If there are music/phone call

AUD\_ID\_BT\_CHARGE\_FINISH,

on-going, the music or phone

AUD\_ID\_BT\_CLEAR\_SUCCESS,

call output will be stopped

AUD\_ID\_BT\_CLEAR\_FAIL,

until the prompt playing is

AUD\_ID\_BT\_CONNECTED,

completed.

AUD\_ID\_BT\_DIS\_CONNECT,

AUD\_ID\_BT\_WARNING, **media\_PlayAudio\_standalon** - Prompt will be played on the

AUDIO\_ID\_BT\_ALEXA\_START, **e\_remotely(AUD\_ID\_ENUM** peer device only if they're

AUDIO\_ID\_FIND\_MY\_BUDS, **id, uint8\_t device\_id);** connected.

AUDIO\_ID\_FIND\_TILE, - If there are music/phone call

AUDIO\_ID\_BT\_ALEXA\_STOP, on-going, the music or phone

AUDIO\_ID\_BT\_GSOUND\_MIC\_OPEN, call output will be stopped

AUDIO\_ID\_BT\_GSOUND\_MIC\_CLOSE, until the prompt playing is

AUDIO\_ID\_BT\_GSOUND\_NC, completed.

AUDIO\_ID\_BT\_MUTE, **media\_PlayAudio\_continuo** - Prompt will be played on the

AUD\_ID\_RING\_WARNING, **us\_start(AUD\_ID\_ENUM id,** both sides if they're

#ifdef \_\_INTERACTION\_\_ **uint8\_t device\_id);** connected.

Rev 1.2 Page137 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.160.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

\- If there are music/phone call AUD\_ID\_BT\_FINDME,

on-going, the prompt will be #endif

mixed. AUD\_ID\_ANC\_PROMPT,

\- Prompt will keep playing AUD\_ID\_ANC\_MUTE,

time and time again until AUD\_ID\_ANC\_MODE0,

media\_PlayAudio\_continuous AUD\_ID\_ANC\_MODE1,

\_end is called #if BLE\_AUDIO\_ENABLED

**media\_PlayAudio\_continuo** Stop the on-going continuous AUD\_ID\_LE\_AUD\_INCOMING\_CALL,

**us\_end(AUD\_ID\_ENUM id,** prompt playing #endif

MAX\_RECORD\_NUM, **uint8\_t device\_id);**

AUD\_ID\_ENUM\_BOTTOM,

} AUD\_ID\_ENUM;

device\_idindicates the device ID. The value is

generally 0.

**app\_prompt\_stop\_all();** Stop the current prompt

playing, and clear subsequent

requests to prompt

**app\_prompt\_start\_callback\_** A callback function that is

**register(app\_prompt\_start\_** automatically invoked at the

**cb cb);** beginning of each prompt

function The cbis the ID of the current prompt (audio ID).

**app\_prompt\_finish\_callback** A callback function that is

**\_register(app\_prompt\_finsih** automatically invoked at the

**\_cb cb);** end of each prompt function

**Sample Code 13: Prompt Usage Test**

{"prompt\_stop\_all", prompt\_stop\_all\_test},

{"media\_PlayAudio\_test", media\_PlayAudio\_test},

{"media\_PlayAudio\_locally\_test", media\_PlayAudio\_locally\_test},

{"media\_PlayAudio\_remotely\_test", media\_PlayAudio\_remotely\_test},

{"media\_PlayAudio\_standalone\_test", media\_PlayAudio\_standalone\_test},

{"media\_PlayAudio\_standalone\_locally\_test", media\_PlayAudio\_standalone\_locally\_test},

{"media\_PlayAudio\_standalone\_remotely\_test", media\_PlayAudio\_standalone\_remotely\_test},

{"media\_PlayAudio\_continuous", media\_PlayAudio\_continuous\_test},

Rev 1.2 Page138 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.161.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

{"prompt\_finish\_callback\_register", app\_prompt\_finish\_callback\_register\_test},

1. ` `**PROMPT IN FLASH API**

The Prompt In Flash API amid at providing services for lower level flash memory management. The services include

providing certain prompt audio data in flash according to specified language ID and audio ID, finding the correct address

space when it comes to upgrading existing prompt package or adding new prompt package to the flash, updating the

language prompt package that is least recently used, etc. Functions are declared in header file *“nvrecord\_prompt.h”*.

The following table shows the detailed information about each function in this API.

**Item Description parameters**

param[in] language: the id of language

**nv\_record\_prompt\_get\_package\_a** Obtain start address of required to get address of

**ddr(uint8\_t language);** language packet Return the start address of required

language package in flash

**nv\_record\_prompt\_get\_default\_st** Return the start address of default None

**art\_addr(void)** start address for prompt in flash

**nv\_record\_prompt\_get\_prompt\_in** Obtain the address and length of a param[out] data: pointer to the address

**fo(uint8\_t language, uint16\_t id,** specific prompt of a given language of the prompt

**uint8\_t \*\*data, uint32\_t \*length);** param[out] length: pointer to the

length of the prompt

param[in] language: the id of

language of the prompt info

param[in] id: the id of the prompt to

get info of

Return the start address of required

language package in flash;

Return the start address to program, if a

new langauge package is to be added by

specifying addNew to be true

**nv\_record\_get\_current\_language(v** Return the id of the current None

**oid);** language for prompt

**nv\_record\_switch\_current\_langua** switch to the other language if None

**ge(void)** there are two language packages in

flash

Rev 1.2 Page139 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.162.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.163.jpeg)*Software Development User Guide*

1. ` `**PROMGRAMING OPTION FOR PROMPT IN FLASH**

The process for programming the prompt binary file along with the main image file takes extra steps comparing to the

normal image programing process.

After generating the binary file using file conversion tool, the location of the prompt binary file should be acquired. This

information can be obtained by checking the “map” file. The location of the file is:

out/<build-version> /<build-version>.map

e.g.: out/best2500p\_ibrt/best2500p\_ibrt.map

In the map file, search for the line “.prompt”, this specifies the start address in flash to program. 28 is offset, which is

unnecessary. The address following the 28 is the corresponding address. The following picture shows an example of the

target promgram address.

Here is an example of how to program the prompt bin along with the main image. Please be noted that the location of

the binary file and the flash offset to program is applied in the field of “Custom bin Config” of the Dld promgrom

software.

Rev 1.2 Page140 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.164.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**OTA FOR PROMPT IN FLASH**

The OTA for prompt in flash can be achieved using mobile OTA application developed by Bestechnic. The application is

supported on both IOS and Android systems. To install the application, please search for “Bestechnic” in app store or

Google play. For detailed OTA process, please refer to the chapter 5.9.4 OTA User Guide.

Due to the limit of size in flash, two packages of prompt in flash is supported currently. The size of each prompt binary

file should be no larger than 152 KB. For OTA purpose, a buffer with the same size as a prompt package is reserved. The

following is the memory map for the voice prompt part of the flash.

When OTA is initialized, the new package will first be programmed to the buffer space. After the transmission is

complete, then the language ID of the new arrival voice prompt package will be checked.

\- If the new arrival package has the same language ID as one of the existing voice prompts in flash, the original

content of that language prompt in flash will be overwritten by the new arrival one. And the current prompt

language will be switched to the new one.

Rev 1.2 Page141 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.165.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

\- If the new arrival package has a new language ID comparing to the existing ones, if there is empty slot will be

checked.

a. If there is an empty slot, the new arrival package will be programed to the empty slot.

b. If there is no empty slot (there are two existing voice prompt packages), the least recently written slot

will be overwritten by the new one. For instance, if there is a default language prompt package,

English prompt, in slot 1, and then a Chinese voice prompt is programmed to slot 2 using OTA. After

that, a Germany prompt package should be OTA to the device, then the English prompt package in

slot 1 will be overwritten by the new arrival Germany prompt package.

1. ` `**Volume Level Configuration and Volume Control**
1. ` `**Music and Call**

The system has 17 levels of volume gain. The configurations are as follows.

const struct CODEC\_DAC\_VOL\_T codec\_dac\_vol[TGT\_VOLUME\_LEVEL\_QTY] = {

{TX\_PA\_GAIN,0x03,-99},

{TX\_PA\_GAIN,0x03,-45},

{TX\_PA\_GAIN,0x03,-42},

{TX\_PA\_GAIN,0x03,-39},

{TX\_PA\_GAIN,0x03,-36},

{TX\_PA\_GAIN,0x03,-33},

{TX\_PA\_GAIN,0x03,-30},

{TX\_PA\_GAIN,0x03,-27},

{TX\_PA\_GAIN,0x03,-24},

{TX\_PA\_GAIN,0x03,-21},

{TX\_PA\_GAIN,0x03,-18},

{TX\_PA\_GAIN,0x03,-15},

{TX\_PA\_GAIN,0x03,-12},

{TX\_PA\_GAIN,0x03, -9},

{TX\_PA\_GAIN,0x03, -6},

{TX\_PA\_GAIN,0x03, -3},

{TX\_PA\_GAIN,0x03, 0}, //0dBm

};

The system can record the information (such as the volume) of the last connection of several devices and update

information to the current connection status.

typedef struct {

uint32\_t pairedDevNum;

nvrec\_btdevicerecord pairedBtDevInfo[MAX\_BT\_PAIRED\_DEVICE\_COUNT];

Rev 1.2 Page142 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.166.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

} NV\_RECORD\_PAIRED\_BT\_DEV\_INFO\_T;

typedef struct {

btif\_device\_record\_t record;

btdevice\_volume device\_vol;

btdevice\_profile device\_plf;

#ifdef BTIF\_DIP\_DEVICE

bt\_dip\_pnp\_info\_t pnp\_info;

#endif

} nvrec\_btdevicerecord;

typedef struct btdevice\_profile {

bool hfp\_act;

uint8\_t a2dp\_abs\_vol;

bool a2dp\_act;

uint8\_t a2dp\_codectype;

} btdevice\_profile;

typedef struct btdevice\_volume

{

int8\_t a2dp\_vol;

int8\_t hfp\_vol;

} btdevice\_volume;

The interface for changing the volume is as follows:

\- Adjust the volume through the phone.

void app\_ibrt\_if\_a2dp\_send\_volume\_up(uint8\_t device\_id)

void app\_ibrt\_if\_a2dp\_send\_volume\_down(uint8\_t device\_id)

void app\_ibrt\_if\_a2dp\_send\_set\_abs\_volume(uint8\_t device\_id, uint8\_t

volume)

\- Adjust the volume through the earphone.

void app\_ibrt\_if\_set\_local\_volume\_up(void)

void app\_ibrt\_if\_set\_local\_volume\_down(void)

During music playback, the local volume is converted to Bluetooth volume by normalization, ranging from 0 to 127.

#define MAX\_A2DP\_VOL (127)

uint8\_t a2dp\_convert\_local\_vol\_to\_bt\_vol(uint8\_t localVol)

Rev 1.2 Page143 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.167.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)*Software Development User Guide*

{

return unsigned\_range\_value\_map(localVol, TGT\_VOLUME\_LEVEL\_MUTE,

TGT\_VOLUME\_LEVEL\_MAX, 0, MAX\_A2DP\_VOL);

}

During call playback, the local volume is converted to Bluetooth volume by normalization, ranging from 0 to 15.

#define MAX\_HFP\_VOL (15)

#define MIN\_HFP\_VOL (0)

#define HFP\_DEFAULT\_VOLUME (7)

uint8\_t hfp\_convert\_bt\_vol\_to\_local\_vol(uint8\_t btVol)

**Sample Code 14: Volume Level Configuration and Volume Control Test**

{"ib\_send\_volumeup",app\_ibrt\_send\_volumeup\_test},

{"ib\_send\_volumedn",app\_ibrt\_send\_volumedown\_test},

{"ib\_send\_setabsvol",app\_ibrt\_send\_set\_absvolume\_test},

{"ib\_adj\_local\_volup",app\_ibrt\_adjust\_local\_volumeup\_test},

{"ib\_adj\_local\_voldn",app\_ibrt\_adjust\_local\_volumedown\_test},

1. ` `**Bluetooth Usage Guide**
1. ` `**Bluetooth Framework**
1. ` `**Summary Architecture**

**Figure 40 Summary Architecture**

Rev 1.2 Page144 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.168.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Software Architecture**

**Figure 41 Software Architecture**

Bond the corresponding folders of the Bluetooth framework as follows.

**-> bthost**

**--> stack**

**---> bt\_if ---> ble\_if**

Bt interface Ble interface

**---> bt\_profiles ---> ble\_ stack**

The stack section is included. The stack contains several protocol stacks.

**----> protocols ---> ble\_profiles**

**-----> l2cap ---> le\_bridge**

**-----> btgatt**

**---->sdp**

**… …**

**--> service**

Rev 1.2 Page145 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**---> bt\_app ---> ble\_app**

Apps with non-BLE functions, such as broadcast functions, etc

**-----> a2dp\_codecs ---> ble\_audio**

Apps related to BLE

**-----> audio\_policy ----> aob\_app**

**-----> besmain.cpp ----> gaf\_core**

**---> bt\_source ---> ble\_audio**

**--> adapter**

**-> services**

**--> ibrt\_core\_v2**

IBRT Control: IO Event, SM, etc.

**--> ibrt\_ui\_v2**

peripheral manager: Open box, Wear up, etc.

1. ` `**Classic BT**
1. ` `**BT Mac Address and BT Name Configuration**

BT name and BT mac address can be configured in DldProductLine before programming. Both information is written

into the factory section after programming.

Rev 1.2 Page146 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.169.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 42 BT Mac Address and Bt Name Configuration**

1. ` `Get the BT address.

uint8\_t \*app\_ibrt\_if\_get\_bt\_local\_address(void)

1. ` `Update the BT address.

void app\_ibrt\_if\_write\_bt\_local\_address(uint8\_t\* btAddr)

**Sample Code 15: Get and Write BT Address**

{"get\_bt\_local\_address", app\_ibrt\_if\_get\_bt\_local\_address\_test},

{"get\_bt\_peer\_address", app\_ibrt\_if\_get\_bt\_peer\_address\_test},

{"write\_bt\_local\_address", app\_ibrt\_if\_write\_bt\_local\_address\_test},

Rev 1.2 Page147 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.170.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.171.jpeg)*Software Development User Guide*

1. ` `**Pairing Test**

\- Single-ear model

Make sure that the following macros are properly configured in target.mk.

POWER\_ON\_ENTER\_FREEMAN\_PAIRING\_ENABLED ?= 1

POWER\_ON\_ENTER\_TWS\_PAIRING\_ENABLED ?= 0

\- TWS model

Make sure that the following macros are properly configured in target.mk.

The master and slave are judged according to the mantissa of the local address. If it's 1, it's the master. If it's 0, it's

slave.

POWER\_ON\_ENTER\_FREEMAN\_PAIRING\_ENABLED ?= 0

POWER\_ON\_ENTER\_TWS\_PAIRING\_ENABLED ?= 1

1. ` `**Common API List**
1. ` `**Interface Description**
1. ` `Get the A2DP stream status of a specific mobile device address.

AppIbrtStatus app\_ibrt\_if\_get\_a2dp\_state(bt\_bdaddr\_t \*addr,

AppIbrtA2dpState \*a2dp\_state)

**Table 29 app\_ibrt\_if\_get\_a2dp\_state Parameters**

**Parameter Description**

addr Specify the mobile device address to get AVRCP palyback state

a2dp\_state Used to return A2DP stream state

**Sample Code 16: app\_ibrt\_if\_get\_a2dp\_state**

{"get\_a2dp\_state\_test", app\_ibrt\_if\_get\_a2dp\_state\_test},

1. ` `Get the AVRCP playback status of a specific mobile device address.

AppIbrtStatus app\_ibrt\_if\_get\_avrcp\_state(bt\_bdaddr\_t \*addr,

AppIbrtAvrcpState \*avrcp\_state)

**Table 30 app\_ibrt\_if\_get\_avrcp\_state Parameters**

**Parameter Description**

addr Specify the mobile device address to get AVRCP palyback state

Rev 1.2 Page148 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.172.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.173.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.174.jpeg)*Software Development User Guide*

a2dp\_state Used to return AVRCP palyback state

**Sample Code 17: app\_ibrt\_if\_get\_avrcp\_state**

{"get\_avrcp\_state\_test", app\_ibrt\_if\_get\_avrcp\_state\_test},

1. ` `Get the HFP status of a specific mobile device address.

AppIbrtStatus app\_ibrt\_if\_get\_hfp\_state(bt\_bdaddr\_t \*addr, AppIbrtHfpState

\*hfp\_state)

**Table 31 app\_ibrt\_if\_get\_hfp\_state Parameters**

**Parameter Description**

addr Specify the mobile device address to get HFP state

hfp\_state Used to return HFP state

**Sample Code 18: app\_ibrt\_if\_get\_hfp\_state**

{"get\_hfp\_state\_test", app\_ibrt\_if\_get\_hfp\_state\_test},

1. ` `Get the HFP call status of specific mobile device address.

AppIbrtStatus app\_ibrt\_if\_get\_hfp\_call\_status(bt\_bdaddr\_t \*addr,

AppIbrtCallStatus \*call\_status)

**Table 32 app\_ibrt\_if\_get\_hfp\_call\_status Parameters**

**Parameter Description**

addr Specify the mobile device address to get HFP state

hfp\_state Used to return HFP state

**Sample Code 19: app\_ibrt\_if\_get\_hfp\_call\_status**

{"get\_hfp\_call\_status", app\_ibrt\_if\_get\_hfp\_call\_status\_test},

1. ` `Get the current connected mobile count.

uint8\_t app\_ibrt\_if\_get\_connected\_mobile\_count(void)

**Sample Code 20: app\_ibrt\_if\_get\_connected\_mobile\_count**

{"connected\_mobile\_count", app\_ibrt\_if\_get\_connected\_mobile\_count\_test},

1. ` `Get current connected mobile device count and address list.

uint8\_t app\_ibrt\_if\_get\_mobile\_connected\_dev\_list(bt\_bdaddr\_t \*addr\_list)

Rev 1.2 Page149 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.175.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.171.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

**Table 33 app\_ibrt\_if\_get\_mobile\_connected\_dev\_list Parameters**

**Parameter Description**

addr\_list Used to return current connected mobile device address list

**Sample Code 21: app\_ibrt\_if\_get\_mobile\_connected\_dev\_list**

{"mobile\_connected\_dev\_list", app\_ibrt\_if\_get\_mobile\_connected\_dev\_list\_test},

1. ` `Check if the TWS role switch is ongoing.

bool app\_ibrt\_if\_is\_tws\_role\_switch\_on(void)

**Sample Code 22: app\_ibrt\_if\_is\_tws\_role\_switch\_on**

{"is\_tws\_role\_switch\_on", app\_ibrt\_if\_is\_tws\_role\_switch\_on\_test},

1. ` `Perform the role switch operation.

void app\_ibrt\_if\_tws\_role\_switch\_request(void)

**Sample Code 23: app\_ibrt\_if\_tws\_role\_switch\_reques**

{"role\_switch", app\_ibrt\_if\_tws\_role\_switch\_test},

1. ` `Get the address list of the history paired mobile phones.

bool

app\_ibrt\_if\_nvrecord\_get\_mobile\_addr(bt\_bdaddr\_tmobile\_addr\_list[],uint8\_t

\*count)

**Table 34 app\_ibrt\_if\_nvrecord\_get\_mobile\_addr Parameters**

**Parameter Description**

mobile\_addr\_list[] Address list of the history paired mobiles

hfp\_state Address count

**Sample Code 24: app\_ibrt\_if\_nvrecord\_get\_mobile\_addr**

{"nvrecord\_get\_mobile\_addr", app\_ibrt\_if\_nvrecord\_get\_mobile\_addr\_test},

1. ` `Clear all paired mobile records in the flash.

void app\_ibrt\_if\_nvrecord\_delete\_all\_mobile\_record(void)

**Sample Code 25: app\_ibrt\_if\_nvrecord\_delete\_all\_mobile\_record**

{"delete\_all\_mobile\_record", app\_ibrt\_if\_nvrecord\_delete\_all\_mobile\_record\_test},

Rev 1.2 Page150 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.176.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.177.jpeg)*Software Development User Guide*

1. ` `Get the paired mobile records.

bool app\_ibrt\_if\_nvrecord\_get\_mobile\_paired\_dev\_list(nvrec\_btdevicerecord

\*nv\_record,uint8\_t \*count)

**Table 35 app\_ibrt\_if\_nvrecord\_get\_mobile\_paired\_dev\_list Parameters**

**Parameter Description**

nv\_record Record list of the history paired mobiles

count Record count

**Sample Code 26: app\_ibrt\_if\_nvrecord\_get\_mobile\_paired\_dev\_list**

{"nvrecord\_get\_mobile\_paired\_dev\_list", app\_ibrt\_if\_nvrecord\_get\_mobile\_paired\_dev\_list\_test},

1. ` `Check if the TWS link is connected.

bool app\_ibrt\_if\_is\_tws\_link\_connected(void)

**Sample Code 27: app\_ibrt\_if\_is\_tws\_link\_connected**

{"is\_tws\_link\_connected", app\_ibrt\_if\_is\_tws\_link\_connected\_test},

1. ` `Check if freeman mode is enabled.

uint8\_t app\_ibrt\_if\_is\_in\_freeman\_mode(void)

**Sample Code 28: app\_ibrt\_if\_is\_in\_freeman\_mode**

{"is\_in\_freeman\_mode", app\_ibrt\_if\_is\_in\_freeman\_mode\_test},

1. ` `Disconnect a TWS link.

ibrt\_status\_t app\_ibrt\_if\_tws\_disconnect\_request(void)

**Sample Code 29: app\_ibrt\_if\_tws\_disconnect\_request**

{"tws\_disconnect\_request", app\_ibrt\_if\_tws\_disconnect\_request\_test},

1. ` `Disconnect a mobile link.

ibrt\_status\_t app\_ibrt\_if\_mobile\_disconnect\_request(const bt\_bdaddr\_t

\*addr,ibrt\_post\_func post\_func)

**Sample Code 30: app\_ibrt\_if\_mobile\_disconnect\_request**

{"mobile\_disconnect\_request", app\_ibrt\_if\_mobile\_disconnect\_request\_test},

1. ` `Check if it is in the TWS pairing state.

Rev 1.2 Page151 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.178.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

bool app\_ibrt\_if\_is\_tws\_in\_pairing\_state(void)

**Sample Code 31: app\_ibrt\_if\_is\_tws\_in\_pairing\_state**

{"is\_tws\_in\_pairing\_state", app\_ibrt\_conn\_is\_tws\_in\_pairing\_state\_test},

1. ` `Check if the earbud side is left.

bool app\_ibrt\_if\_is\_left\_side(void)

**Sample Code 32: app\_ibrt\_if\_is\_left\_side**

{"is\_left\_side", app\_ibrt\_if\_is\_left\_side\_test},

1. ` `Check if the earbud side is right.

bool app\_ibrt\_if\_is\_right\_side(void)

**Sample Code 33: app\_ibrt\_if\_is\_right\_side**

{"is\_right\_side", app\_ibrt\_if\_is\_right\_side\_test},

1. ` `Check if the earbud side is unknown.

bool app\_ibrt\_if\_unkown\_side(void)

**Sample Code 34: app\_ibrt\_if\_unknown\_side**

{"is\_unknown\_side", app\_ibrt\_if\_is\_unknown\_side\_test},

1. ` `Set a earbud side.

void app\_ibrt\_if\_set\_side(APP\_TWS\_SIDE\_T side)

**Table 36 app\_ibrt\_if\_set\_side Parameters**

**Parameter Description**

Side Only can be set to left or right side

**Sample Code 35: app\_ibrt\_if\_tws\_disconnect\_request**

{"ibrt\_if\_set\_side", app\_ibrt\_if\_set\_side\_test},

1. ` `Get the role of an earbud.

TWS\_UI\_ROLE\_E app\_ibrt\_if\_get\_ui\_role(void)

**Sample Code 36: app\_ibrt\_if\_tws\_disconnect\_request**

{"get\_ui\_role", app\_ibrt\_if\_get\_ui\_role\_test},

Rev 1.2 Page152 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.179.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.171.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.180.jpeg)*Software Development User Guide*

1. ` `Convert a role value to a string.

const char\* app\_ibrt\_if\_uirole2str(TWS\_UI\_ROLE\_E uiRole)

**Sample Code 37: app\_ibrt\_if\_uirole2str**

{"ibrt\_if\_uirole2str", app\_ibrt\_if\_uirole2str\_test},

1. ` `Register a user and its handling functions for specific TWS information sync.

void app\_ibrt\_if\_register\_sync\_user(TWS\_SYNC\_USER\_E id, TWS\_SYNC\_USER\_T

\*user)

**Table 37 app\_ibrt\_if\_register\_sync\_user Parameters**

**Parameter Description**

id User id

user Handling functions belonging to the user

For the usage of related interfaces, see [5.2.2.7.](#br172)

1. ` `Unregister a user.

void app\_ibrt\_if\_deregister\_sync\_user(TWS\_SYNC\_USER\_E id)

**Table 38 app\_ibrt\_if\_deregister\_sync\_user Parameters**

**Parameter Description**

id User id

For the usage of related interfaces, see [5.2.2.7.](#br172)

1. ` `Initialize and make preparation for TWS synchronization

void app\_ibrt\_if\_prepare\_sync\_info(void)

For the usage of related interfaces, see [5.2.2.7.](#br172)

1. ` `Fill TWS information into the pending sync list.

void app\_ibrt\_if\_sync\_info(TWS\_SYNC\_USER\_E id)

**Table 39 app\_ibrt\_if\_sync\_info Parameters**

**Parameter Description**

id User id for tws information filling

For the usage of related interfaces, see [5.2.2.7.](#br172)

Rev 1.2 Page153 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.181.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.180.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.180.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

1. ` `Flush pending TWS sync information to a peer device.

void app\_ibrt\_if\_flush\_sync\_info(void)

For the usage of related interfaces, see [5.2.2.7.](#br172)

1. ` `Request a specific TWS bandwidth for a user.

void app\_ibrt\_if\_request\_modify\_tws\_bandwidth (TWS\_TIMING\_CONTROL\_USER\_E

user, bool enable)

**Table 40 app\_ibrt\_if\_request\_modify\_tws\_bandwidth Parameters**

**Parameter Description**

user User id

enable true(request)/false(release)

For the usage of related interfaces, see [5.2.2.9.](#br176)

1. ` `Write a local BT address into factory section and activate it.

void app\_ibrt\_if\_write\_bt\_local\_address(uint8\_t\* btAddr)

**Table 41 app\_ibrt\_if\_write\_bt\_local\_address Parameters**

**Parameter Description**

btAddr User id for tws information filling

For the usage of related interfaces, see [5.2.2.1.](#br146)

1. ` `Get a local BT address.

uint8\_t\* app\_ibrt\_if\_get\_bt\_local\_address(void)

For the usage of related interfaces, see [5.2.2.1.](#br146)

1. ` `Get a peer BT address.

uint8\_t\* app\_ibrt\_if\_get\_bt\_peer\_address (void)

For the usage of related interfaces, see [5.2.2.1.](#br146)

1. ` `Write a local TWS role and peer device BT address. The TWS pairing won’t be started.

void app\_ibrt\_if\_update\_tws\_pairing\_info(ibrt\_role\_e role, uint8\_t\*

peerAddr)

**Table 42 app\_ibrt\_if\_update\_tws\_pairing\_info Parameters**

Rev 1.2 Page154 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.182.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.183.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.180.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)*Software Development User Guide*

**Parameter Description**

Role The tws role to update

peerAddr The peer device bt address to update

For the usage of related interfaces, see [5.2.2.4.](#br159)

1. ` `Write a local TWS role and peer device BT address. The TWS pairing is immediately started

void app\_ibrt\_if\_start\_tws\_pairing(ibrt\_role\_e role, uint8\_t\* peerAddr)

**Table 43 app\_ibrt\_if\_start\_tws\_pairing Parameters**

**Parameter Description**

Role The tws role to update

peerAddr The peer device bt address to update

For the usage of related interfaces, see [5.2.2.4.](#br159)

1. ` `**Parameter Structure Description**

\- bt\_bdaddr\_t

/\* Bluetooth Device Address \*/

typedef struct {

uint8\_t address[6];

} \_\_attribute\_\_ ((packed)) bt\_bdaddr\_t;

\- AppIbrtA2dpState

/\* A2DP State \*/

typedef enum {

APP\_IBRT\_IF\_A2DP\_IDLE = 0,

APP\_IBRT\_IF\_A2DP\_CODEC\_CONFIGURED = 1,

APP\_IBRT\_IF\_A2DP\_OPEN = 2,

APP\_IBRT\_IF\_A2DP\_STREAMING = 3,

APP\_IBRT\_IF\_A2DP\_CLOSED = 4,

}AppIbrtA2dpState;

\- AppIbrtAvrcpState

/\* AVRCP State \*/

typedef enum {

APP\_IBRT\_IF\_AVRCP\_DISCONNECTED = 0,

APP\_IBRT\_IF\_AVRCP\_CONNECTED = 1,

Rev 1.2 Page155 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.184.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.057.jpeg)*Software Development User Guide*

APP\_IBRT\_IF\_AVRCP\_PLAYING = 2,

APP\_IBRT\_IF\_AVRCP\_PAUSED = 3,

APP\_IBRT\_IF\_AVRCP\_VOLUME\_UPDATED = 4,

}AppIbrtAvrcpState;

\- AppIbrtHfpState

/\* HFP State \*/

Typedef enum {

APP\_IBRT\_IF\_HFP\_SLC\_DISCONNECTED = 0,

APP\_IBRT\_IF\_HFP\_CLOSED = 1,

APP\_IBRT\_IF\_HFP\_SCO\_CLOSED = 2,

APP\_IBRT\_IF\_HFP\_PENDING = 3,

APP\_IBRT\_IF\_HFP\_SLC\_OPEN = 4,

APP\_IBRT\_IF\_HFP\_NEGOTIATE = 5,

APP\_IBRT\_IF\_HFP\_CODEC\_CONFIGURED = 6,

APP\_IBRT\_IF\_HFP\_SCO\_OPEN = 7,

APP\_IBRT\_IF\_HFP\_INCOMING\_CALL = 8,

APP\_IBRT\_IF\_HFP\_OUTGOING\_CALL = 9,

APP\_IBRT\_IF\_HFP\_RING\_INDICATION = 10,

} AppIbrtHfpState;

\- AppIbrtCallStatus

/\* CALL Status \*/

typedef enum {

APP\_IBRT\_IF\_NO\_CALL = 0,

APP\_IBRT\_IF\_CALL\_ACTIVE = 1,

APP\_IBRT\_IF\_HOLD = 2,

APP\_IBRT\_IF\_SETUP\_INCOMMING = 3,

APP\_IBRT\_IF\_SETUP\_OUTGOING = 4,

APP\_IBRT\_IF\_SETUP\_ALERT = 5,

} AppIbrtCallStatus;

\- nvrec\_btdevicerecord

/\* Bluetooth Device info record \*/

typedef struct {

btif\_device\_record\_t record;

btdevice\_volume device\_vol;

btdevice\_profile device\_plf;

#ifdef BTIF\_DIP\_DEVICE

Rev 1.2 Page156 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.185.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.037.jpeg)*Software Development User Guide*

uint16\_t vend\_id;

uint16\_t vend\_id\_source;

uint16\_t reserve;

#endif

} nvrec\_btdevicerecord;

\- ibrt\_post\_func

/\* Callback Function \*/

typedef void (\*ibrt\_post\_func)(void);

\- APP\_TWS\_SIDE\_T

/\* Earbuds Side \*/

typedef enum {

EAR\_SIDE\_UNKNOWN = 0,

EAR\_SIDE\_LEFT = 1,

EAR\_SIDE\_RIGHT = 2,

EAR\_SIDE\_NUM,

} APP\_TWS\_SIDE\_T;

\- TWS\_SYNC\_USER\_T

/\* Functions used to handle tws information sync\*/

typedef struct {

TWS\_SYNC\_INFO\_PREPARE\_FUNC\_T sync\_info\_prepare\_handler;

TWS\_INFO\_SYNC\_FUNC\_T sync\_info\_received\_handler;

TWS\_SYNC\_INFO\_PREPARE\_FUNC\_T sync\_info\_prepare\_rsp\_handler;

TWS\_INFO\_SYNC\_FUNC\_T sync\_info\_rsp\_received\_handler;

TWS\_INFO\_SYNC\_FUNC\_T sync\_info\_rsp\_timeout\_handler;

} TWS\_SYNC\_USER\_T;

\- TWS\_SYNC\_USER\_E

/\* Users need sync tws information \*/

typedef enum {

TWS\_SYNC\_USER\_BLE\_INFO = 0,

TWS\_SYNC\_USER\_OTA = 1,

TWS\_SYNC\_USER\_AI\_CONNECTION = 2,

TWS\_SYNC\_USER\_GFPS\_INFO = 3,

TWS\_SYNC\_USER\_AI\_INFO = 4,

TWS\_SYNC\_USER\_AI\_MANAGER = 5,

TWS\_SYNC\_USER\_DIP = 6,

Rev 1.2 Page157 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.186.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

TWS\_SYNC\_USER\_NUM,

} TWS\_SYNC\_USER\_E;

\- TWS\_TIMING\_CONTROL\_USER\_E

/\* Users of the tws timing control \*/

typedef enum

{

TWS\_TIMING\_CONTROL\_USER\_SNIFF = 0,

TWS\_TIMING\_CONTROL\_USER\_OTA,

TWS\_TIMING\_CONTROL\_USER\_AI\_VOICE,

TWS\_TIMING\_CONTROL\_USER\_DEFAULT,

TWS\_TIMING\_CONTROL\_USER\_START\_IBRT,

TWS\_TIMING\_CONTROL\_USER\_RESERVE1,

TWS\_TIMING\_CONTROL\_USER\_NUM,

} TWS\_TIMING\_CONTROL\_USER\_E;

\- ibrt\_role\_e

/\* TWS role \*/

typedef uint8\_t ibrt\_role\_e;

#define IBRT\_MASTER 0

#define IBRT\_SLAVE 1

#define IBRT\_UNKNOW 0xff

1. ` `**Return Value Description**

\- ApplbrtStatus

typedef enum {

APP\_IBRT\_IF\_STATUS\_SUCCESS = 0,

APP\_IBRT\_IF\_STATUS\_PENDING = 1,

APP\_IBRT\_IF\_STATUS\_ERROR\_INVALID\_PARAMETERS = 2,

APP\_IBRT\_IF\_STATUS\_ERROR\_NO\_CONNECTION = 3,

APP\_IBRT\_IF\_STATUS\_ERROR\_CONNECTION\_EXISTS = 4,

APP\_IBRT\_IF\_STATUS\_IN\_PROGRESS = 5,

APP\_IBRT\_IF\_STATUS\_ERROR\_DUPLICATE\_REQUEST = 6,

APP\_IBRT\_IF\_STATUS\_ERROR\_INVALID\_STATE = 7,

APP\_IBRT\_IF\_STATUS\_ERROR\_TIMEOUT = 8,

APP\_IBRT\_IF\_STATUS\_ERROR\_ROLE\_SWITCH\_FAILED = 9,

APP\_IBRT\_IF\_STATUS\_ERROR\_UNEXPECTED\_VALUE = 10,

APP\_IBRT\_IF\_STATUS\_ERROR\_OP\_NOT\_ALLOWED = 11,

Rev 1.2 Page158 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.187.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

} AppIbrtStatus;

\- ibrt\_status\_t

typedef enum {

IBRT\_STATUS\_SUCCESS = 0,

IBRT\_STATUS\_PENDING = 1,

IBRT\_STATUS\_ERROR\_INVALID\_PARAMETERS = 2,

IBRT\_STATUS\_ERROR\_NO\_CONNECTION = 3,

IBRT\_STATUS\_ERROR\_CONNECTION\_EXISTS = 4,

IBRT\_STATUS\_IN\_PROGRESS = 5,

IBRT\_STATUS\_ERROR\_DUPLICATE\_REQUEST = 6,

IBRT\_STATUS\_ERROR\_INVALID\_STATE = 7,

IBRT\_STATUS\_ERROR\_TIMEOUT = 8,

IBRT\_STATUS\_ERROR\_ROLE\_SWITCH\_FAILED = 9,

IBRT\_STATUS\_ERROR\_UNEXPECTED\_VALUE = 10,

IBRT\_STATUS\_ERROR\_OP\_NOT\_ALLOWED = 11,

IBRT\_STATUS\_VENDOR\_START = 0x80,

} ibrt\_status\_t;

\- TWS\_UI\_ROLE\_E

TWS\_UI\_MASTER 0

TWS\_UI\_SLAVE 1

TWS\_UI\_UNKNOWN 0xff

\- TWS\_SYNC\_FILL\_RET\_E

typedef enum

{

TWS\_SYNC\_CONTINUE\_FILLING = 0,

TWS\_SYNC\_BUF\_FULL = 1,

TWS\_SYNC\_NO\_DATA\_FILLED = 3

} TWS\_SYNC\_FILL\_RET\_E;

1. ` `**Custom UI Usage**
1. ` `Call IBRT APIs that are defined in the common API List.
1. ` `Register a callback handler list to receive the Bluetooth events distributed from the custom UX layer of the SDK:

void app\_custom\_ux\_register\_callback(ibrt\_core\_status\_changed\_cb\_t \*cb)

**Table 44 Ibrt\_core\_status\_changed\_cb\_t Description**

Rev 1.2 Page159 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.188.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.189.jpeg)*Software Development User Guide*

**Item Description**

void (\*global\_state\_changed)(ibrt\_global\_state\_change\_event \*state);

void (\*a2dp\_state\_changed)(const bt\_bdaddr\_t \*addr, ibrt\_conn\_a2dp\_state\_change

\*state);

void (\*hfp\_state\_changed)(const bt\_bdaddr\_t \*addr, ibrt\_conn\_hfp\_state\_change

\*state);

void (\*avrcp\_state\_changed)(const bt\_bdaddr\_t \*addr, ibrt\_conn\_avrcp\_state\_change

\*state);

void (\*tws\_acl\_state\_changed)(ibrt\_conn\_tws\_conn\_state\_event \*state, uint8\_t

reason\_code);

||ibrt\_core\_status\_ch||<p>void (\*mobile\_acl\_state\_changed)(const bt\_bdaddr\_t \*addr,</p><p>ibrt\_mobile\_conn\_state\_event \*state, uint8\_t reason\_code);</p>|
| :- | :- | :- | :- |
anged\_cb\_t

void (\*tws\_role\_switch\_status\_ind)(const bt\_bdaddr\_t \*addr,

ibrt\_conn\_role\_change\_state state, ibrt\_role\_e role);

void (\*access\_mode\_changed)(btif\_accessible\_mode\_t newAccessMode);

ibrt\_conn\_req\_rsp\_t (\*incoming\_connect\_request\_response\_cb)(void);

void (\*sco\_disconnect\_cb)(const bt\_bdaddr\_t \*addr, uint8\_t reason\_code);

void (\*dip\_info\_queried\_cb)(uint8\_t \*remote\_addr, bt\_dip\_pnp\_info\_t \*pnp\_info);

void (\*bsir\_event\_cb)(uint8\_t is\_in\_band\_ring);

1. ` `How to configure TWS pairing for the custom UI.

\- Write a local TWS role and peer device BT address. The TWS pairing won’t be started.

void app\_ibrt\_if\_update\_tws\_pairing\_info(ibrt\_role\_e role, uint8\_t\*

peerAddr);

**Table 45 app\_ibrt\_if\_update\_tws\_pairing\_info Parameters**

**Parameter Description**

Role The tws role to update

peerAddr The peer device bt address to update

\- Write a local TWS role and peer device BT address. The TWS pairing is immediately started.

void app\_ibrt\_if\_start\_tws\_pairing(ibrt\_role\_e role, uint8\_t\* peerAddr);

**Table 46 app\_ibrt\_if\_start\_tws\_pairing Parameters**

**Parameter Description**

Rev 1.2 Page160 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.190.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.191.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.192.jpeg)*Software Development User Guide*

Role The tws role to update

peerAddr The peer device bt address to update

**Sample Code 38: Simple Pairing Test**

{"slave\_update\_tws\_pair", app\_slave\_update\_tws\_pair\_info\_test},

{"master\_update\_tws\_pair", app\_master\_update\_tws\_pair\_info\_test},

{"master\_start\_tws\_pair", app\_master\_start\_tws\_pairing\_test},

{"slave\_start\_tws\_pair", app\_slave\_start\_tws\_pairing\_test}

1. ` `**BES UI Usage**
1. ` `**TWS Role’s Judgment Strategy**

nv-role: Not changed.

bt-role: During a BT connection, the device that initiates the connection is the master, and the device that is connected

is the slave. In the connected state, no change occurs.

ibrt-role: In IBRT, the device that actually connects to the mobile phone is the master, and the device that listens is the

slave. The master and slave are changed in the following events.

\- When the master earphone is inserted into the box, the external slave earphone becomes the master.

\- The master earphone signal is bad, the slave earphone becomes the master.

\- The power level of the left and right earphone is unbalanced, and the master-slave transmission is switched.

\- Events defined by the customers.

ui-role: It is consistent with IBRT-role, except the case that both earphones are masters when they are not connected.

1. ` `**API List**

\- Interface to enter the event:

void app\_ibrt\_if\_event\_entry(ibrt\_mgr\_evt\_t event)

**Table 47 app\_ibrt\_if\_event\_entry Description**

**Item Description Notes**

IBRT\_MGR\_EV\_CASE\_OPEN Open box

IBRT\_MGR\_EV\_UNDOCK Fetch out box

ibrt\_mgr\_evt\_t

IBRT\_MGR\_EV\_DOCK Put in box

IBRT\_MGR\_EV\_CASE\_CLOSE Close box

Rev 1.2 Page161 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.193.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.194.jpeg)*Software Development User Guide*

IBRT\_MGR\_EV\_WEAR\_UP Wear up

IBRT\_MGR\_EV\_TWS\_PAIRING Tws pairing

||<p>IBRT\_MGR\_EV\_FREE\_MAN\_MOD</p><p>E</p>||Free man mode|
| :- | :- | :- | :- |
\- Interface to enter the event freeman mode:

void app\_ibrt\_if\_test\_enter\_freeman(void)

\- Interface to dump info:

void app\_ibrt\_if\_dump\_ibrt\_mgr\_info()

\- Custom TWS switch interface:

void app\_ibrt\_customif\_ui\_tws\_switch(void)

\- Custom TWS switching check interface. Checks whether the TWS switch is performing now, and returns true or

false.

bool app\_ibrt\_customif\_ui\_is\_tws\_switching(void)

\- Callback for the BES UI:

void

app\_ibrt\_if\_register\_client\_callback(APP\_IBRT\_IF\_LINK\_STATUS\_CHANGED\_CALLBA

CK\* cbs)

{

client\_cb = cbs;

}

typedef ibrt\_link\_status\_changed\_cb\_t

APP\_IBRT\_IF\_LINK\_STATUS\_CHANGED\_CALLBACK;

**Table 48 ibrt\_core\_status\_changed\_cb\_t Description**

**Item Description**

void (\*ibrt\_global\_state\_changed)(ibrt\_global\_state\_change\_event \*state);

void (\*ibrt\_a2dp\_state\_changed)(const bt\_bdaddr\_t\* addr,

||<p>ibrt\_link\_status\_ch</p><p>anged\_cb\_t</p>||<p>ibrt\_conn\_a2dp\_state\_change \*state);</p><p>void (\*ibrt\_hfp\_state\_changed)(const bt\_bdaddr\_t\* addr, ibrt\_conn\_hfp\_state\_change</p><p>\*state);</p>|
| :- | :- | :- | :- |
void (\*ibrt\_avrcp\_state\_changed)(const bt\_bdaddr\_t \*addr,

ibrt\_conn\_avrcp\_state\_change \*state);

Rev 1.2 Page162 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.195.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

void (\*ibrt\_tws\_pairing\_changed)(ibrt\_conn\_pairing\_state state,uint8\_t reason\_code);

void (\*ibrt\_tws\_acl\_state\_changed)(ibrt\_conn\_tws\_conn\_state\_event \*state,uint8\_t

reason\_code);

void (\*ibrt\_mobile\_acl\_state\_changed)(const bt\_bdaddr\_t \*addr,

ibrt\_mobile\_conn\_state\_event \*state, uint8\_t reason\_code);

void (\*ibrt\_sco\_state\_changed)(const bt\_bdaddr\_t \*addr, ibrt\_sco\_conn\_state\_event

\*state,uint8\_t reason\_code);

void (\*ibrt\_tws\_role\_switch\_status\_ind)(const bt\_bdaddr\_t

\*addr,ibrt\_conn\_role\_change\_state state,ibrt\_role\_e role);

void (\*ibrt\_ibrt\_state\_changed)(const bt\_bdaddr\_t \*addr, ibrt\_connection\_state\_event\*

state, ibrt\_role\_e role,uint8\_t reason\_code);

void (\*ibrt\_access\_mode\_changed)(btif\_accessible\_mode\_t newAccessMode);

**Sample Code 39: BES UI Usage**

{"open\_box\_event\_test",app\_ibrt\_if\_event\_entry\_open\_box\_test},

{"fetch\_out\_box\_event\_test",app\_ibrt\_if\_event\_entry\_fetch\_out\_box\_test},

{"put\_in\_box\_event\_test",app\_ibrt\_if\_event\_entry\_put\_in\_box\_test},

{"close\_box\_event\_test",app\_ibrt\_if\_event\_entry\_close\_box\_test},

{"wear\_up\_event\_test",app\_ibrt\_if\_event\_entry\_wear\_up\_test},

{"wear\_down\_event\_test",app\_ibrt\_if\_event\_entry\_wear\_down\_test},

{"pairing\_mode\_test",app\_ibrt\_if\_pairing\_mode\_test},

{"free\_man\_test",app\_ibrt\_if\_event\_entry\_freeman\_test},

{"dump\_mgr\_info\_test",app\_ibrt\_if\_event\_entry\_dump\_info\_test},

{"ui\_tws\_switch",app\_ibrt\_customif\_ui\_tws\_switch\_test},

{"check\_ui\_tws\_switch",app\_ibrt\_customif\_ui\_is\_tws\_switching\_test},

{"register\_client\_callback",app\_ibrt\_if\_register\_client\_callback\_test},

1. ` `**BES UI Property Configuration**

**Key functions for calls:**

**app\_ibrt\_customif\_ui\_start -> ibrt\_mgr\_config\_t**

Rev 1.2 Page163 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.196.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Table 49 BES UI Property Configuration**

**Item Description**

bool freeman\_enable freeman mode config, default should be false.

bool tws\_use\_same\_addr tws earphone set the same addr, UI will be flexible,

default should be true

bool wear\_updown\_tws\_switch\_enable ibrt slave will reconnect to mobile if tws connect

failed, default should be true

bool slave\_reconnect\_enable do tws switch when wearup or weardown, must be

true because MIC will be with IBRT master

bool enter\_pairing\_mode pairing mode default value, default should be set false

bool freeman\_accept\_mobile\_new\_pairing following cases the reconnect will be fail for freeman,

please set to true if you want to reconnect successful:

1. ` `freeman has link key but mobile deleted the

link key

1. ` `freeman changed its bt address after reboot

and use the new address to reconnect mobile

bool enter\_pairing\_on\_empty\_mobile\_addr for some proj no box key, default should be false;

bool enter\_pairing\_on\_reconnect\_mobile\_failed for some proj no box key, default should be false

bool enter\_pairing\_on\_reconnect\_mobile\_failed\_once when mobile has connected,

enter\_pairing\_on\_reconnect\_mobile\_failed will be

cleared, default false

bool enter\_pairing\_on\_mobile\_disconnect for some proj no box key, default should be false

bool check\_plugin\_excute\_closedbox\_event; default should be true

bool disc\_tws\_before\_reconnect\_mobile; for 08 error reconnect event, default must be true

bool snoop\_via\_ble\_enable; exchange snoop info by BLE\_box, special custom

config, default should be false

bool tws\_switch\_according\_to\_rssi\_value; do tws switch when RSII value change, default should

be true

bool tws\_switch\_according\_to\_noise\_value; do tws switch when noise value change, default

should be true

bool disable\_tws\_switch; disable tws switch, NOT recommended to open

bool disable\_stop\_ibrt; disable tws switch, NOT recommended to open

bool lowlayer\_monitor\_enable; controller baseband monitor

bool delay\_exit\_sniff; default should be false

bool share\_tws\_info\_done; default should be false

uint32\_t delay\_ms\_exit\_sniff; default should be 3000

bool mobile\_incoming\_filter\_unpaired; only allow paired mobile device incoming when not in

paring mode, default should be false

Rev 1.2 Page164 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.197.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

uint8\_t rssi\_threshold; do tws switch when rssi value change over threshold.

default should be 10dm.

#define

IBRT\_UI\_ROLE\_SWITCH\_THRESHOLD\_WITH\_RSSI

(10) //dbm

int32\_t noise\_count\_threshold; do tws switch when noise count value change over

threshold.

#define

IBRT\_UI\_ROLE\_SWITCH\_THRESHOLD\_WITH\_NOISE\_C

OUNT (2) //times

uint8\_t role\_switch\_timer\_threshold; do tws switch when RSII value change, timer threshold

#define IBRT\_UI\_ROLE\_SWITCH\_TIME\_THRESHOLD

(2) //

uint8\_t noise\_role\_switch\_timer\_threshold;

uint16\_t close\_box\_event\_wait\_response\_timeout; close box debounce time config

#define

IBRT\_UI\_CLOSE\_BOX\_EVENT\_WAIT\_RESPONSE\_TIME

OUT (600)//ms

uint16\_t reconnect\_wait\_ready\_timeout; reconnect event internal config wait timer when tws

disconnect

#define

IBRT\_UI\_MOBILE\_RECONNECT\_WAIT\_READY\_TIMEOU

T (1000)//ms

uint16\_t reconnect\_mobile\_wait\_ready\_timeout; reconnect event internal config wait timer when tws

disconnect

#define

IBRT\_UI\_MOBILE\_RECONNECT\_WAIT\_READY\_TIMEOU

T (1000)//ms

uint16\_t reconnect\_tws\_wait\_ready\_timeout; reconnect event internal config wait timer when tws

disconnect

#define

IBRT\_UI\_TWS\_RECONNECT\_WAIT\_READY\_TIMEOUT

(1500)//ms

uint16\_t reconnect\_mobile\_wait\_response\_timeout; wait time before launch reconnect event

#define

IBRT\_UI\_RECONNECT\_MOBILE\_WAIT\_RESPONSE\_TIM

EOUT (5000)//5s

uint16\_t reconnect\_ibrt\_wait\_response\_timeout; #define

IBRT\_UI\_RECONNECT\_IBRT\_WAIT\_RESPONSE\_TIMEO

Rev 1.2 Page165 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.198.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

UT (300)//ms

uint16\_t #define

nv\_master\_reconnect\_tws\_wait\_response\_timeout; IBRT\_UI\_NV\_MASTER\_RECONNECT\_TWS\_WAIT\_RESP

ONSE\_TIMEOUT (300)//ms

uint16\_t #define

nv\_slave\_reconnect\_tws\_wait\_response\_timeout; IBRT\_UI\_NV\_SLAVE\_RECONNECT\_TWS\_WAIT\_RESPO

NSE\_TIMEOUT (1000)//ms

uint32\_t disable\_bt\_scan\_timeout; pairing mode timeout config

#define IBRT\_UI\_DISABLE\_BT\_SCAN\_TIMEOUT

(150000)//5min

uint16\_t open\_reconnect\_mobile\_max\_times; open box reconnect mobile times config

#define

IBRT\_UI\_OPEN\_RECONNECT\_MOBILE\_MAX\_TIMES

(0)

uint16\_t open\_reconnect\_tws\_max\_times; open box reconnect tws times config

#define

IBRT\_UI\_OPEN\_RECONNECT\_TWS\_MAX\_TIMES

(1)

uint16\_t reconnect\_mobile\_max\_times; open box reconnect mobile times config

#define

IBRT\_UI\_OPEN\_RECONNECT\_MOBILE\_MAX\_TIMES

(0)

uint16\_t reconnect\_tws\_max\_times; open box reconnect tws times config

#define

IBRT\_UI\_OPEN\_RECONNECT\_TWS\_MAX\_TIMES

(1)

uint16\_t reconnect\_ibrt\_max\_times; connection timeout reconnect ibrt times config

#define IBRT\_UI\_RECONNECT\_IBRT\_MAX\_TIMES

(1)

uint8\_t tws\_reconnect\_cycle; reconnect tws one cycle

#define IBRT\_TWS\_RECONNECT\_ONE\_CYCLE

(3)

uint8\_t mobile\_reconnect\_cycle; reconnect mobile one cycle

#define IBRT\_MOBILE\_RECONNECT\_ONE\_CYCLE

(5)

uint16\_t default\_bt\_tpoll; Default polling time

#define IBRT\_TWS\_BT\_TPOLL\_DEFAULT

(80)

uint16\_t tws\_page\_timeout\_on\_last\_success; for fast connect when only one headset in the nearby

Rev 1.2 Page166 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.199.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

#define

IBRT\_TWS\_PAGE\_TIMEOUT\_ON\_CONNECT\_SUCCESS\_

LAST (0x2000)

uint16\_t tws\_page\_timeout\_on\_last\_failed; #define

IBRT\_TWS\_PAGE\_TIMEOUT\_ON\_CONNECT\_FAILED\_L

AST (0x2000)

uint16\_t #define

tws\_page\_timeout\_on\_reconnect\_mobile\_success; IBRT\_TWS\_PAGE\_TIMEOUT\_ON\_RECONNECT\_MOBIL

E\_SUCCESS (0x2000)

uint16\_t #define

tws\_page\_timeout\_on\_reconnect\_mobile\_failed; IBRT\_TWS\_PAGE\_TIMEOUT\_ON\_RECONNECT\_MOBIL

E\_FAILED (0x2000)

uint16\_t mobile\_page\_timeout; #define IBRT\_MOBILE\_PAGE\_TIMEOUT

(0x2000)

uint16\_t tws\_connection\_timeout; tws connection timeout

#define IBRT\_UI\_TWS\_CONNECTION\_TIMEOUT

(3200)//1600 slot=1s/3200 slot = 2s/8000slot=5s

uint8\_t profile\_concurrency\_supported; false

uint8\_t connect\_new\_mobile\_enable;

uint16\_t wait\_time\_before\_disc\_tws; 3000

bt\_bdaddr\_t new\_mobile\_address;

uint32\_t rx\_seq\_error\_timeout; #define IBRT\_UI\_RX\_SEQ\_ERROR\_TIMEOUT

(10000)

uint32\_t rx\_seq\_error\_threshold; define IBRT\_UI\_RX\_SEQ\_ERROR\_THRESHOLD

(50)

uint32\_t rx\_seq\_recover\_wait\_timeout; #define

IBRT\_UI\_RX\_SEQ\_ERROR\_RECOVER\_TIMEOUT

(5000)

uint32\_t rssi\_monitor\_timeout; #ifdef TEST\_OVER\_THE\_AIR\_ENANBLED

#define IBRT\_UI\_RSSI\_MONITOR\_TIMEOUT

(1000)//ms

#else

#define IBRT\_UI\_RSSI\_MONITOR\_TIMEOUT

(5000)//ms

uint32\_t noise\_monitor\_timeout; #define IBRT\_UI\_NOISE\_MONITOR\_TIMEOUT

(1000)//ms

bool wear\_updown\_detect\_supported; false

uint32\_t stop\_ibrt\_timeout; #define IBRT\_UI\_STOP\_IBRT\_TIMEOUT

(3000000)//40min

Rev 1.2 Page167 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.200.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

uint16\_t radical\_scan\_interval\_nv\_slave; #define BTIF\_BT\_DEFAULT\_PAGE\_SCAN\_INTERVAL

0x800

#define

IBRT\_UI\_RADICAL\_SAN\_INTERVAL\_NV\_SLAVE

((BTIF\_BT\_DEFAULT\_PAGE\_SCAN\_INTERVAL/4)-0x48)

uint16\_t radical\_scan\_interval\_nv\_master; #define BTIF\_BT\_DEFAULT\_PAGE\_SCAN\_INTERVAL

0x800

#define

IBRT\_UI\_RADICAL\_SAN\_INTERVAL\_NV\_MASTER

(BTIF\_BT\_DEFAULT\_PAGE\_SCAN\_INTERVAL/4)

uint32\_t event\_hung\_timeout; #define IBRT\_EVENT\_HUNG\_TIMEOUT

(200)//ms

uint16\_t rssi\_tws\_switch\_threshold; #define IBRT\_TWS\_SWITCH\_RSSI\_THRESHOLD

(30)

uint32\_t stop\_ibrt\_wait\_time\_after\_tws\_switch; #define IBRT\_STOP\_IBRT\_WAIT\_TIME

(500)

uint32\_t tws\_conn\_failed\_wait\_time; #define TWS\_CONN\_FAILED\_WAIT\_TIME

(5)

uint32\_t sm\_running\_timeout;

uint32\_t peer\_sm\_running\_timeout; #define SM\_RUNNING\_TIMEOUT

(20000)

uint32\_t connect\_no\_03\_timeout; #define CONNECT\_NO\_03\_TIMEOUT

(15000)

uint32\_t disconnect\_no\_05\_timeout; #define DISCONNECT\_NO\_05\_TIMEOUT

(8000)

uint32\_t reconnect\_peer\_sm\_running\_timeout; #define IBRT\_UI\_RECONNECT\_MOBILE\_MAX\_TIMES

(20)

#define

IBRT\_UI\_RECONNECT\_MOBILE\_WAIT\_RESPONSE\_TIM

EOUT (5000)//5s

#define

RECONNECT\_PEER\_SM\_RUNNING\_TIMEOUT

(2\*(IBRT\_UI\_RECONNECT\_MOBILE\_MAX\_TIMES \*

(IBRT\_UI\_RECONNECT\_MOBILE\_WAIT\_RESPONSE\_TI

MEOUT+5000)))

#define CONNECT\_NO\_03\_TIMEOUT

(15000)

bool tws\_switch\_tx\_data\_protect; true

uint32\_t tws\_cmd\_send\_timeout; #define IBRT\_UI\_TWS\_CMD\_SEND\_TIMEOUT

Rev 1.2 Page168 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.201.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

(10000)

uint32\_t tws\_cmd\_send\_counter\_threshold; #define IBRT\_UI\_TWS\_CMD\_SEND\_TIMEOUT

(10000)

uint32\_t tws\_switch\_stable\_timeout; #define IBRT\_UI\_TWS\_SWITCH\_STABLE\_TIMEOUT

(300)

bool invoke\_event\_when\_box\_closed; true

uint8\_t audio\_sync\_mismatch\_resume\_version; 2

uint8\_t llmonitor\_report\_format;

uint32\_t llmonitor\_report\_count;

1. ` `**Pairing Information Management**

\- Interface to get all paired BT link keys

bool app\_ibrt\_if\_get\_all\_paired\_bt\_link\_key(ibrt\_if\_paired\_bt\_link\_key\_info

\*linkKey)

typedef struct {

int pairedDevNum;

ibrt\_if\_link\_key\_info linkKey[MAX\_BT\_PAIRED\_DEVICE\_COUNT];

} ibrt\_if\_paired\_bt\_link\_key\_info;

typedef struct {

bt\_bdaddr\_t btAddr;

uint8\_t linkKey[16];

} ibrt\_if\_link\_key\_info;

typedef struct {

bt\_bdaddr\_t btAddr;

uint8\_t linkKey[16];

} ibrt\_if\_link\_key\_info;

\- Interface to delete all pairing records

void app\_ibrt\_nvrecord\_delete\_all\_bt\_pairing\_record(void)

\- Interface to delete all mobile records

void app\_ibrt\_nvrecord\_delete\_all\_mobile\_record(void);

\- Interface to record the paired mobile records to the NV

Rev 1.2 Page169 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.202.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

bt\_status\_t

app\_ibrt\_nvrecord\_get\_mobile\_paired\_dev\_list(nvrec\_btdevicerecord

\*nv\_record,uint8\_t \*count);

typedef struct {

btif\_device\_record\_t record;

btdevice\_volume device\_vol;

btdevice\_profile device\_plf;

#ifdef BTIF\_DIP\_DEVICE

bt\_dip\_pnp\_info\_t pnp\_info;

#endif

} nvrec\_btdevicerecord;

For the test cases of related interfaces, s[ee](#br148)[ ](#br148)[5.2.2.3.1(](#br148)[9-](#br150)[11)](#br151)

1. ` `**IBRT Role Switch**
1. ` `**Host Flow**

**Figure 43 Host Flow**

Rev 1.2 Page170 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.203.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Role Switch Preparation**

**Figure 44 Flow Path of Role Switch Preparation**

1. ` `**Role Switch Post Operation**

Rev 1.2 Page171 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.204.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.205.jpeg)*Software Development User Guide*

**Figure 45 Flow Path of Role Switch Post Operation**

1. ` `**Role Switch Controller Operation**

**Figure 46 Role Switch Controller Operation**

For the test cases of related interfaces, see 7.2.3.1 (7-8).

1. ` `**TWS Synchronization Interface Usage**

\- TWS information sync

Earbuds need to synchronize information with each other, and the different TWS information is defined into different

users, such as AI, BLE, and OTA. If you want to synchronize a new kind of information, you may need to add a user.

Take user “BLE”as an example, you can add a user by performing the following steps:

1. ` `Add “TWS\_SYNC\_USER\_BLE\_INFO”into TWS\_SYNC\_USER\_E;
1. ` `Implement the handling functions and fill them into TWS\_SYNC\_USER\_T, for example, the name is “userBle”;

**Table 50 TWS\_SYNC\_USER\_T Description**

**Item Description Notes**

sync\_info\_prepare\_handler Collect BLE information to be sent to a peer device

||TWS\_SYNC\_USER\_T||sync\_info\_received\_handler||<p>Process the received BLE sync information from the</p><p>peer device</p>|
| :- | :- | :- | :- | :- | :- |
Rev 1.2 Page172 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.206.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.207.jpeg)*Software Development User Guide*

sync\_info\_prepare\_rsp\_handler Prepare BLE information to reponse

sync\_info\_rsp\_received\_handler Process the received response from the peer device

sync\_info\_rsp\_timeout\_handler The response timeout handler

1. ` `Register a user and its handle function to the TWS information sync list by using

“app\_ibrt\_if\_register\_sync\_user(TWS\_SYNC\_USER\_BLE\_INFO, &userBle)”.

void app\_ble\_mode\_tws\_sync\_init(void)

{

TWS\_SYNC\_USER\_T userBle = {

ble\_sync\_info\_prepare\_handler,

ble\_sync\_info\_received\_handler,

ble\_sync\_info\_prepare\_handler,

ble\_sync\_info\_rsp\_received\_handler,

NULL,

};

app\_ibrt\_if\_register\_sync\_user(TWS\_SYNC\_USER\_BLE\_INFO, &userBle);

}

1. ` `Synchronize the TWS information of the BLE user.

Firstly, call “app\_ibrt\_if\_prepare\_sync\_info”to Initialize and make preparation for TWS synchronization;

Then, call “app\_ibrt\_if\_sync\_info”to fill TWS information into the pending sync list; The TWS sync information can

be filled at this stage.

Finally, call“app\_ibrt\_if\_flush\_sync\_info”to flush the pending TWS sync information to the peer device.

void app\_ble\_sync\_ble\_info(void)

{

app\_ibrt\_if\_prepare\_sync\_info();

app\_ibrt\_if\_sync\_info(TWS\_SYNC\_USER\_BLE\_INFO);

app\_ibrt\_if\_flush\_sync\_info();

}

#endif

1. ` `**Sniff and Active Mode Management**

The sniff mode saves power by reducing the number of time slots for the master device to send data and the

corresponding number of time slots for the slave device to listen. The sniff mode is mainly controlled by the BTC. You

can control the sniff mode by using the following interfaces.

Rev 1.2 Page173 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.208.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Prevent Entering Sniff Mode**

void app\_ibrt\_if\_prevent\_sniff\_set(uint8\_t \*p\_mobile\_addr, uint16\_t

prv\_sniff\_bit)

/// Definition of the bits preventing the BTC from enter sniff

enum app\_ibrt\_if\_prevent\_sniff

{

/// Flag indicating that the OTA process is ongoing

OTA\_ONGOING = 0x01,

/// Flag indicating that vocie record is ongoing

AI\_VOICE\_RECORD = 0x02,

/// Flag indicating that AVRCP status change is ongoing

AVRCP\_STATUS\_CHANING = 0x04,

};

1. ` `**Disabling ‘APP\_IBRT\_IF\_PREVENT\_SNIFF\_SET’**

void app\_ibrt\_if\_prevent\_sniff\_clear(uint8\_t \*p\_mobile\_addr, uint16\_t

prv\_sniff\_bit)

Next, take entering OTA mode as an example. When the system enters the OTA mode, exit the sniff mode and then

prevent the sniff mode.

static POSSIBLY\_UNUSED void Bes\_enter\_ota\_state(void)

{

LOG\_DBG(0,"%s state %d", \_\_func\_\_, isInBesOtaState);

if (isInBesOtaState)

{

return;

}

// 1. switch to the highest freq

app\_sysfreq\_req(APP\_SYSFREQ\_USER\_OTA, APP\_SYSFREQ\_104M);

// 2. exit bt sniff mode

#ifdef IBRT

app\_ibrt\_if\_request\_modify\_tws\_bandwidth(TWS\_TIMING\_CONTROL\_USER\_OTA,

true);

app\_tws\_ibrt\_exit\_sniff\_with\_tws();

#if defined(IBRT\_UI\_V1)

Rev 1.2 Page174 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.209.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

app\_ibrt\_if\_exit\_sniff\_with\_mobile();

#else

uint8\_t\* mobileAddr = ota\_basic\_get\_mac\_addr();

app\_ibrt\_if\_exit\_sniff\_with\_mobile(mobileAddr);

if (OTA\_BASIC\_SPP\_DATAPATH\_ENABLED == ota\_basic\_get\_datapath())

{

app\_ibrt\_if\_prevent\_sniff\_set(mobileAddr, OTA\_ONGOING);

}

#endif

When the system exits the OTA mode, cancel the mode of preventing the sniff.

void Bes\_exit\_ota\_state(void)

{

LOG\_DBG(0,"%s state %d", \_\_func\_\_, isInBesOtaState);

if (!isInBesOtaState)

{

return;

}

app\_sysfreq\_req(APP\_SYSFREQ\_USER\_OTA, APP\_SYSFREQ\_32K);

#ifdef IBRT

app\_ibrt\_if\_prevent\_sniff\_clear(ota\_basic\_get\_mac\_addr(), OTA\_ONGOING);

v

app\_ibrt\_if\_request\_modify\_tws\_bandwidth(TWS\_TIMING\_CONTROL\_USER\_OTA,

false);

#else

bes\_bt\_me->set\_stay\_active\_mode(false, BT\_ACTIVE\_MODE\_KEEP\_USER\_OTA,

UPDATE\_ACTIVE\_MODE\_FOR\_ALL\_LINKS);

#endif

#ifdef \_\_IAG\_BLE\_INCLUDE\_\_

bes\_ble\_me->ble\_update\_conn\_param\_mode(BLE\_CONN\_PARAM\_MODE\_OTA, false);

bes\_ble\_me->ble\_update\_conn\_param\_mode(BLE\_CONN\_PARAM\_MODE\_OTA\_SLOWER,

false);

#endif

**Sample Code 40: Sniff and Active Mode Management**

Rev 1.2 Page175 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.210.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.211.jpeg)*Software Development User Guide*

{"prevent\_sniff\_set",app\_ibrt\_if\_prevent\_sniff\_set\_test},

{"prevent\_sniff\_clear",app\_ibrt\_if\_prevent\_sniff\_clear\_test}

1. ` `**TWS Communication Bandwidth Update**

Different TWS bandwidths may be required based on scenarios. So different scenarios are defined as different users.

“app\_ibrt\_if\_request\_modify\_tws\_bandwidth”is implemented for request a specific TWS bandwidth for a user. When a

user requests or releases its TWS bandwidth, the TWS link’s bandwidth is adjusted.

#define app\_ibrt\_if\_request\_modify\_tws\_bandwidth

app\_tws\_ibrt\_request\_modify\_tws\_bandwidth

void app\_tws\_ibrt\_request\_modify\_tws\_bandwidth(TWS\_TIMING\_CONTROL\_USER\_E

user, bool enable)

**Table 51 app\_ibrt\_if\_request\_modify\_tws\_bandwidth Description**

**Item parameter Notes**

typedef enum

{

TWS\_TIMING\_CONTROL\_USER\_SNIFF = 0,

TWS\_TIMING\_CONTROL\_USER\_DEFAULT,

TWS\_TIMING\_CONTROL\_USER\_A2DP,

TWS\_TIMING\_CONTROL\_USER\_OTA,

||app\_ibrt\_if\_request\_modify\_tws\_||<p>TWS\_TIMING\_CONTROL\_U</p><p>SER\_E user</p>||<p>TWS\_TIMING\_CONTROL\_USER\_AI\_VOICE,</p><p>TWS\_TIMING\_CONTROL\_USER\_START\_IBRT</p><p>,</p>|
| :- | :- | :- | :- | :- | :- |
` `TWS\_TIMING\_CONTROL\_USER\_IBRT\_SWITbandwidth

CH,

TWS\_TIMING\_CONTROL\_USER\_FAST\_COM

MUNICATION,

TWS\_TIMING\_CONTROL\_USER\_NUM,

} TWS\_TIMING\_CONTROL\_USER\_E;

bool enable

static TWS\_TIMING\_CONTROL\_INFO\_T

tws\_timing\_info[TWS\_TIMING\_CONTROL\_USER\_NUM] =

{

Rev 1.2 Page176 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.212.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

{false, TWS\_LINK\_SNIFF\_DURATION, TWS\_LINK\_SNIFF\_POLL\_INTERVAL,

TWS\_LINK\_SNIFF\_POLL\_INTERVAL\_IN\_SCO}, //SNIFF

{false, IBRT\_TWS\_LINK\_DEFAULT\_DURATION,

IBRT\_UI\_DEFAULT\_POLL\_INTERVAL, IBRT\_UI\_DEFAULT\_POLL\_INTERVAL\_IN\_SCO},

//DEFAULT

{false, TWS\_LINK\_A2DP\_DURATION, IBRT\_UI\_DEFAULT\_POLL\_INTERVAL,

IBRT\_UI\_DEFAULT\_POLL\_INTERVAL\_IN\_SCO}, //A2DP,

{false, TWS\_LINK\_OTA\_DURATION, TWS\_LINK\_OTA\_POLL\_INTERVAL,

TWS\_LINK\_OTA\_POLL\_INTERVAL\_IN\_SCO}, //OTA

{false, TWS\_LINK\_AI\_DURATION, TWS\_LINK\_AI\_POLL\_INTERVAL,

TWS\_LINK\_AI\_POLL\_INTERVAL\_IN\_SCO}, //AI\_VOICE

{false, TWS\_LINK\_START\_IBRT\_DURATION, TWS\_LINK\_START\_IBRT\_INTERVAL,

TWS\_LINK\_START\_IBRT\_INTERVAL\_IN\_SCO}, //START\_IBRT

{false, TWS\_LINK\_ROLE\_SWITCH\_DURATION,

IBRT\_UI\_DEFAULT\_POLL\_INTERVAL, IBRT\_UI\_DEFAULT\_POLL\_INTERVAL\_IN\_SCO},

//IBRT\_SWITCH,

};

typedef struct

{

bool timing\_enable;

uint8\_t acl\_slot\_num;

uint16\_t acl\_interval;

uint16\_t acl\_interval\_in\_sco;

} TWS\_TIMING\_CONTROL\_INFO\_T;

This function is called when the initialization state or Bluetooth state changes.

\- App\_ibrt\_init

void app\_ibrt\_init(void)

Rev 1.2 Page177 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.213.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

{

if (bes\_bt\_me->bes\_cfg\_get(BT\_BES\_CFG\_BT\_SINK\_ENABLED))

{

bes\_bt\_me->bt\_global\_handle\_init();

#if defined(IBRT)

ibrt\_config\_t config;

app\_tws\_ibrt\_init();

app\_tws\_ibrt\_init\_default\_tws\_bandwidth\_config(

IBRT\_TWS\_LINK\_DEFAULT\_DURATION,

IBRT\_UI\_DEFAULT\_POLL\_INTERVAL,

IBRT\_UI\_DEFAULT\_POLL\_INTERVAL\_IN\_SCO);

app\_tws\_ibrt\_request\_modify\_tws\_bandwidth(TWS\_TIMING\_CONTROL\_USER\_DEFAULT,

v

true);

#if defined(IBRT\_UI\_V1)

app\_ibrt\_ui\_init();

app\_ibrt\_ui\_test\_init();

app\_ibrt\_if\_config\_load(&config);

app\_ibrt\_customif\_ui\_start();

#ifdef IBRT\_SEARCH\_UI

app\_tws\_ibrt\_start(&config, true);

app\_ibrt\_search\_ui\_init(false,IBRT\_NONE\_EVENT);

\- app\_tws\_ibrt\_disconnect\_callback

error\_code = p\_ibrt\_ctrl->ibrt\_disc\_reason;

p\_ibrt\_ctrl->ibrt\_disc\_reason = INVALID\_ERROR;

}

app\_tws\_ibrt\_bandwidth\_table\_clean();

app\_tws\_ibrt\_request\_modify\_tws\_bandwidth(TWS\_TIMING\_CONTROL\_USER\_DEFAULT,t

rue); v

}

p\_ibrt\_ctrl->snoop\_connected = 0;

//Cancel profile wait timer if wait for data exchange

if (p\_ibrt\_ctrl->wait\_profile == true)

{

TRACE(0,"ui\_log:cancel wait profile timer");

Rev 1.2 Page178 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.214.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.215.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

p\_ibrt\_ctrl->wait\_profile = false;

osTimerStop(p\_ibrt\_ctrl->wait\_profile\_ready\_timer\_id);

osTimerStop(p\_ibrt\_ctrl->delay\_profile\_send\_timer\_id);

}

app\_tws\_ibrt\_reset\_tss\_state();

}

1. ` `**Add a Custom RFComm Profile**

The RFcomm related functions are encapsulated in the “g\_bes\_bt\_spp” function structure of “bt\_api\_export.c”.

The API for RFcomm control:

g\_bes\_bt\_spp->spp\_rfcomm\_ ()

// turn on rfcomm profile

.spp\_rfcomm\_open = app\_rfcomm\_open,

// turn off rfcomm profile

.spp\_rfcomm\_close = app\_rfcomm\_close,

// send data

.spp\_rfcomm\_write = app\_rfcomm\_write,

The number of channels provided by RFcomm is 6. The common buffer pool is shared for all the opened RFcomm

channels and each RxBuffer size is 2048 bytes.

#define RFCOMM\_SERVER\_MAX\_CHANNEL\_CNT 6

static RfcommService\_t

RfcommServiceInstance[RFCOMM\_SERVER\_MAX\_CHANNEL\_CNT];

static uint8\_t rfcomm\_service\_used\_instance\_cnt = 0;

#define RFCOMM\_RECV\_BUFFER\_SIZE 2048

#define RFCOMM\_RECV\_BUFFER\_POOL\_SIZE (RFCOMM\_SERVER\_MAX\_CHANNEL\_CNT \*

RFCOMM\_RECV\_BUFFER\_SIZE)

static uint8\_t rfcomm\_rx\_buf[RFCOMM\_RECV\_BUFFER\_POOL\_SIZE]; // common

buffer pool for all the opened rfcomm channels

The information in the RFCOMM\_CONFIG\_T structure should be defined during initialization, including RFcomm chanel

which can be added into enum RFCOMM\_CHANNEL\_NUM, maximum number of RFComm channels, UUID, event

callback, data callback, and mutex.

typedef struct

Rev 1.2 Page179 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.216.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

{

uint8\_t rfcomm\_ch;

uint8\_t tx\_pkt\_cnt;

const uint8\_t\* rfcomm\_128bit\_uuid;

rfcomm\_callback\_func callback;

spp\_handle\_data\_event\_func\_t spp\_handle\_data\_event\_func;

osMutexId mutexId;

osMutexId creditMutexId;

} RFCOMM\_CONFIG\_T;

The callback function performs corresponding operations according to the status of the event.

Callback function:

static bool fp\_rfcomm\_callback(uint8\_t device\_id, RFCOMM\_EVENT\_E event,

uint8\_t instanceIndex, uint16\_t connHandle,

uint8\_t\* pBtAddr, uint8\_t\* pSentDataBuf, uint16\_t sentDataLen)

enum RFCOMM\_EVENT\_E contains different types of events:

typedef enum

{

RFCOMM\_INCOMING\_CONN\_REQ = 0,

RFCOMM\_CONNECTED,

RFCOMM\_DISCONNECTED,

RFCOMM\_TX\_DONE,

RFCOMM\_UNKNOWN\_EVENT

} RFCOMM\_EVENT\_E;

1. ` `**BLE**
1. ` `**Connection Management**
1. ` `**BLE Mac Address and BLE Name Configuration**

BLE name and BLE mac address can be configured in DldProductLine before programming. Both information is written

into the factory section after programming.

Rev 1.2 Page180 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.217.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.057.jpeg)*Software Development User Guide*

**Figure 47 Configure BLE Mac Address and BLE Name**

If necessary, The BLE address and BLE name can be updated and viewed through the following interfaces:

1. ` `Get the BLE mac address.

uint8\_t\* factory\_section\_get\_ble\_address(void)

**Sample Code 41: get\_ble\_address**

{"get\_ble\_addr", get\_ble\_addr\_test},

1. ` `Update the BLE mac address.

/\*\*

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

\*\*\*\*\*\*\*\*\*\*\*\*\*

\* @return

\* 0:Set ble address failed

\* 1:Set ble address successed

Rev 1.2 Page181 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.218.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.037.jpeg)*Software Development User Guide*

\*

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

\*\*\*\*\*\*\*\*\*\*\*\*\*

\*/

int factory\_section\_set\_ble\_address(uint8\_t\* bleAddr)

**Sample Code 42: set\_ble\_address**

{"set\_ble\_address", set\_ble\_address\_test},

1. ` `Get the BLE name.

uint8\_t\* factory\_section\_get\_ble\_name(void)

**Sample Code 43: get\_ble\_name**

{"get\_ble\_name", get\_ble\_name\_test},

1. ` `Update the BLE name.

/\*\*

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

\*\*\*\*\*\*\*\*\*\*\*\*\*

\* @return

\* 0:Set ble name failed

\* 1:Set ble name successed

\*

\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

\*\*\*\*\*\*\*\*\*\*\*\*\*

\*/

int factory\_section\_set\_ble\_name(char \*name,int len)

**Sample Code 44: set\_ble\_name**

{"set\_ble\_name", set\_ble\_name\_test},

1. ` `**BLE Adv**

There are two kinds of advertising users: adv user and custom user. The advertising initiated by the adv user is called

user adv, and the advertising initiated by the custom user is called custom adv. These two kinds of advertising will be

interduced respectively as following.

1. ` `**User Adv**

In order to choose user adv, the macro switch CUSTOMER\_DEFINE\_ADV\_DATA needs to be disabled in target.mk:

Rev 1.2 Page182 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.219.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

CUSTOMER\_DEFINE\_ADV\_DATA ?= 0

1. ` `**Simple Advertising**

Before starting simple advertising, the macro switch BLE\_AUDIO\_ENABLED needs to be disabled in target file:

BLE\_AUDIO\_ENABLED = 0

In order to facilitate a simple adv, the default adv user -- USER\_STUB is set to work when no other adv user is

registered. That is, if other adv users are registered, USER\_STUB will be invalid. The flag of this adv is 0x06, and there is

only one BLE name and no response data exists in this adv. The default adv user can be started and stopped by using

the following two interfaces when the UI role is not a slave:

Enable USER\_STUB

void ble\_core\_enable\_stub\_adv(void)

Disable USER\_STUB

void ble\_core\_disable\_stub\_adv(void)

1. ` `**Add an Adv User**

To specify UUID or response data in the adv, you need to register an adv user. In this example, USER\_BLE\_ DEMO is

used to introduce how to add an adv user.

Steps to add an adv user:

1. ` `Add the enum variables.

Add USER\_BLE\_DEMO1 in BLE\_ADV\_USER\_E and add it to ble\_adv\_user2str

typedef enum

{

USER\_INUSE = 0,

USER\_ALL = USER\_INUSE,

USER\_STUB,

USER\_GFPS,

USER\_SWIFT,

USER\_GSOUND,

USER\_AI,

USER\_INTERCONNECTION,

USER\_TILE,

USER\_OTA,

USER\_BLE\_AUDIO,

USER\_SPOT,

Rev 1.2 Page183 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.220.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.221.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.222.jpeg)*Software Development User Guide*

USER\_BLE\_CUSTOMER\_0,

USER\_BLE\_CUSTOMER\_1,

USER\_BLE\_CUSTOMER\_2,

USER\_BLE\_CUSTOMER\_3,

USER\_BLE\_DEMO0,

USER\_BLE\_DEMO1,

BLE\_ADV\_USER\_NUM,

} BLE\_ADV\_USER\_E;

char \*ble\_adv\_user2str(BLE\_ADV\_USER\_E user)

{

switch (user)

{

CASE\_S(USER\_STUB)

CASE\_S(USER\_GFPS)

CASE\_S(USER\_SWIFT)

CASE\_S(USER\_GSOUND)

CASE\_S(USER\_AI)

CASE\_S(USER\_INTERCONNECTION)

CASE\_S(USER\_TILE)

CASE\_S(USER\_OTA)

CASE\_S(USER\_BLE\_AUDIO)

CASE\_S(USER\_SPOT)

CASE\_S(USER\_BLE\_CUSTOMER\_0)

CASE\_S(USER\_BLE\_CUSTOMER\_1)

CASE\_S(USER\_BLE\_CUSTOMER\_2)

CASE\_S(USER\_BLE\_CUSTOMER\_3)

CASE\_S(USER\_BLE\_DEMO0)

CASE\_S(USER\_BLE\_DEMO1)

CASE\_S(USER\_BLE\_DEMO)

CASE\_D()

}

}

1. ` `Bind an adv activity.

Bind the added adv user to one of the adv activities in the table ble\_adv\_fill\_param.

BLE\_ADV\_FILL\_PARAM\_T ble\_adv\_fill\_param[BLE\_ADV\_ACTIVITY\_USER\_NUM] =

{

{

Rev 1.2 Page184 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.223.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

//idle adv interval, music adv interval, sco adv interval

{BLE\_ADV\_INVALID\_INTERVAL},

{USER\_BLE\_CUSTOMER\_0, USER\_STUB, USER\_GFPS, USER\_GSOUND, USER\_AI,

USER\_INTERCONNECTION, USER\_TILE,

USER\_OTA,USER\_BLE\_AUDIO, USER\_BLE\_DEMO},

BLE\_ADV\_TX\_POWER\_LEVEL\_0

},

{

//idle adv interval, music adv interval, sco adv interval

{BLE\_ADV\_INVALID\_INTERVAL},

{USER\_SWIFT, USER\_SPOT, USER\_BLE\_CUSTOMER\_1, USER\_BLE\_DEMO0,

USER\_INUSE},

BLE\_ADV\_TX\_POWER\_LEVEL\_1

},

{

//idle adv interval, music adv interval, sco adv interval

{BLE\_ADV\_INVALID\_INTERVAL},

{USER\_BLE\_CUSTOMER\_2, USER\_BLE\_DEMO1, USER\_INUSE},

BLE\_ADV\_TX\_POWER\_LEVEL\_2

},

#ifdef IS\_BLE\_ACTIVITY\_COUNT\_MORE\_THAN\_THREE

{

//idle adv interval, music adv interval, sco adv interval

{BLE\_ADV\_INVALID\_INTERVAL},

{USER\_BLE\_CUSTOMER\_3},

BLE\_ADV\_TX\_POWER\_LEVEL\_2

},

#endif

};

1. ` `Register a data filling function. This function will be called when adv activity traverses the adv user.

app\_ble\_register\_data\_fill\_handle(USER\_BLE\_DEMO,

(BLE\_DATA\_FILL\_FUNC\_T)ble\_demo\_user\_data\_fill\_handler, false);

1. ` `Specify advertising data and set advertising parameters.

Specify the advertising data and parameters in the registered callback function.The data and parameters of

advertising can be set by using the structure BLE\_ADV\_PARAM\_T as follows. Then enable or disable the

advertising by using the interface app\_ble\_data\_fill\_enable().

typedef struct {

BLE\_ADV\_ACTIVITY\_USER\_E adv\_actv\_user;

Rev 1.2 Page185 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.069.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

bool isBleFlagsAdvDataConfiguredByAppLayer;

/// Advertising filtering policy (@see enum adv\_filter\_policy)

uint8\_t filter\_pol;

BLE\_ADV\_TYPE\_E advType;

ADV\_MODE\_E advMode;

ADV\_DISC\_MODE\_E discMode;

uint32\_t advInterval;

uint32\_t advUserInterval[BLE\_ADV\_USER\_NUM];

/// only ADV\_MODE\_PERIODIC adv mode use

uint32\_t PeriodicIntervalMin;

uint32\_t PeriodicIntervalMax;

// Maximum power level

BLE\_ADV\_TX\_POWER\_LEVEL\_E advTxPwr;

uint8\_t advDataLen;

uint8\_t advData[EXT\_ADV\_DATA\_LEN];

uint8\_t scanRspDataLen;

uint8\_t scanRspData[EXT\_ADV\_DATA\_LEN];

uint8\_t localAddrType;

uint8\_t localAddr[BTIF\_BD\_ADDR\_SIZE];

ble\_bdaddr\_t peerAddr;

} \_\_attribute\_\_((\_\_packed\_\_)) BLE\_ADV\_PARAM\_T;

static void ble\_demo\_user\_data\_fill\_handler(void \*param)

{

BLE\_ADV\_PARAM\_T \*cmd = (BLE\_ADV\_PARAM\_T\*)param;

memcpy(&cmd->advData[cmd->advDataLen], APP\_DEMO\_UUID,

APP\_DEMO\_UUID\_LEN);

cmd->advDataLen += APP\_DEMO\_UUID\_LEN;

memcpy(&cmd->scanRspData[cmd->scanRspDataLen], APP\_DEMO\_DATA,

APP\_DEMO\_DATA\_LEN);

cmd->scanRspDataLen += APP\_DEMO\_DATA\_LEN;

cmd->filter\_pol = 0;

cmd->advType = ADV\_TYPE\_CONN\_EXT\_ADV;

cmd->advMode = ADV\_MODE\_EXTENDED;

cmd->advInterval = BLE\_ADVERTISING\_INTERVAL;

cmd->advUserInterval[USER\_BLE\_DEMO] = BLE\_ADVERTISING\_INTERVAL;

Rev 1.2 Page186 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.224.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

cmd->advTxPwr = BLE\_ADV\_TX\_POWER\_LEVEL\_1;

cmd->localAddr[0] = 0x31;

cmd->localAddr[1] = 0x32;

cmd->localAddr[2] = 0x33;

cmd->localAddr[3] = 0x24;

cmd->localAddr[4] = 0x11;

cmd->localAddr[5] = 0x11;

cmd->localAddrType = 1;

//Add flag

cmd->isBleFlagsAdvDataConfiguredByAppLayer = true;

memcpy(&cmd->advData[cmd->advDataLen], FLAG\_DATA, FLAG\_DATA\_LEN);

cmd->advDataLen += FLAG\_DATA\_LEN;

app\_ble\_data\_fill\_enable(USER\_BLE\_DEMO, true);

}

**Table 52 BLE\_ADV\_PARAM\_T Description**

**Parameter Description**

BLE\_ADV\_ACTIVITY\_USER\_E Adv activity, used in SDK, shouldn’t be set here.

adv\_actv\_user

bool False : Adv Flags is not Configured By App Layer.

isBleFlagsAdvDataConfiguredByAppLayer True : Adv Flags is Configured By App Layer.

uint8\_t ///Advertising filter policy

filter\_pol enum adv\_filter\_policy

{

///Allow both scan and connection requests

///from anyone

ADV\_ALLOW\_SCAN\_ANY\_CON\_ANY = 0x00,

///Allow both scan req from White List

devices

///only and connection req from anyone

ADV\_ALLOW\_SCAN\_WLST\_CON\_ANY,

///Allow both scan req from anyone and

///connection req from White List devices

only

ADV\_ALLOW\_SCAN\_ANY\_CON\_WLST,

///Allow scan and connection requests from

Rev 1.2 Page187 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.225.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

///White List devices only

ADV\_ALLOW\_SCAN\_WLST\_CON\_WLST,

};

BLE\_ADV\_TYPE\_E /// Advertise Types

advType typedef enum app\_ble\_adv\_type

{

/// Connectable and scannable undirected

/// advertising

ADV\_TYPE\_UNDIRECT = 0,

/// Directed connectable with Low Duty Cycle

ADV\_TYPE\_DIRECT\_LDC,

/// Directed connectable with High Duty

Cycle

ADV\_TYPE\_DIRECT\_HDC,

/// Non-connectable but Scannable

/// undirected advertising

ADV\_TYPE\_NON\_CONN\_SCAN,

/// Non-connectable and nonscannable

/// undirected

ADV\_TYPE\_NON\_CONN\_NON\_SCAN,

/// Undirected connectable but scannable

with

/// extended ADV

ADV\_TYPE\_CONN\_EXT\_ADV,

/// Directed connectable no scannable with

/// extended ADV

ADV\_TYPE\_EXT\_CON\_DIRECT,

/// Type MAx Number

ADV\_TYPE\_MAX,

} BLE\_ADV\_TYPE\_E;

ADV\_MODE\_E /// Advertising mode types

advMode typedef enum adv\_mode

{

/// Legacy advertising

ADV\_MODE\_LEGACY = 0,

/// Extended advertising

ADV\_MODE\_EXTENDED,

Rev 1.2 Page188 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.226.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

/// Periodic advertising

ADV\_MODE\_PERIODIC,

}ADV\_MODE\_E;

ADV\_DISC\_MODE\_E /// Advertising discoverable mode types

discMode typedef enum adv\_disc\_mode

{

/// Mode in non-discoverable

ADV\_DISC\_MODE\_NON\_DISC = 0,

/// Mode in general discoverable

ADV\_DISC\_MODE\_GEN\_DISC,

/// Mode in limited discoverable

ADV\_DISC\_MODE\_LIM\_DISC,

/// Broadcast mode without presence of

/// AD\_TYPE\_FLAG in advertising data

ADV\_DISC\_MODE\_BEACON,

/// Mode Max number

ADV\_DISC\_MODE\_MAX,

}ADV\_DISC\_MODE\_E;

uint32\_t Advertising interval, takes precedence over advUserInterval.

advInterval

uint32\_t Interval takes effect when advInterval is invalid.

advUserInterval**[**BLE\_ADV\_USER\_NUM**]**

uint32\_t Minimum interval, only work in advertising mode:

PeriodicIntervalMin ADV\_MODE\_PERIODIC.

uint32\_t Maximum interval, only work in advertising mode:

PeriodicIntervalMax ADV\_MODE\_PERIODIC.

BLE\_ADV\_TX\_POWER\_LEVEL\_E /// Advertise TX power level

advTxPwr typedef enum

{

BLE\_ADV\_TX\_POWER\_LEVEL\_0 = 3,

BLE\_ADV\_TX\_POWER\_LEVEL\_1 = 4,

BLE\_ADV\_TX\_POWER\_LEVEL\_2 = 5,

} BLE\_ADV\_TX\_POWER\_LEVEL\_E;

uint8\_t Advertising data length.

advDataLen

uint8\_t Advertising data.

advData**[**EXT\_ADV\_DATA\_LEN**]**

uint8\_t Scan response data length.

Rev 1.2 Page189 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.227.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

scanRspDataLen

uint8\_t Scan response data.

scanRspData**[**EXT\_ADV\_DATA\_LEN**]**

uint8\_t Type of the local address.

localAddrType 0: public address.

1: private random address.

uint8\_t Address of the device.

localAddr**[**BTIF\_BD\_ADDR\_SIZE**]**

ble\_bdaddr\_t peer address.

peerAddr typedef struct ble\_bdaddr

{

/// BD Address of device

uint8\_t addr[BTIF\_BD\_ADDR\_SIZE];

/// Address type of the device

/// 0: public address

/// 1: private random address

uint8\_t addr\_type;

} ble\_bdaddr\_t;

**Sample Code 45: ble\_adv\_user\_register**

{"ble\_adv\_user\_register", ble\_adv\_user\_register\_test},

1. ` `**Fill Data**

Advertising data and response data need to be specified by using the following method, or the data may be cleared by

other users. The BLE name is added by default at the end of the data.

static void ble\_demo\_user\_data\_fill\_handler(void \*param)

{

BLE\_ADV\_PARAM\_T \*cmd = (BLE\_ADV\_PARAM\_T\*)param;

memcpy(&cmd->advData[cmd->advDataLen], APP\_DEMO\_UUID,

APP\_DEMO\_UUID\_LEN);

cmd->advDataLen += APP\_DEMO\_UUID\_LEN;

memcpy(&cmd->scanRspData[cmd->scanRspDataLen], APP\_DEMO\_DATA,

APP\_DEMO\_DATA\_LEN);

cmd->scanRspDataLen += APP\_DEMO\_DATA\_LEN;

cmd->filter\_pol = 0;

Rev 1.2 Page190 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.228.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

cmd->advType = ADV\_TYPE\_CONN\_EXT\_ADV;

cmd->advMode = ADV\_MODE\_EXTENDED;

cmd->advInterval = BLE\_ADVERTISING\_INTERVAL;

cmd->advUserInterval[USER\_BLE\_DEMO] = BLE\_ADVERTISING\_INTERVAL;

cmd->advTxPwr = BLE\_ADV\_TX\_POWER\_LEVEL\_1;

//Add flag

cmd->isBleFlagsAdvDataConfiguredByAppLayer = true;

memcpy(&cmd->advData[cmd->advDataLen], FLAG\_DATA, FLAG\_DATA\_LEN);

cmd->advDataLen += FLAG\_DATA\_LEN;

app\_ble\_data\_fill\_enable(USER\_BLE\_DEMO, true);

}

1. ` `**Set a Flag**

The BLE stack sets the adv flag according to the advertising type automatically. If you want to set a custom flag for the

user adv, set the parameter isBleFlagsAdvDataConfiguredByAppLayer to be true, and add the adv flag to the data as

follows.

#define FLAG\_DATA "\x02\x01\x01"

#define FLAG\_DATA\_LEN (3)

static void ble\_demo\_user\_data\_fill\_handler(void \*param)

{

BLE\_ADV\_PARAM\_T \*cmd = (BLE\_ADV\_PARAM\_T\*)param;

memcpy(&cmd->advData[cmd->advDataLen], APP\_DEMO\_UUID,

APP\_DEMO\_UUID\_LEN);

cmd->advDataLen += APP\_DEMO\_UUID\_LEN;

memcpy(&cmd->scanRspData[cmd->scanRspDataLen], APP\_DEMO\_DATA,

APP\_DEMO\_DATA\_LEN);

cmd->scanRspDataLen += APP\_DEMO\_DATA\_LEN;

cmd->filter\_pol = 0;

cmd->advType = ADV\_TYPE\_CONN\_EXT\_ADV;

cmd->advMode = ADV\_MODE\_EXTENDED;

cmd->advInterval = BLE\_ADVERTISING\_INTERVAL;

cmd->advUserInterval[USER\_BLE\_DEMO] = BLE\_ADVERTISING\_INTERVAL;

Rev 1.2 Page191 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.229.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

cmd->advTxPwr = BLE\_ADV\_TX\_POWER\_LEVEL\_1;

cmd->localAddr[0] = 0x31;

cmd->localAddr[1] = 0x32;

cmd->localAddr[2] = 0x33;

cmd->localAddr[3] = 0x24;

cmd->localAddr[4] = 0x11;

cmd->localAddr[5] = 0x11;

cmd->localAddrType = 1;

//Add flag

cmd->isBleFlagsAdvDataConfiguredByAppLayer = true;

memcpy(&cmd->advData[cmd->advDataLen], FLAG\_DATA, FLAG\_DATA\_LEN);

cmd->advDataLen += FLAG\_DATA\_LEN;

app\_ble\_data\_fill\_enable(USER\_BLE\_DEMO, true);

}

1. ` `**Advertising Control**

There are two ways to control advertising, one is to enable or disable advertising in the data filling function, which can

be understood as start and stop, and the other is to force switching, which can be understanded as open and close.

Advertising can be opened or closed no matter whether the device is advertising or not.

1. ` `Start and stop advertising

In the data filling function, advertising can be enabled or disabled by using the interface app\_ble\_data\_fill\_enable. Any

adv user can enable adv, and if any adv user enables adv, the corresponding adv activity is enabled.

static void ble\_demo\_user\_data\_fill\_handler(void \*param)

{

BLE\_ADV\_PARAM\_T \*cmd = (BLE\_ADV\_PARAM\_T\*)param;

memcpy(&cmd->advData[cmd->advDataLen], APP\_DEMO\_UUID,

APP\_DEMO\_UUID\_LEN);

cmd->advDataLen += APP\_DEMO\_UUID\_LEN;

memcpy(&cmd->scanRspData[cmd->scanRspDataLen], APP\_DEMO\_DATA,

APP\_DEMO\_DATA\_LEN);

cmd->scanRspDataLen += APP\_DEMO\_DATA\_LEN;

cmd->filter\_pol = 0;

Rev 1.2 Page192 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.230.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.231.jpeg)*Software Development User Guide*

cmd->advType = ADV\_TYPE\_CONN\_EXT\_ADV;

cmd->advMode = ADV\_MODE\_EXTENDED;

cmd->advInterval = BLE\_ADVERTISING\_INTERVAL;

cmd->advUserInterval[USER\_BLE\_DEMO] = BLE\_ADVERTISING\_INTERVAL;

cmd->advTxPwr = BLE\_ADV\_TX\_POWER\_LEVEL\_1;

cmd->localAddr[0] = 0x31;

cmd->localAddr[1] = 0x32;

cmd->localAddr[2] = 0x33;

cmd->localAddr[3] = 0x24;

cmd->localAddr[4] = 0x11;

cmd->localAddr[5] = 0x11;

cmd->localAddrType = 1;

//Add flag

cmd->isBleFlagsAdvDataConfiguredByAppLayer = true;

memcpy(&cmd->advData[cmd->advDataLen], FLAG\_DATA, FLAG\_DATA\_LEN);

cmd->advDataLen += FLAG\_DATA\_LEN;

app\_ble\_data\_fill\_enable(USER\_BLE\_DEMO, true);

}

**Table 53 Function app\_ble\_data\_fill\_enable Description**

**Parameter Description**

enum The user of the ble advertising.

user

bool False : disable this advertising

enable True : enable this advertising

1. ` `Open and close advertising

An adv activity can be forcibly disabled by using the interface app\_ble\_force\_switch\_adv. Every adv user can disable

adv activity. If any adv user disables adv, the corresponding adv activity is disabled.

void app\_ble\_force\_switch\_adv(enum BLE\_ADV\_SWITCH\_USER\_E user, bool

isToEnableAdv)

**Table 54 Function app\_ble\_force\_switch\_adv Description**

**Parameter Description**

Rev 1.2 Page193 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.232.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.233.jpeg)*Software Development User Guide*

enum It is used to set the disable bit map. One user corresponds to one bit. When the

BLE\_ADV\_SWITCH\_USER\_E user disable bit map is not 0, that is, there is at least one user disable adv, the

advertising is disabled.

enum BLE\_ADV\_SWITCH\_USER\_E {

BLE\_SWITCH\_USER\_RS = 0, // used for role switch

BLE\_SWITCH\_USER\_BOX = 1, // used for box

open/close

BLE\_SWITCH\_USER\_AI = 2, // used for ai

BLE\_SWITCH\_USER\_BT\_CONNECT = 3, // used for bt connect

BLE\_SWITCH\_USER\_SCO = 4, // used for sco

BLE\_SWITCH\_USER\_IBRT = 5, // used for ibrt

BLE\_SWITCH\_USER\_FPGA = 6, // used for fpga

BLE\_SWITCH\_USER\_BLE\_AUDIO = 7, // used for ble audio

BLE\_SWITCH\_USER\_NUM,

};

bool False: Disable adv

isToEnableAdv True: Cancel disable adv

**Sample Code 46: Enable and Disable advertising**

{"close\_adv", ble\_audio\_close\_adv\_test},

{"open\_adv", ble\_audio\_open\_adv\_test},

1. ` `**Set an Advertising Type**

There are two ways to set an advertising type. The first one is to set an advertising type by using the interface

app\_ble\_set\_adv\_type, the other is to set the advType directly in the data filling function. The first one has a higher

priority.

1. ` `Set an advertising type by using the interface app\_ble\_set\_adv\_type.

void app\_ble\_set\_adv\_type(BLE\_ADV\_TYPE\_E advType, ble\_bdaddr\_t \*peer\_addr)

**Table 55 Function app\_ble\_set\_adv\_type Description**

**Parameter Description**

enum typedef enum app\_ble\_adv\_type

BLE\_ADV\_TYPE\_E {

advType /// Connectable and scannable undirected advertising

ADV\_TYPE\_UNDIRECT = 0,

/// Directed connectable with Low Duty Cycle

Rev 1.2 Page194 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.234.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.035.jpeg)*Software Development User Guide*

ADV\_TYPE\_DIRECT\_LDC,

/// Directed connectable with High Duty Cycle

ADV\_TYPE\_DIRECT\_HDC,

/// Non-connectable but Scannable undirected

advertising

ADV\_TYPE\_NON\_CONN\_SCAN,

/// Non-connectable and nonscannable undirected

ADV\_TYPE\_NON\_CONN\_NON\_SCAN,

/// Undirected connectable but scannable with extended

ADV

ADV\_TYPE\_CONN\_EXT\_ADV,

/// Directed connectable no scannable with extended ADV

ADV\_TYPE\_EXT\_CON\_DIRECT,

/// Type MAx Number

ADV\_TYPE\_MAX,

} BLE\_ADV\_TYPE\_E;

struct typedef struct ble\_bdaddr

ble\_bdaddr\_t {

\*peer\_addr /// BD Address of device

` `uint8\_t addr[BTIF\_BD\_ADDR\_SIZE]; /// Address type of the device 0=public/1=privaterandom

uint8\_t addr\_type;

} ble\_bdaddr\_t;

**Sample Code 47: ble\_set\_adv\_type**

{"ble\_set\_adv\_type", ble\_set\_adv\_type\_test},

1. ` `Set an advertising type in the data filling function

The advertising type is set to ADV\_TYPE\_CONN\_EXT\_ADV because the current advertsing mode is

ADV\_MODE\_EXTENDED.

static void ble\_demo\_user\_data\_fill\_handler(void \*param)

{

BLE\_ADV\_PARAM\_T \*cmd = (BLE\_ADV\_PARAM\_T\*)param;

memcpy(&cmd->advData[cmd->advDataLen], APP\_DEMO\_UUID,

APP\_DEMO\_UUID\_LEN);

cmd->advDataLen += APP\_DEMO\_UUID\_LEN;

Rev 1.2 Page195 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.235.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

memcpy(&cmd->scanRspData[cmd->scanRspDataLen], APP\_DEMO\_DATA,

APP\_DEMO\_DATA\_LEN);

cmd->scanRspDataLen += APP\_DEMO\_DATA\_LEN;

cmd->filter\_pol = 0;

cmd->advType = ADV\_TYPE\_CONN\_EXT\_ADV;

cmd->advMode = ADV\_MODE\_EXTENDED;

cmd->advInterval = BLE\_ADVERTISING\_INTERVAL;

cmd->advUserInterval[USER\_BLE\_DEMO] = BLE\_ADVERTISING\_INTERVAL;

cmd->advTxPwr = BLE\_ADV\_TX\_POWER\_LEVEL\_1;

cmd->localAddr[0] = 0x31;

cmd->localAddr[1] = 0x32;

cmd->localAddr[2] = 0x33;

cmd->localAddr[3] = 0x24;

cmd->localAddr[4] = 0x11;

cmd->localAddr[5] = 0x11;

cmd->localAddrType = 1;

//Add flag

cmd->isBleFlagsAdvDataConfiguredByAppLayer = true;

memcpy(&cmd->advData[cmd->advDataLen], FLAG\_DATA, FLAG\_DATA\_LEN);

cmd->advDataLen += FLAG\_DATA\_LEN;

app\_ble\_data\_fill\_enable(USER\_BLE\_DEMO, true);

}

1. ` `**Set an Advertsing Interval**

There are two ways to set an adv interval. One is to set an adv activity interval, and the other is to set an advertising

interval in the data filling function. The first one has a higher priority.

1. ` `Set adv activity interval

When the system is in some states, the advertising interval can be set in the scene. The activity interval is set by the

corresponding adv user. If there are multiple user requests to configure the advertising interval, the maximum value

takes effect.

void app\_ble\_param\_set\_adv\_interval(BLE\_ADV\_INTERVALREQ\_USER\_E

adv\_intv\_user,

BLE\_ADV\_USER\_E adv\_user,

Rev 1.2 Page196 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.236.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

uint32\_t interval)

**Table 56 Function app\_ble\_param\_set\_adv\_interval Description**

**Parameter Description**

enum A user corresponds to a scene

BLE\_ADV\_INTERVALREQ\_USER\_E adv\_intv\_user typedef enum

{

BLE\_ADV\_INTERVALREQ\_USER\_A2DP,

BLE\_ADV\_INTERVALREQ\_USER\_SCO,

BLE\_ADV\_INTERVALREQ\_USER\_TWS\_STM,

BLE\_ADV\_INTERVALREQ\_USER\_NUM,

} BLE\_ADV\_INTERVALREQ\_USER\_E;

enum USER\_ALL: Configure the interval for all adv activities

BLE\_ADV\_USER\_E adv\_user 0xXX: Configure the interval of the adv activity corresponding

to the adv user

uint32\_t Configure the interval of adv activity

interval

**Sample Code 48: set\_adv\_interval**

{"ble\_param\_set\_adv\_interval", ble\_param\_set\_adv\_interval\_test},

1. ` `Set an adv user interval

The advertising interval can be configured by using the parameters advUserInterval[adv user] and advInterval in the

data filling function. The parameter advInterval has a higher priority. If there are multiple adv user requests to

configure the interval, the minimum value takes effect.

static void ble\_demo\_user\_data\_fill\_handler(void \*param)

{

BLE\_ADV\_PARAM\_T \*cmd = (BLE\_ADV\_PARAM\_T\*)param;

memcpy(&cmd->advData[cmd->advDataLen], APP\_DEMO\_UUID,

APP\_DEMO\_UUID\_LEN);

cmd->advDataLen += APP\_DEMO\_UUID\_LEN;

memcpy(&cmd->scanRspData[cmd->scanRspDataLen], APP\_DEMO\_DATA,

APP\_DEMO\_DATA\_LEN);

cmd->scanRspDataLen += APP\_DEMO\_DATA\_LEN;

cmd->filter\_pol = 0;

Rev 1.2 Page197 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.237.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)*Software Development User Guide*

cmd->advType = ADV\_TYPE\_CONN\_EXT\_ADV;

cmd->advMode = ADV\_MODE\_EXTENDED;

cmd->advInterval = BLE\_ADVERTISING\_INTERVAL;

cmd->advUserInterval[USER\_BLE\_DEMO] = BLE\_ADVERTISING\_INTERVAL;

cmd->advTxPwr = BLE\_ADV\_TX\_POWER\_LEVEL\_1;

cmd->localAddr[0] = 0x31;

cmd->localAddr[1] = 0x32;

cmd->localAddr[2] = 0x33;

cmd->localAddr[3] = 0x24;

cmd->localAddr[4] = 0x11;

cmd->localAddr[5] = 0x11;

cmd->localAddrType = 1;

//Add flag

cmd->isBleFlagsAdvDataConfiguredByAppLayer = true;

memcpy(&cmd->advData[cmd->advDataLen], FLAG\_DATA, FLAG\_DATA\_LEN);

cmd->advDataLen += FLAG\_DATA\_LEN;

app\_ble\_data\_fill\_enable(USER\_BLE\_DEMO, true);

}

1. ` `**Set the TX power**

Each adv activity can have its own TX power configured. There are four ways to configure the TX power:

Set the TX power in the data fillling function;

Set the TX power by using the interface app\_ble\_set\_adv\_TXpwr\_by\_actv\_user;

Set the TX power by using the interface app\_ble\_set\_adv\_TXpwr\_by\_adv\_user;

Set the TX power by using the interface app\_ble\_set\_all\_adv\_TXpwr.

The last three have higher priorities. TX power can be modified in real time after adv is up.

1. ` `Set the TX power in the data fillling function.

TX power is divided into three levels. You can set the TX power level as needed.

typedef enum

{

BLE\_ADV\_TX\_POWER\_LEVEL\_0 = 3,

BLE\_ADV\_TX\_POWER\_LEVEL\_1 = 4,

Rev 1.2 Page198 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.238.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

BLE\_ADV\_TX\_POWER\_LEVEL\_2 = 5,

} BLE\_ADV\_TX\_POWER\_LEVEL\_E;

static void ble\_demo\_user\_data\_fill\_handler(void \*param)

{

BLE\_ADV\_PARAM\_T \*cmd = (BLE\_ADV\_PARAM\_T\*)param;

memcpy(&cmd->advData[cmd->advDataLen], APP\_DEMO\_UUID,

APP\_DEMO\_UUID\_LEN);

cmd->advDataLen += APP\_DEMO\_UUID\_LEN;

memcpy(&cmd->scanRspData[cmd->scanRspDataLen], APP\_DEMO\_DATA,

APP\_DEMO\_DATA\_LEN);

cmd->scanRspDataLen += APP\_DEMO\_DATA\_LEN;

cmd->filter\_pol = 0;

cmd->advType = ADV\_TYPE\_CONN\_EXT\_ADV;

cmd->advMode = ADV\_MODE\_EXTENDED;

cmd->advInterval = BLE\_ADVERTISING\_INTERVAL;

cmd->advUserInterval[USER\_BLE\_DEMO] = BLE\_ADVERTISING\_INTERVAL;

cmd->advTxPwr = BLE\_ADV\_TX\_POWER\_LEVEL\_1;

cmd->localAddr[0] = 0x31;

cmd->localAddr[1] = 0x32;

cmd->localAddr[2] = 0x33;

cmd->localAddr[3] = 0x24;

cmd->localAddr[4] = 0x11;

cmd->localAddr[5] = 0x11;

cmd->localAddrType = 1;

//Add flag

cmd->isBleFlagsAdvDataConfiguredByAppLayer = true;

memcpy(&cmd->advData[cmd->advDataLen], FLAG\_DATA, FLAG\_DATA\_LEN);

cmd->advDataLen += FLAG\_DATA\_LEN;

app\_ble\_data\_fill\_enable(USER\_BLE\_DEMO, true);

}

1. ` `Set the TX power by using the interface app\_ble\_set\_adv\_txpwr\_by\_actv\_user.

The TX power of the activity can be set directly.

Rev 1.2 Page199 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.239.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.240.jpeg)*Software Development User Guide*

void app\_ble\_set\_adv\_txpwr\_by\_actv\_user(BLE\_ADV\_ACTIVITY\_USER\_E actv\_user,

int8\_t txpwr\_dbm)

**Table 57 Function app\_ble\_set\_adv\_txpwr\_by\_actv\_user Description**

**Parameter Description**

enum Activities that need to be configured

BLE\_ADV\_ACTIVITY\_USER\_E actv\_user

int8\_t Tx power value in the range -21 -> 16

txpwr\_dbm

**Sample Code 49: ble\_set\_adv\_txpwr\_by\_actv\_user**

{"ble\_set\_adv\_txpwr\_by\_actv\_user", ble\_set\_adv\_txpwr\_by\_actv\_user\_test},

1. ` `Set the TX power by using the interface app\_ble\_set\_adv\_txpwr\_by\_adv\_user.

The tx power of the activity can be set by the adv user.

void app\_ble\_set\_adv\_txpwr\_by\_adv\_user(BLE\_ADV\_USER\_E user, int8\_t

txpwr\_dbm)

**Table 58 Function app\_ble\_set\_adv\_txpwr\_by\_adv\_user Description**

**Parameter Description**

enum Used to get the activity that needs to be configured

BLE\_ADV\_USER\_E user

int8\_t Tx power value in the range -21 -> 16

txpwr\_dbm

**Sample Code 50: ble\_set\_adv\_txpwr\_by\_adv\_user**

{"ble\_set\_adv\_txpwr\_by\_adv\_user", ble\_set\_adv\_txpwr\_by\_adv\_user\_test},

1. ` `Set the TX power by using the interface app\_ble\_set\_all\_adv\_txpwr.

Set the TX power of all activities.

void app\_ble\_set\_all\_adv\_txpwr(int8\_t txpwr\_dbm)

**Table 59 Function app\_ble\_set\_all\_adv\_txpwr Description**

**Parameter Description**

int8\_t Tx power value in the range -21 -> 16

txpwr\_dbm

**Sample Code 51: ble\_set\_all\_adv\_txpwr**

Rev 1.2 Page200 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.241.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

{"ble\_set\_all\_adv\_txpwr", ble\_set\_all\_adv\_txpwr\_test},

1. ` `**Set a Local Address**

The advertising address of the user adv is a private random address by default. It can be set to a static address by

enabling the macro switch BLE\_ADV\_RPA\_ENABLED as follows:

BLE\_ADV\_RPA\_ENABLED ?= 0

After enabling the macro, the advertising address is a BLE address by default. It can be set by the following methods:

Set a local address in the data filling function;

Set a local address by using the interface app\_ble\_set\_adv\_local\_addr\_by\_actv\_user;

Set local address by using the interface app\_ble\_set\_adv\_local\_addr\_by\_adv\_user.

The first one have a higher priority. When you use the last two ways to set a local address, the localAddrType needs to

be set to 1 and the localAddr can not be set in the data filling function.

1. ` `Set a local address in the data filling function.

static void ble\_demo\_user\_data\_fill\_handler(void \*param)

{

BLE\_ADV\_PARAM\_T \*cmd = (BLE\_ADV\_PARAM\_T\*)param;

memcpy(&cmd->advData[cmd->advDataLen], APP\_DEMO\_UUID,

APP\_DEMO\_UUID\_LEN);

cmd->advDataLen += APP\_DEMO\_UUID\_LEN;

memcpy(&cmd->scanRspData[cmd->scanRspDataLen], APP\_DEMO\_DATA,

APP\_DEMO\_DATA\_LEN);

cmd->scanRspDataLen += APP\_DEMO\_DATA\_LEN;

cmd->filter\_pol = 0;

cmd->advType = ADV\_TYPE\_CONN\_EXT\_ADV;

cmd->advMode = ADV\_MODE\_EXTENDED;

cmd->advInterval = BLE\_ADVERTISING\_INTERVAL;

cmd->advUserInterval[USER\_BLE\_DEMO] = BLE\_ADVERTISING\_INTERVAL;

cmd->advTxPwr = BLE\_ADV\_TX\_POWER\_LEVEL\_1;

cmd->localAddr[0] = 0x31;

cmd->localAddr[1] = 0x32;

cmd->localAddr[2] = 0x33;

Rev 1.2 Page201 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.242.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.243.jpeg)*Software Development User Guide*

cmd->localAddr[3] = 0x24;

cmd->localAddr[4] = 0x11;

cmd->localAddr[5] = 0x11;

cmd->localAddrType = 1;

//Add flag

cmd->isBleFlagsAdvDataConfiguredByAppLayer = true;

memcpy(&cmd->advData[cmd->advDataLen], FLAG\_DATA, FLAG\_DATA\_LEN);

cmd->advDataLen += FLAG\_DATA\_LEN;

app\_ble\_data\_fill\_enable(USER\_BLE\_DEMO, true);

}

1. ` `Set a local address by using the interface app\_ble\_set\_adv\_local\_addr\_by\_actv\_user.

void app\_ble\_set\_adv\_local\_addr\_by\_actv\_user(BLE\_ADV\_ACTIVITY\_USER\_E

actv\_user, uint8\_t \*addr)

**Table 60 Function app\_ble\_set\_adv\_local\_addr\_by\_user Description**

**Parameter Description**

enum Activities that need to be configured

BLE\_ADV\_ACTIVITY\_USER\_E actv\_user

uint8\_t **\*** Adv address that needs to configure

addr

**Sample Code 52: ble\_set\_adv\_local\_addr\_by\_actv\_user**

{"ble\_set\_adv\_local\_addr\_by\_actv\_user", ble\_set\_adv\_local\_addr\_by\_actv\_user\_test},

1. ` `Set a local address by using the interface app\_ble\_set\_adv\_local\_addr\_by\_adv\_user.

Set the local address of the activity through the adv user.

void app\_ble\_set\_adv\_local\_addr\_by\_adv\_user(BLE\_ADV\_USER\_E user, uint8\_t

\*addr)

**Table 61 Function app\_ble\_set\_adv\_local\_adddr\_adv\_user Description**

**Parameter Description**

enum Used to get the activity that needs to be configured

BLE\_ADV\_ACTIVITY\_USER\_E actv\_user

uint8\_t **\*** Adv address that needs to configure

addr

Rev 1.2 Page202 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.244.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)*Software Development User Guide*

**Sample Code 53: ble\_set\_adv\_local\_addr\_by\_adv\_user**

{"ble\_set\_adv\_local\_addr\_by\_adv\_user", ble\_set\_adv\_local\_addr\_by\_adv\_user\_test},

1. ` `**Start Advertising**

User adv can be started and stopped by using the interface app\_ble\_start\_connectable\_adv as follows.

The data filling function ble\_demo\_user\_data\_fill\_handler is called after advertising starts.

If advertising starts successfully, BLE\_ADV\_STARTED\_EVENT is triggered, and the callback functionn

app\_ble\_customif\_adv\_started\_event\_handler() is called.

If advertising fails to start, BLE\_ADV\_STARTING\_FAILED\_EVENT is triggered, and the callback function

app\_ble\_customif\_adv\_starting\_failed\_event\_handler() is called. These two callback functions can be modified as

needed.

void app\_ble\_start\_connectable\_adv(uint16\_t advInterval)

**Table 62 Function app\_ble\_refresh\_adv\_state Description**

**Parameter Description**

uint16\_t Invalid

advInterval

**Sample Code 54: ble\_user\_adv\_start**

{"ble\_user\_adv\_start", ble\_user\_adv\_start\_test},

1. ` `**BLE Custom Adv**

Inoder to choose a custom adv, the macro switch CUSTOMER\_DEFINE\_ADV\_DATA needs to be enabled in target.mk as

follows:

CUSTOMER\_DEFINE\_ADV\_DATA ?= 1

1. ` `**Initiate a Custom Adv**

Different from the user adv, the initialization of a custom adv has been writed in the SDK as follows. All custom users

can be registered in the function app\_ble\_custom\_init. Therefore, the way of initiating the custom adv is to call the

interface app\_ble\_custom\_init.

void app\_ble\_custom\_init(void)

{

static bool ble\_custom\_inited = false;

Rev 1.2 Page203 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.245.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

if (!ble\_custom\_inited)

{

LOG\_I("%s", \_\_func\_\_);

ble\_custom\_inited = true;

for (uint8\_t actv\_user = BLE\_ADV\_ACTIVITY\_USER\_0; actv\_user <

BLE\_ADV\_ACTIVITY\_USER\_NUM; actv\_user++)

{

memset(&customer\_adv\_param[actv\_user], 0,

sizeof(CUSTOMER\_ADV\_PARAM\_T));

}

app\_ble\_custom\_0\_user\_init();

app\_ble\_custom\_1\_user\_init();

app\_ble\_custom\_2\_user\_init();

#ifdef IS\_BLE\_ACTIVITY\_COUNT\_MORE\_THAN\_THREE

app\_ble\_custom\_3\_user\_init();

#endif

}

}

static void app\_ble\_custom\_0\_user\_init(void)

{

app\_ble\_register\_data\_fill\_handle(USER\_BLE\_CUSTOMER\_0,

(BLE\_DATA\_FILL\_FUNC\_T)app\_ble\_custom\_0\_user\_data\_fill\_handler, false);

}

1. ` `**Data Filling**

The advertising parameters and data can be filled in by using the following interface:

void app\_ble\_custom\_adv\_write\_data(BLE\_ADV\_ACTIVITY\_USER\_E actv\_user,

bool is\_custom\_adv\_flags,

ADV\_ADDR\_TYPE\_E type,

uint8\_t \*local\_addr,

ble\_bdaddr\_t \*peer\_addr,

uint32\_t adv\_interval,

BLE\_ADV\_TYPE\_E adv\_type,

ADV\_MODE\_E adv\_mode,

int8\_t tx\_power\_dbm,

uint8\_t \*adv\_data, uint8\_t adv\_data\_size,

uint8\_t \*scan\_rsp\_data, uint8\_t scan\_rsp\_data\_size)

Rev 1.2 Page204 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.246.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Table 63 Function app\_ble\_custom\_adv\_write\_data Description**

**Parameter Description**

enum /// The user of the adv activity

BLE\_ADV\_ACTIVITY\_USER\_E typedef enum

actv\_user {

BLE\_ADV\_ACTIVITY\_USER\_0 = 0,

BLE\_ADV\_ACTIVITY\_USER\_1,

BLE\_ADV\_ACTIVITY\_USER\_2,

BLE\_ADV\_ACTIVITY\_USER\_3,

BLE\_ADV\_ACTIVITY\_USER\_NUM,

} BLE\_ADV\_ACTIVITY\_USER\_E;

bool False : Adv Flags is not Configured By App Layer.

is\_custom\_adv\_flags True : Adv Flags is Configured By App Layer.

enum Configure the interval of adv activity

ADV\_ADDR\_TYPE\_E type

uint8\_t **\*** Type of the local address.

local\_addr 0: public address.

1: private random address.

struct // peer address.

ble\_bdaddr\_t **\***peer\_addr typedef struct ble\_bdaddr

{

/// BD Address of device

uint8\_t addr[BTIF\_BD\_ADDR\_SIZE];

/// Address type of the device

/// 0: public address

/// 1: private random address

uint8\_t addr\_type;

} ble\_bdaddr\_t;

uint32\_t The interval of the adv activity

adv\_interval

enum /// Advertise Types

BLE\_ADV\_TYPE\_E adv\_type typedef enum app\_ble\_adv\_type

{

/// Connectable and scannable undirected

/// advertising

ADV\_TYPE\_UNDIRECT = 0,

Rev 1.2 Page205 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.247.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

/// Directed connectable with Low Duty Cycle

ADV\_TYPE\_DIRECT\_LDC,

/// Directed connectable with High Duty Cycle

ADV\_TYPE\_DIRECT\_HDC,

/// Non-connectable but Scannable

/// undirected advertising

ADV\_TYPE\_NON\_CONN\_SCAN,

/// Non-connectable and nonscannable

/// undirected

ADV\_TYPE\_NON\_CONN\_NON\_SCAN,

/// Undirected connectable but scannable with

/// extended ADV

ADV\_TYPE\_CONN\_EXT\_ADV,

/// Directed connectable no scannable with

/// extended ADV

ADV\_TYPE\_EXT\_CON\_DIRECT,

/// Type MAx Number

ADV\_TYPE\_MAX,

} BLE\_ADV\_TYPE\_E;

enum /// Advertising mode types

ADV\_MODE\_E adv\_mode typedef enum adv\_mode

{

/// Legacy advertising

ADV\_MODE\_LEGACY = 0,

/// Extended advertising

ADV\_MODE\_EXTENDED,

/// Periodic advertising

ADV\_MODE\_PERIODIC,

}ADV\_MODE\_E;

int8\_t Tx power value, the range is -21 -> 16

tx\_power\_dbm

uint8\_t **\*** Advertising data.

adv\_data

uint8\_t Size of advertising data

adv\_data\_size

uint8\_t **\*** Scan response data.

scan\_rsp\_data

uint8\_t Size of scan response data.

scan\_rsp\_data\_size

Rev 1.2 Page206 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.248.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.249.jpeg)*Software Development User Guide*

1. ` `**Start Advertising**

A custom adv can be started by using the following interface.

If advertising starts successfully, BLE\_ADV\_STARTED\_EVENT is triggered, and the callback function

app\_ble\_customif\_adv\_started\_event\_handler() is executed.

If advertising fails to start, BLE\_ADV\_STARTING\_FAILED\_EVENT is triggered, and the callback functionn

app\_ble\_customif\_adv\_starting\_failed\_event\_handler() is executed.

These two callback functions can be modified as needed.

void app\_ble\_custom\_adv\_start(BLE\_ADV\_ACTIVITY\_USER\_E actv\_user)

**Table 64 Function app\_ble\_custom\_adv\_start Description**

**Parameter Description**

enum Activities that need to be configured

BLE\_ADV\_ACTIVITY\_USER\_E actv\_user

**Sample Code 55: ble\_custom\_adv\_start**

{"ble\_custom\_adv\_start", ble\_custom\_adv\_start\_test},

1. ` `**Advertising Event**

In order to feedback the specific advertising operations, a series of callback interfaces is provided for users. When the

advertising event is triggered, the corresponding callback handler is called.

static const ble\_event\_handler\_t app\_ble\_customif\_event\_handler\_tab[] =

{

… …

{BLE\_ADV\_STARTED\_EVENT, app\_ble\_customif\_adv\_started\_event\_handler},

{BLE\_ADV\_STARTING\_FAILED\_EVENT,

app\_ble\_customif\_adv\_starting\_failed\_event\_handler},

{BLE\_ADV\_STOPPED\_EVENT, app\_ble\_customif\_adv\_stopped\_event\_handler},

… …

};

**Table 65 Adv Event List**

**Event Description Event** Event Parameters

**Code**

BLE\_ADV\_STARTED\_EVENT Advertising started event 0x0B // Event type

enum ble\_event\_type\_e evt\_type

Rev 1.2 Page207 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.250.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.251.jpeg)*Software Development User Guide*

// Activity index

uint8\_t act\_user

// Something to output

void\* output

BLE\_ADV\_STARTING\_FAILED Advertising starting failed 0x0C // event type

\_EVENT event enum ble\_event\_type\_e evt\_type

// Activity index

uint8\_t act\_user

// Something to output

void\* output

BLE\_ADV\_STOPPED\_EVENT Advertising stopped event 0x0D // Event type

enum ble\_event\_type\_e evt\_type

// Activity index

uint8\_t act\_user

// Error reason

uint8\_t err\_code

// Something to output

void\* output

1. ` `**BLE Scan**
1. ` `**Start a Scan**

You can start a scan by using the following interface.

If scanning starts successfully, BLE\_SCAN\_STARTED\_EVENT is triggered, and the callback function

app\_ble\_customif\_scan\_started\_event\_handler() is executed.

If scaning failed to start, BLE\_SCAN\_STARTING\_FAILED\_EVENT is triggered, and the callback function

app\_ble\_customif\_scan\_starting\_failed\_event\_handler() is executed.

These two callback functions can be modified as needed.

void app\_ble\_start\_scan(enum BLE\_SCAN\_FILTER\_POLICY scanFilterPolicy,

uint16\_t scanWindow, uint16\_t scanInterval)

**Table 66 Function app\_ble\_start\_scan Description**

**Parameter Description**

enum enum BLE\_SCAN\_FILTER\_POLICY {

BLE\_SCAN\_FILTER\_POLICY scanFilterPolicy ///Allow advertising packets from anyone

BLE\_SCAN\_ALLOW\_ADV\_ALL = 0x00,

Rev 1.2 Page208 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.252.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

///Allow advertising packets from White

List

///devices only

BLE\_SCAN\_ALLOW\_ADV\_WLST,

///Allow advertising packets from anyone

and

///Direct adv using RPA in InitA

BLE\_SCAN\_ALLOW\_ADV\_ALL\_AND\_INIT\_RPA,

///Allow advertising packets from White

List

///devices only and Direct adv using RPA in

///InitA

BLE\_SCAN\_ALLOW\_ADV\_WLST\_AND\_INIT\_RPA,

};

uint16\_t Scan duration

scanWindow

uint16\_t Scan interval

scanInterval

**Sample Code 56: ble\_start\_scan**

{"ble\_start\_scan", ble\_start\_scan\_test},

1. ` `**Stop a Scan**

You can stop a scan by using the following interface.

If scanning stops, BLE\_SCAN\_STOPED\_EVENT is triggered, and the callback function

app\_ble\_customif\_scan\_stopped\_event\_handler() is executed. The callback functions can be modified as needed.

void app\_ble\_stop\_scan(void)

**Sample Code 57: ble\_stop\_scan**

{"ble\_stop\_scan", ble\_stop\_scan\_test},

1. ` `**Scan Event**

In order to feedback the specific scan operations, a series of callback interfaces is provided for users. When the scan

event is triggered, the corresponding callback handler is called.

static const ble\_event\_handler\_t app\_ble\_customif\_event\_handler\_tab[] =

{

… …

Rev 1.2 Page209 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.253.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.215.jpeg)*Software Development User Guide*

{BLE\_SCAN\_STARTED\_EVENT, app\_ble\_customif\_scan\_started\_event\_handler},

{BLE\_SCAN\_DATA\_REPORT\_EVENT,

app\_ble\_customif\_scan\_data\_report\_event\_handler},

{BLE\_SCAN\_STARTING\_FAILED\_EVENT,

app\_ble\_customif\_scan\_starting\_failed\_event\_handler},

{BLE\_SCAN\_STOPPED\_EVENT, app\_ble\_customif\_scan\_stopped\_event\_handler},

… …

};

**Table 67 Scan Event List**

**Event Description Event Code** Event Parameters

BLE\_SCAN\_STARTED\_EVENT Scan start event,this event 0x0E /// Event type

will be triggered when scan enumble\_event\_type\_e evt\_type

started. /// Something to output

void\* output

BLE\_SCAN\_DATA\_REPORT\_E Scan data report event, this 0x0F /// event type

VENT event will be triggered when enumble\_event\_type\_e evt\_type

scan report data. /// BD Address of device

uint8\_taddr[6];

/// Address type of the

peer ///device

0=public/1=private ///

random

uint8\_taddr\_type;

/// Adv signal strength

uint8\_t rssi

/// report data length

uint16\_tlength

/// scan report data

uint8\_t data[251]

/// Something to output

void\* output

BLE\_SCAN\_STARTING\_FAILE Scan starting failed event, 0x10 /// event type

D\_EVENT this event will be triggered enumble\_event\_type\_e evt\_type

when scan start failed. /// Activity index

uint8\_tactv\_idx;

/// Error reason

uint8\_terr\_code;

/// Something to output

Rev 1.2 Page210 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.254.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.255.jpeg)*Software Development User Guide*

void\* output

BLE\_SCAN\_STOPPED\_EVEN Scan stop event, this event 0x11 /// event type

T will be triggered when scan enumble\_event\_type\_e evt\_type

stopped. /// Something to output

void\* output

1. ` `**BLE Initiating**
1. ` `**Connection**

There are two connection methods: direct connection and connection with the initaited type. Direct connection is

realized by connecting with the initiated type APP\_BLE\_INIT\_TYPE\_DIRECT\_CONN\_EST.

If the connection is successful, BLE\_LINK\_CONNECTED\_EVENT is triggered, and the callback function

app\_ble\_customif\_connect\_event\_handler() is executed.

If the connection fails, BLE\_CONNECTING\_FAILED\_EVENT is triggered, and the callback function

app\_ble\_customif\_scan\_starting\_failed\_event\_handler() is executed.

These two callback functions can be modified as needed.

1. ` `Direct connection

void app\_ble\_start\_connect(ble\_bdaddr\_t \*addr)

**Table 68 Function app\_ble\_start\_connect Description**

**Parameter Description**

struct The address of device to be connected

ble\_bdaddr\_t **\***addr typedef struct ble\_bdaddr

{

/// BD Address of device

struct addr[BTIF\_BD\_ADDR\_SIZE];

/// Address type of the device 0: public / 1: private

random

uint8\_t addr\_type;

} ble\_bdaddr\_t;

**Sample Code 58: ble\_start\_connect**

{"ble\_start\_connect", ble\_start\_connect\_test},

1. ` `Connection with the initiated type

Rev 1.2 Page211 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.256.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.257.jpeg)*Software Development User Guide*

void app\_ble\_start\_connect\_with\_init\_type(ble\_bdaddr\_t \*addr,

BLE\_INIT\_TYPE\_E init\_type, uint16\_t conn\_to)

**Table 69 Function app\_ble\_start\_connect\_with\_init\_type Description**

**Parameter Description**

struct The address of device to be connected

ble\_bdaddr\_t **\***addr typedef struct ble\_bdaddr

{

/// BD Address of device

uint8\_t addr[BTIF\_BD\_ADDR\_SIZE];

/// Address type of the device 0=public/1=private

random

uint8\_t addr\_type;

} ble\_bdaddr\_t;

enum typedef enum app\_ble\_init\_type

BLE\_INIT\_TYPE\_E init\_type {

/// Direct connection establishment, establish a

/// connection with an indicated device

APP\_BLE\_INIT\_TYPE\_DIRECT\_CONN\_EST = 0,

/// Automatic connection establishment, establish a

/// connection with all devices whose address is

present

/// in the white list

APP\_BLE\_INIT\_TYPE\_AUTO\_CONN\_EST,

/// Name discovery, Establish a connection with an

/// indicated device in order to read content of its

device

/// Name characteristic. Connection is closed once

this

/// operation is stopped.

APP\_BLE\_INIT\_TYPE\_NAME\_DISC,

} BLE\_INIT\_TYPE\_E;

uint16\_t Connection timeout

conn\_to

**Sample Code 59: ble\_start\_connect\_with\_init\_type**

{"ble\_start\_connect\_with\_init\_type", ble\_start\_connect\_with\_init\_type\_test},

Rev 1.2 Page212 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.258.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

1. ` `**Connection Status**

In order to determine whether the two devices are connected, you can use the following methods to get the

connection status:

1. ` `Get the connection status by address

bool app\_ble\_is\_connection\_on\_by\_addr(uint8\_t \*addr)

**Table 70 Function app\_ble\_is\_connection\_on\_by\_addr Description**

**Parameter Description**

uint8\_t **\*** Pointer to the peer address

addr

bool Return Parameter

True: It’s connected

False: It’s disconnected

**Sample Code 60: ble\_is\_connection\_on\_by\_addr**

{"ble\_is\_connection\_on\_by\_addr", ble\_is\_connection\_on\_by\_addr\_test},

1. ` `Get the connection status by connetion index

Each connection is assigned an index from 0 increasing by 1. In the case of knowing the connection index, the

connection state can be obtained by using the following interface:

bool app\_ble\_is\_connection\_on(uint8\_t index)

**Table 71 Function app\_ble\_is\_connection\_on Description**

**Parameter Description**

uint8\_t Connection index

index

bool Return Parameter

True: It’s connected

False: It’s disconnected

**Sample Code 61: ble\_is\_connection\_on\_by\_conIdx**

{"ble\_is\_connection\_on\_by\_conIdx", ble\_is\_connection\_on\_by\_conIdx\_test},

1. ` `**Cancel on-going Connections**

All on-going connections can be canceled by using the following intereface.

Rev 1.2 Page213 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.259.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

If an on-going connection is canceled, BLE\_CONNECTING\_STOPPED\_EVENT is triggered, and the callback function

app\_ble\_customif\_stopped\_connecting\_event\_handler() is executed.

void app\_ble\_cancel\_connecting(void)

**Sample Code 62: ble\_cancel\_connecting**

{"ble\_cancel\_connecting", ble\_cancel\_connecting\_test},

1. ` `**Disconnection**

The BLE connection can be diconnected by using the following interface.

If the disconnection starts, BLE\_DISCONNECT\_EVENT is triggered, and the callback function

app\_ble\_customif\_disconnect\_event\_handler() is executed.

void app\_ble\_start\_disconnect(uint8\_t conIdx)

**Table 72 Function app\_ble\_start\_disconnect Description**

**Parameter Description**

uint8\_t Connection index

conIdx

**Sample Code 63: ble\_start\_disconnect**

{"ble\_start\_disconnect", ble\_start\_disconnect\_test},

1. ` `**Connection Event**

In order to feedback the specific connection operations, a series of callback interfaces is provided for users. When the

connection event is triggered, the corresponding callback handler is called.

static const ble\_event\_handler\_t app\_ble\_customif\_event\_handler\_tab[] =

{

{BLE\_LINK\_CONNECTED\_EVENT, app\_ble\_customif\_connect\_event\_handler},

{BLE\_CONNECT\_BOND\_EVENT, app\_ble\_customif\_connect\_bond\_event\_handler},

{BLE\_CONNECT\_NC\_EXCH\_EVENT,

app\_ble\_customif\_connect\_nc\_exch\_event\_handler},

{BLE\_CONNECT\_ENCRYPT\_EVENT,

app\_ble\_customif\_connect\_encrypt\_event\_handler},

{BLE\_CONNECTING\_STOPPED\_EVENT,

app\_ble\_customif\_stopped\_connecting\_event\_handler},

{BLE\_CONNECTING\_FAILED\_EVENT,

app\_ble\_customif\_connecting\_failed\_event\_handler},

Rev 1.2 Page214 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.260.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

{BLE\_DISCONNECT\_EVENT, app\_ble\_customif\_disconnect\_event\_handler},

… …

};

**Table 73 Connection Event List**

**Event Description Event Code** Event Parameters

BLE\_LINK\_CONNECTE BLE connection event, this 0x00 // Event type

D\_EVENT event will be triggered when enumble\_event\_type\_e evt\_type

the TWS is actively or // Connection index

passively connected to a ble uint8\_tconidx;

link. // Peer address

uint8\_taddr[6];

/// Address type of the peer

/// device 0: public

/// 1: private random

uint8\_taddr\_type;

/// Something to output

void\* output

BLE\_CONNECT\_BON BLE connection bound event, 0x01 /// event type

D\_EVENT this event will be triggered enumble\_event\_type\_e evt\_type

when two BLE device are /// Connection index

pairing. int8\_tconidx;

/// True: pair successfully

/// False: pair failed

boolsuccess;

/// failed reason

uint16\_t reason

/// Something to output

void\* output

BLE\_CONNECT\_NC\_E BLE Numeric Comparison 0x02 /// event type

XCH\_EVENT exchange event, when BLE is enumble\_event\_type\_e evt\_type

encrypted, this event will be /// Connection index

triggered after the value is uint8\_tconidx;

exchanged, and the customer /// Something to output

can check the value here. void\* output

Choose to agree or reject

BLE\_CONNECT\_ENCR BLE encryption event, ,this 0x03 /// event type

YPT\_EVENT event will be triggered when enumble\_event\_type\_e evt\_type

the encryption is completed /// Connection index

Rev 1.2 Page215 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.261.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

uint8\_tconidx;

/// BLE pairing level

uint8\_tpairing\_lvl;

/// Something to output

void\* output

BLE\_CONNECTING\_S BLE cancel connection 0x04 /// event type

TOPPED\_EVENT complete event enumble\_event\_type\_e evt\_type

/// Peer address

uint8\_tpeer\_bdaddr[6];

/// Something to output

void\* output

BLE\_CONNECTING\_F BLE connection failure event 0x05 /// event type

AILED\_EVENT enumble\_event\_type\_e evt\_type

/// Activity index

uint8\_tactv\_idx;

/// Error reason

uint8\_terr\_code;

/// Peer address

uint8\_taddr[6];

/// Address type of the peer

/// device 0: public

/// 1: private random

uint8\_taddr\_type;

/// Something to output

void\* output

BLE\_DISCONNECT\_EV BLE disconnection event 0x06 /// event type

ENT enumble\_event\_type\_e evt\_type

/// Disconnected BLE link

connection index

uint8\_tconidx;

/// Reason for disconnection

uint8\_terrCode;

/// Disconnected peer address

uint8\_taddr[6];

/// Address type of the peer

/// device 0: public

/// 1: private random

uint8\_taddr\_type;

/// Something to output

Rev 1.2 Page216 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.262.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.263.jpeg)*Software Development User Guide*

void\* output

1. ` `**Connection Parameter Management**
1. ` `**Update Connection Parameters**

There are different connection modes in BLE. Each connection mode has corresponding parameters. If you want to

customize connection parameters, add the specific connection mode to the table ble\_conn\_param\_config.

typedef enum

{

BLE\_CONN\_PARAM\_MODE\_DEFAULT = 0,

BLE\_CONN\_PARAM\_MODE\_AI\_STREAM\_ON,

BLE\_CONN\_PARAM\_MODE\_A2DP\_ON,

BLE\_CONN\_PARAM\_MODE\_HFP\_ON,

BLE\_CONN\_PARAM\_MODE\_OTA,

BLE\_CONN\_PARAM\_MODE\_OTA\_SLOWER,

BLE\_CONN\_PARAM\_MODE\_SNOOP\_EXCHANGE,

BLE\_CONN\_PARAM\_MODE\_BLE\_AUDIO,

BLE\_CONN\_PARAM\_MODE\_SVC\_DISC\_START,

BLE\_CONN\_PARAM\_MODE\_SVC\_DISC\_CMP,

BLE\_CONN\_PARAM\_MODE\_ISO\_DATA\_ACT,

BLE\_CONN\_PARAM\_MODE\_ISO\_DATA\_STOP,

BLE\_CONN\_PARAM\_MODE\_NUM,

} BLE\_CONN\_PARAM\_MODE\_E;

typedef enum

{

BLE\_CONN\_PARAM\_PRIORITY\_NORMAL = 0,

BLE\_CONN\_PARAM\_PRIORITY\_ABOVE\_NORMAL0,

BLE\_CONN\_PARAM\_PRIORITY\_ABOVE\_NORMAL1,

BLE\_CONN\_PARAM\_PRIORITY\_ABOVE\_NORMAL2,

BLE\_CONN\_PARAM\_PRIORITY\_HIGH,

} BLE\_CONN\_PARAM\_PRIORITY\_E;

// interval in the unit of 1.25ms

static const BLE\_CONN\_PARAM\_CONFIG\_T ble\_conn\_param\_config[] =

{

// default value: for the case of BLE just connected and the BT idle

state

{BLE\_CONN\_PARAM\_MODE\_DEFAULT, BLE\_CONN\_PARAM\_PRIORITY\_NORMAL, 36, 0},

Rev 1.2 Page217 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.264.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.035.jpeg)*Software Development User Guide*

{BLE\_CONN\_PARAM\_MODE\_AI\_STREAM\_ON,

BLE\_CONN\_PARAM\_PRIORITY\_ABOVE\_NORMAL1, 36, 0},

… …

… …

// TODO: add mode cases if needed

};

Multiple connection modes can be enabled at the same time, but only one connection mode takes effect. The

connection mode with higher priority takes effect first, and the connection mode with the same priority has a smaller

connection interval.

If a connection mode is disabled, other enabled connection mode takes effect.

**Figure 48 Connection Parameter Update Policy**

A connection mode can be enabled or disabled by using the following interface.

If the connection mode is enbaled, the event BLE\_CONN\_PARAM\_UPDATE\_REQ\_EVENT is triggered, and the callback

function app\_ble\_customif\_conn\_param\_update\_req\_event\_handler is executed.

If the connection parameters change, the event BLE\_CONN\_PARAM\_UPDATE\_SUCCESSFUL\_EVENT is triggered, and the

callback function app\_ble\_customif\_conn\_param\_update\_successful\_event\_handler is executed.

If the connection parameters fail to change, the event BLE\_CONN\_PARAM\_UPDATE\_FAILED\_EVENT is triggered, and

the callback function app\_ble\_customif\_conn\_param\_update\_failed\_event\_handler is executed.

Rev 1.2 Page218 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.265.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

void app\_ble\_update\_conn\_param\_mode(BLE\_CONN\_PARAM\_MODE\_E mode, bool

isEnable)

**Table 74 Function app\_ble\_update\_conn\_param\_mode Description**

**Parameter Description**

enum Connection mode that needs to be configured

BLE\_CONN\_PARAM\_MODE\_E mode

bool True: enable update connection mode

isEnable False: disable update connection mode

**Sample Code 64: ble\_update\_conn\_param\_mode**

{"ble\_update\_conn\_param\_mode", ble\_update\_conn\_param\_mode\_test},

1. ` `**Get Connection Parameters**

The connection parameters can be obtained by using the following interface.

bool app\_ble\_get\_conn\_param(uint8\_t conidx, APP\_BLE\_CONN\_PARAM\_T\*

pConnParam)

**Table 75 Function app\_ble\_conn\_param Description**

**Parameter Description**

uint8\_t Connection index

conidx

struct typedef struct

APP\_BLE\_CONN\_PARAM\_T**\*** {

pConnParam /// Connection interval value

uint16\_t con\_interval;

/// Connection latency value

uint16\_t con\_latency;

/// Supervision timeout

uint16\_t sup\_to;

} APP\_BLE\_CONN\_PARAM\_T;

**Sample Code 65: ble\_get\_conn\_param**

{"ble\_get\_conn\_param", ble\_get\_conn\_param\_test},

Rev 1.2 Page219 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.266.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Connection Parameter Management Event**

In order to feedback the specific connection parameter management operations, a series of callback interfaces is

provided for users. When the connection parameter management event is triggered, the corresponding callback

handler is called.

static const ble\_event\_handler\_t app\_ble\_customif\_event\_handler\_tab[] =

{

… …

{BLE\_CONN\_PARAM\_UPDATE\_REQ\_EVENT,

app\_ble\_customif\_conn\_param\_update\_req\_event\_handler},

{BLE\_CONN\_PARAM\_UPDATE\_FAILED\_EVENT,

app\_ble\_customif\_conn\_param\_update\_failed\_event\_handler},

{ BLE\_CONN\_PARAM\_UPDATE\_SUCCESSFUL\_EVENT,

app\_ble\_customif\_conn\_param\_update\_successful\_event\_handler},

… …

};

**Table 76 Connection Parameter Management Event List**

**Event Description Event** Event Parameters

**Code**

BLE\_CONN\_PARAM\_UPDAT BLE connection 0x0E /// Event type

E\_REQ\_EVENT parameter update enum ble\_event\_type\_e evt\_type

request event // Connection index

uint16\_t conidx;

// Connection interval minimum

uint16\_t intv\_min;

// Connection interval maximum

uint16\_t intv\_max;

// Latency

uint16\_t latency;

// Supervision timeout

uint16\_t time\_out;

// Something to output

void\* output

BLE\_CONN\_PARAM\_UPDAT BLE connection 0x0F // event type

E\_FAILED\_EVENT parameter update enum ble\_event\_type\_e evt\_type

failure event // Connection index

uint8\_t conidx;

// Error reason

Rev 1.2 Page220 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.267.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

uint8\_t err\_code;

// Something to output

void\* output

BLE\_CONN\_PARAM\_UPDATE BLE connection 0x10 // event type

\_SUCCESSFUL\_EVENT parameter update enum ble\_event\_type\_e evt\_type

success event // Connection index

uint16\_t conidx;

// Connection interval value

uint16\_t con\_interval;

// Latency

uint16\_t con\_latency;

// Supervision timeout

uint16\_t sup\_out;

// Something to output

void\* output

1. ` `**BLE Connection Process Case**

The BLE connection process is shows as follows:

Rev 1.2 Page221 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.268.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 49 BLE Connection Process**

Steps:

1. ` `Advertising

Choose advertising : custom adv or user adv

1. ` `User adv

Ø Disable the macro switch CUSTOMER\_DEFINE\_ADV\_DATA in target.mk.

Ø Add the adv user to BLE\_ADV\_USER\_E, ble\_adv\_user2str and add the adv user to ble\_adv\_fill\_param.

Ø Fill in advertising data and scan response data and set advertising parameters in the data filling function.

Ø Enable the user adv by using the interface app\_ble\_data\_fill\_enable() in the data filling function.

Ø Set advertising parameters by using interfaces. (This part is not neccessary)

Set an advertising type by using the interface app\_ble\_set\_adv\_type(). See Sample code 47 for details.

Set an advertising interval by using the interface app\_ble\_param\_set\_adv\_interval(). See Sample code 48

for details.

Set the TX power by using the interface app\_ble\_set\_adv\_txpwr\_by\_actv\_user(),

app\_ble\_set\_adv\_txpwr\_ by\_act\_user() or app\_ble\_set\_all\_adv\_txpwr(). See Sample code 49, 50 and 51

for details.

Rev 1.2 Page222 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

Set a local address by using the interface app\_ble\_set\_adv\_local\_addr\_by\_actv\_user() or

app\_ble\_set\_adv\_ local\_addr\_by\_adv\_user(). See Sample code 52 and 53 for details.

Ø Register the user adv by using the interface app\_ble\_register\_data\_fill\_handle(). See Sample code 45 for

details.

Ø Start the user adv by using the interface app\_ble\_start\_connectable\_adv(). See Sample code 54 for

details.

1. ` `Custom adv

Ø Enable the macro switch CUSTOMER\_DEFINE\_ADV\_DATA in target.mk.

Ø Initialize the custom user by using the interface app\_ble\_custom\_init().

Ø Set advertising parameters in the data filling function app\_ble\_custom\_adv\_write\_data().

Ø Start the custom adv by using the interface app\_ble\_custom\_adv\_start(). See Sample code 55 for details.

1. ` `Scan

Ø Start a scan by using the interface app\_ble\_start\_scan(). See Sample code 56 for details.

Ø Stop a scan by using the interface app\_ble\_stop\_scan(). See Sample code 57 for details.

1. ` `Connection

Ø Start connection by using the interface ble\_start\_connect() or app\_ble\_start\_connect\_with\_init\_type().

See Sample code 58 and 59 for details.

Ø Get the connection status by using the interface app\_ble\_is\_connection\_on\_by\_addr() or

app\_ble\_is\_connection\_on(). See Sample code 60 and 61 for details.

1. ` `Update connection parameters (This part is not necessary)

Ø Add connection parameters in ble\_conn\_param\_config.

Ø Enable connection mode by using the interface app\_ble\_update\_conn\_param\_mode(). See Sample code

64 for details.

Ø Get connection parameters by the using interface app\_ble\_get\_conn\_param(). See Sample code 65 for

details.

1. ` `Disconnection

Ø Start disconnection by using the interface app\_ble\_start\_disconnect() or app\_ble\_disconnect\_all(). See

Sample code 63 for details.

1. ` `**Add a Custom BLE Profile**
1. ` `**Custom BLE Profile Overview**
1. ` `BLE Profile functional division

Rev 1.2 Page223 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.037.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.269.jpeg)*Software Development User Guide*

**Figure 50 BLE Profile Functional Division**

\1) Profile manager. To add the BLE profile into the BLE database.

\2) BLE profile definition. Define the profile’s UUID/attribute database and the profile initializer, creator,

clean-up and destroy functions here, for the registration to the profile manager.

\3) The bridge between application layer and the profile layer. (Optional)

Define the message APIs for the application layer to call:

\- Enable the notification/indication

\- Send out the data via Write req/command or notification/indication

Distribute the following event and data to the application layer:

\- Receive the enabling notification/indication request

\- Receive the data from write req/command or notification/indication

\- Receive the sent done event of write req/command or notification/indication

\4) Application layer. Define the APIs for the top level to call, and distribute the event and data to the top

level.

\5) Application. Make use of the APIs and event/data callback functions of application layer.

1. ` `Steps to Add a BLE Custom Profile

Based on the BLE profile functional division, the following steps are needed to create a BLE custom profile.

\1) Define a BLE profile.

\2) Register the BLE profile to profile manager.

\3) Define the bridge APIs and event/data distributors.

\4) Define the application layer APIs and event/data distributors.

1. ` `**Define the BLE Profile**
1. ` `Turn to rwprf\_config.h, add the macro switch of the profile. Then all the profile related functions and variables can

be wrapped by the macro BLE\_DATAPATH\_SERVER.

#define CFG\_PRF\_DATAPATH\_SERVER

/// Data Path Service Server Role

#if defined(CFG\_PRF\_DATAPATH\_SERVER)

#define BLE\_DATAPATH\_SERVER 1

Rev 1.2 Page224 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.270.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

#else

#define BLE\_DATAPATH\_SERVER 0

#endif // defined(CFG\_PRF\_DATAPATH\_SERVER)

1. ` `Turn to datapathps.c, specify the profile attribute database datapathps\_att\_db.

The default database is as follows:

/// Full DATAPATH SERVER Database Description - Used to add attributes into

the /// database

const struct gatt\_att\_desc datapathps\_att\_db[DATAPATHPS\_IDX\_NB] =

{

// Service Declaration

[DATAPATHPS\_IDX\_SVC] = {GATT\_DECL\_PRIMARY\_SERVICE, PROP(RD), 0},

// TX Characteristic Declaration

[DATAPATHPS\_IDX\_TX\_CHAR] = {GATT\_DECL\_CHARACTERISTIC\_UUID, PROP(RD),

0},

// TX Characteristic Value

[DATAPATHPS\_IDX\_TX\_VAL] = {datapath\_tx\_char\_val\_uuid\_128\_content,

PROP(N) | PROP(RD) | ATT\_UUID(128), DATAPATHPS\_MAX\_LEN},

// TX Characteristic - Client Characteristic Configuration Descriptor

#if defined(CTKD\_ENABLE) && !defined(BLE\_AUDIO\_STARLORD\_COMPATIBLE\_SUPPORT)

// Let app write ccc to trigger secure connection pairing

[DATAPATHPS\_IDX\_TX\_NTF\_CFG] = {GATT\_DESC\_CLIENT\_CHAR\_CFG\_UUID,

PROP(RD) | PROP(WR) | SEC\_LVL(WP, AUTH), PRF\_SVC\_DESC\_CLI\_CFG\_LEN},

#else

[DATAPATHPS\_IDX\_TX\_NTF\_CFG] = {GATT\_DESC\_CLIENT\_CHAR\_CFG\_UUID,

PROP(RD) | PROP(WR), PRF\_SVC\_DESC\_CLI\_CFG\_LEN},

#endif

// TX Characteristic - Characteristic User Description Descriptor

[DATAPATHPS\_IDX\_TX\_DESC] = {GATT\_DESC\_CHAR\_USER\_DESCRIPTION\_UUID,

PROP(RD), 32},

// RX Characteristic Declaration

[DATAPATHPS\_IDX\_RX\_CHAR] = {GATT\_DECL\_CHARACTERISTIC\_UUID, PROP(RD),

0},

// RX Characteristic Value

[DATAPATHPS\_IDX\_RX\_VAL] = {datapath\_rx\_char\_val\_uuid\_128\_content,

PROP(RD) | PROP(WR) | PROP(WC) | ATT\_UUID(128), DATAPATHPS\_MAX\_LEN},

Rev 1.2 Page225 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.271.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

// RX Characteristic - Characteristic User Description Descriptor

[DATAPATHPS\_IDX\_RX\_DESC] = {GATT\_DESC\_CHAR\_USER\_DESCRIPTION\_UUID,

PROP(RD), 32},

};

The UUID of the service and characteristics should be defined here, there are two choices, 128 bit or 16 bit.

For 128 bit, define USE\_128BIT\_UUID as 1 and change following UUID as the customized:

#define datapath\_service\_uuid\_128\_content {0x12, 0x34, 0x56, 0x78,

0x90, 0x00, 0x00, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01 }

#define datapath\_tx\_char\_val\_uuid\_128\_content {0x12, 0x34, 0x56, 0x78,

0x91, 0x00, 0x00, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02 }

#define datapath\_rx\_char\_val\_uuid\_128\_content {0x12, 0x34, 0x56, 0x78,

0x92, 0x00, 0x00, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03 }

For 16 bit, define USE\_128BIT\_UUID as 0 and change following UUID as the customized:

#define DATAPATHPS\_SERVICE\_UUID\_16BIT 0xFEF8

#define DATAPATHPS\_TX\_CHAR\_VAL\_UUID\_16BIT 0xFEF9

#define DATAPATHPS\_RX\_CHAR\_VAL\_UUID\_16BIT 0xFEFA

1. ` `Define the profile init, destroy, con\_create, con\_clean\_up and con\_updated APIs and fill them into the profile

callback list:

/// DATAPATHPS Task interface required by profile manager

const struct prf\_task\_cbs datapathps\_itf =

{

\_init\_cb,

\_destroy\_cb,

\_con\_create\_cb,

\_con\_cleanup\_cb,

};

/// exported functions definitions

const struct prf\_task\_cbs\* datapathps\_prf\_itf\_get(void)

{

return &datapathps\_itf;

}

Add database to gatt user client:

#if USE\_128BIT\_UUID

status = gatt\_db\_svc\_add(datapathps\_env->user\_lid,

Rev 1.2 Page226 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.272.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

SVC\_SEC\_LVL(NOT\_ENC) | SVC\_UUID(128),

DATAPATH\_SERVICE\_UUID\_128,

DATAPATHPS\_IDX\_NB, NULL, datapathps\_att\_db,

DATAPATHPS\_IDX\_NB,

&datapathps\_env->shdl);

#else

status = gatt\_db\_svc16\_add(datapathps\_env->user\_lid,

SVC\_SEC\_LVL(NOT\_ENC),

ATAPATHPS\_SERVICE\_UUID\_16BIT,

DATAPATHPS\_IDX\_NB, NULL,

datapathps\_att\_db, DATAPATHPS\_IDX\_NB,

&datapathps\_env->shdl);

#endif

1. ` `Define the set of callbacks functions for communication with GATT as a GATT User Client:

// cb\_event\_sent:

// This function is called when GATT server user has initiated event send

to peer // device or if an error occurs.

// cb\_att\_read\_get:

// This function is called when peer want to read local attribute database

value.

// cb\_att\_event\_get:

// This function is called when GATT server user has initiated event send

procedure.

// cb\_att\_info\_get:

// This function is called during a write procedure to get information

about a // specific attribute handle.

// cb\_att\_val\_set:

// This function is called during a write procedure to modify attribute

handle.

/// Set of callbacks functions for communication with GATT as a GATT User

Client

\_\_STATIC const gatt\_srv\_cb\_t datapath\_gatt\_cb = {

.cb\_event\_sent = datapath\_gatt\_cb\_event\_sent,

Rev 1.2 Page227 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.273.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.037.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)*Software Development User Guide*

.cb\_att\_read\_get = datapath\_gatt\_cb\_att\_read\_get,

.cb\_att\_event\_get = datapath\_gatt\_cb\_att\_event\_get,

.cb\_att\_info\_get = datapath\_gatt\_cb\_att\_info\_get,

.cb\_att\_val\_set = datapath\_gatt\_cb\_att\_set,

};

Register as GATT User Client in function \_init\_cb

status = gatt\_user\_srv\_register(PREFERRED\_BLE\_MTU, 0, &datapath\_gatt\_cb,

&(datapathps\_env->user\_lid));

1. ` `**Register the BLE Profile**

Turn to the profile manager source file prf.c. Register the profile by adding the following lines into prf\_itf[PRF\_ID\_MAX]

(array of the profile interface structure):

#if (BLE\_DATAPATH\_SERVER)

PRF\_ITF(DATAPATHPS, datapathps\_prf\_itf\_get),

#endif //(BLE\_DATAPATH\_SERVER)

1. ` `**Define Bridge APIs and Event/Data Distributors**

Turn to file datapathps\_task.c, and define the following message APIs for the application layer to call:

KE\_MSG\_HANDLER\_TAB(datapathps)

{

// send data via notification, can be called when the device is the BLE

peripheral

{DATAPATHPS\_SEND\_DATA\_VIA\_NOTIFICATION, (ke\_msg\_func\_t)

send\_data\_via\_notification\_handler},

// send data via write command, can be called when the device is the BLE

central

{DATAPATHPS\_SEND\_DATA\_VIA\_WRITE\_COMMAND, (ke\_msg\_func\_t)

send\_data\_via\_write\_command\_handler},

};

1. ` `**Define Application Layer APIs and Event/Data Distributors**
1. ` `Turn to rwapp\_config.h, and add the macro switch of the profile as follows:

#define CFG\_APP\_DATAPATH\_SERVER

/// Data Path Server Application

#if defined(CFG\_APP\_DATAPATH\_SERVER)

Rev 1.2 Page228 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.274.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)*Software Development User Guide*

#define BLE\_APP\_DATAPATH\_SERVER 1

#else

#define BLE\_APP\_DATAPATH\_SERVER 0

#endif

Then all the profile related application layer functions and variables can be wrapped by the macro

BLE\_APP\_DATAPATH\_SERVER.

1. ` `Turn to file app\_datapath\_server.c, and define the following APIs for the application top layer to call.

// initialize the profile application layer

void app\_datapath\_server\_init(void);

// register the profile service into the service manager

void app\_datapath\_add\_datapathps(void);

// send notification when the device is BLE peripheral

void app\_datapath\_server\_send\_data\_via\_notification(uint8\_t\* ptrData,

uint32\_t length);

// send write command when the device is BLE central

void app\_datapath\_server\_send\_data\_via\_write\_command(uint8\_t\* ptrData,

uint32\_t length);

// register a callback function when the write command or notification has

been // sent out. when the data needs to be sent continously, this callback

function // can be used to trigger the next transmission

void app\_datapath\_server\_register\_tx\_done(app\_datapath\_server\_tx\_done\_t

callback);

// enable or disable the notification when the device is BLE central

void app\_datapath\_server\_control\_notification(bool isEnable);

1. ` `Turn to file app\_datapath\_server.c, and define the following callback functions for internal handling:

// the BLE connection is connected

void app\_datapath\_server\_connected\_evt\_handler(uint8\_t conidx);

// the BLE connection is disconnected

void app\_datapath\_server\_disconnected\_evt\_handler(uint8\_t conidx);

1. ` `Register the profile service into the APP service manger.

Rev 1.2 Page229 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.275.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

\1) Add the adding profile API into the BLE database creation function list:

static const appm\_add\_svc\_func\_t appm\_add\_svc\_func\_list[APPM\_SVC\_LIST\_STOP]

\=

{

… …

#if (BLE\_APP\_DATAPATH\_SERVER)

(appm\_add\_svc\_func\_t)app\_datapath\_add\_datapathps,

#endif //(BLE\_APP\_DATAPATH\_SERVER)

… …

}

\2) In the function appm\_init, add the profile application layer initialization function:

#if (BLE\_APP\_DATAPATH\_SERVER)

// Data Path Server Module

app\_datapath\_server\_init();

#endif //(BLE\_APP\_DATAPATH\_SERVER)

1. ` `Register the profile service into the APP message handler.

\1) Turn to rwip\_task.h, add the profile task ID into enum TASK\_API\_ID:

TASK\_ID\_DATAPATHPS = 91, // Datapath Server Task

\2) Turn to app\_task.c and include the header file:

#if (BLE\_APP\_DATAPATH\_SERVER)

#include "app\_datapath\_server.h" // Data Path Server Application

Definitions

#endif //(BLE\_APP\_DATAPATH\_SERVER)

\3) In function appm\_msg\_handler, add the following content:

#if (BLE\_APP\_DATAPATH\_SERVER)

case (TASK\_ID\_DATAPATHPS):

{

// Call the Battery Module

msg\_pol = app\_get\_handler(&app\_datapath\_server\_table\_handler, msgid,

param, src\_id);

} break;

#endif //(BLE\_APP\_DATAPATH\_SERVER)

Rev 1.2 Page230 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.276.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.277.jpeg)*Software Development User Guide*

1. ` `**Add a Custom l2cap Connection-oriented Channel**

**Figure 51 l2cap Connection**

As the figure shows, the client and server transmit data on l2cap through DTC and DTS. Before data transmission, the

client has to estabilsh a connection with the server.

Steps to add a custom l2cap connection\_oriented channel:

1. ` `The server registers the connection channel on l2cap;
1. ` `The client initiates a connection and connects to the server;
1. ` `The server and client transfer data on l2cap through DTS and DTC respectively.
1. ` `The server and client are disconnected after data transfer is completed.
1. ` `**DTS**
1. ` `**DTS Register**

The l2cap connection channel can be registered by the server using the following interface.

If a l2cap connection channel is registered, the event APP\_DTS\_COC\_REGISTERED\_IND is triggered, and the callback

function aob\_dts\_coc\_registered\_cb() is executed.

void aob\_dts\_register\_spsm(uint16\_t spsm, uint16\_t initial\_credits)

**Table 77 Function aob\_dts\_register\_spsm Description**

**Parameter Description**

uint16\_t Simplified Protocol/Service Multiplexer

spsm

uint16\_t Initial credits

initial\_credits

**Sample Code 66: DTS Registration**

{"dts\_config", aob\_dts\_configure},

1. ` `**DTS Data Sending**

The server can send data to the client on the l2cap connection channel by using the following interface.

Rev 1.2 Page231 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.278.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

When the data was sent by the server, the event APP\_DTS\_COC\_SEND\_IND is triggered, and the callback function

aob\_dts\_coc\_send\_cb() is executed.

void aob\_dts\_send\_data(uint8\_t con\_lid, uint16\_t spsm, uint16\_t length,

const uint8\_t \*sdu)

**Table 78 Function aob\_dts\_send\_data Description**

**Parameter Description**

uint16\_t Simplified Protocol/Service Multiplexer

spsm

uint16\_t Initial credits

initial\_credits

**Sample Code 67: dts\_send\_data**

{"dts\_send\_data", aob\_dts\_send\_data},

1. ` `**DTS Disconnection**

The server can disconnect the client on the l2cap connection channel by using the following interface.

When the sever is disconnected from the client, the event APP\_DTS\_COC\_DISCONNECTED\_IND is triggered, and the

callback function aob\_dts\_coc\_disconnected\_cb() is executed.

void aob\_dts\_disconnect(uint8\_t con\_lid, uint16\_t spsm)

**Table 79 Function aob\_dts\_disconnect Description**

**Parameter Description**

uint16\_t Connection local index .

con\_lid Used to identify the connected device

uint16\_t Simplified Protocol/Service Multiplexer

spsm

**Sample Code 68: dts\_disconnect**

{"dts\_disconnect", aob\_dts\_disconnect},

1. ` `**DTS Events**

In order to feedback the specific operations, a series of callback interfaces is provided for users. When the DTS event is

triggered, the corresponding callback handler is called.

static dts\_coc\_event\_handler\_t dts\_coc\_event\_cb = {

.dts\_coc\_registered\_cb = aob\_dts\_coc\_registed\_cb,

.dts\_coc\_connected\_cb = aob\_dts\_coc\_connected\_cb,

Rev 1.2 Page232 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.279.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)*Software Development User Guide*

.dts\_coc\_disconnected\_cb = aob\_dts\_coc\_disconnected\_cb,

.dts\_coc\_data\_cb = aob\_dts\_coc\_data\_cb,

.dts\_coc\_send\_cb = aob\_dts\_coc\_send\_cb,

};

**Table 80 DTS Callback handler Description**

**Callback handler Description Event Parameters**

dts\_coc\_registered\_cb The server registers the /// register status

connection channel on uint8\_t status,

l2cap /// Simplified Protocol/ServiceMultiplexer

uint16\_t spsm

dts\_coc\_connected\_cb The server connects the /// Connection local index

client on l2cap channel uint8\_t con\_lid,

/// Maximum SDU size that the peer on

/// the link can receive

uint16\_t tx\_mtu,

/// Maximum packet size that the peer on

the

/// link can receive

uint16\_t tx\_mps,

/// Simplified Protocol/Service Multiplexer

uint16\_t spsm,

/// initial credits

uint16\_t initial\_credits

dts\_coc\_disconnected\_ The server disconnects /// Connection local index

cb the client on the l2cap uint8\_t con\_lid,

channel /// Disconnection reason

uint16\_t reason,

/// Simplified Protocol/Service Multiplexer

uint16\_t spsm

dts\_coc\_data\_cb The server receives data /// Connection local index

from the client on the uint8\_t con\_lid,

l2cap channel /// Simplified Protocol/Service Multiplexer

uint16\_t spsm,

/// SDU data length

uint16\_t length,

/// SDU data

uint8\_t \*sdu

Rev 1.2 Page233 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.280.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.281.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.282.jpeg)*Software Development User Guide*

dts\_coc\_send\_cb The server sends data to /// Connection local index

the client on the l2cap uint8\_t con\_lid,

channel /// Simplified Protocol/Service Multiplexer

uint16\_t spsm

1. ` `**DTC**
1. ` `**DTC Connection**

The client can connect with the server on the l2cap channel by using the following interface.

When the client is connected, the event APP\_DTC\_COC\_CONNECTED\_IND is triggered, and the callback function

aob\_dtc\_coc\_connected\_cb() is executed.

void aob\_dtc\_connect(uint8\_t con\_lid, uint16\_t local\_max\_sdu, uint16\_t

spsm)

**Table 81 Function aob\_dtc\_connect Decription**

**Parameter Description**

uint8\_t Connection local index .

con\_lid Used to identify the connected device

uint16\_t Maximum length of the SDU

local\_max\_sdu

uint16\_t Simplified Protocol/Service Multiplexer

spsm

**Sample Code 69: dts\_connect**

{"dtc\_connect", aob\_dtc\_connect},

1. ` `**DTC Data Sending**

The client can send data to the server on the l2cap channel by using the following interface.

void aob\_dtc\_send\_data(uint8\_t con\_lid, uint16\_t spsm, uint16\_t length,

uint8\_t \*sdu)

**Table 82 Function aob\_dtc\_send\_data Description**

**Parameter Description**

uint8\_t Connection local index.

con\_lid Used to identify the connected device

uint16\_t Connection local index

spsm

uint16\_t SDU data length

Rev 1.2 Page234 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.283.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.284.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.285.jpeg)*Software Development User Guide*

length

uint8\_t \* SDU data to be tranferred to the peer device

sdu

**Sample Code 70: dts\_send\_data**

{"dtc\_send\_data", aob\_dtc\_send\_data},

1. ` `**DTC Disconnection**

The client can disconnect from the server on the l2cap channel by using the following interface.

When the client is disconnected, the event APP\_DTC\_COC\_DISCONNECTED\_IND is triggered, and the callback function

aob\_dtc\_coc\_disconnected\_cb() is executed.

void aob\_dtc\_disconnect(uint8\_t con\_lid, uint16\_t spsm)

**Table 83 Function aob\_dtc\_disconnect Description**

**Parameter Description**

uint8\_t Connection local index .

con\_lid Used to identify the connected device

uint16\_t Simplified Protocol/Service Multiplexer

spsm

**Sample Code 71: dts\_disconnect**

{"dtc\_disconnect", aob\_dtc\_disconnect},

1. ` `**DTC Events**

In order to feedback the specific operations, a series of callback interfaces is provided for users. When the DTC event is

triggered, the corresponding callback handler is called.

static dtc\_coc\_event\_handler\_t dtc\_coc\_event\_cb = {

.dtc\_coc\_connected\_cb = aob\_dtc\_coc\_connected\_cb,

.dtc\_coc\_disconnected\_cb = aob\_dtc\_coc\_disconnected\_cb,

.dtc\_coc\_data\_cb = aob\_dtc\_coc\_data\_cb,

};

**Table 84 DTC Callback Handler Description**

**Callback handler Description** Event Parameters

dtc\_coc\_connected\_cb The Client connect /// Connection local index

to the Server on the uint8\_t con\_lid,

l2cap channel

Rev 1.2 Page235 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.286.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

/// Maximum SDU size that the peer on the

link /// can receive

uint16\_t tx\_mtu,

/// Maximum packet size that the peer on the

/// link can receive

uint16\_t tx\_mps,

/// Simplified Protocol/Service Multiplexer

uint16\_t spsm

dtc\_coc\_disconnected\_cb The Client /// Connection local index

disconnects to the uint8\_t con\_lid,

Server on l2cap /// Disconnection reason

channel uint16\_t reason,

/// Simplified Protocol/Service Multiplexer

uint16\_t spsm

dtc\_coc\_data\_cb Client receives data /// Connection local index

from Server on uint8\_t con\_lid,

l2cap channel /// SDU data length

uint16\_t length,

/// SDU data

uint8\_t \*sdu,

/// Simplified Protocol/Service Multiplexer

uint16\_t spsm

1. ` `**TWS Communication Data Path**

Custom L2CAP is implemented as the communication data path between the master and slave buds.

The L2CAP connection flow is as follows:

Rev 1.2 Page236 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.287.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.288.jpeg)*Software Development User Guide*

**Figure 52 L2CAP Connection Datapath**

Both earbuds register custom L2CAP in their classic BT profile database. When a TWS ACL link is created, the default

master bud (the one that is chosen as the master during TWS pairing) triggers the L2CAP connection as the client.

After the TWS custom L2CAP connection is created. Either side can send TWS commands to the other side. The TWS

command handler is designed to support “wait response” and “don’t wait response” modes, to meet different

requirements.

TWS custom L2CAP isn’t influenced by TWS role switch, and across the lifetime of TWS link, TWS custom L2CAP is alive

for use by the TWS command handler layer.

There is an existing custom TWS command table in app\_ibrt\_customif\_cmd.cpp for developers to add their own

commands.

The command entry definition:

**Table 85 Command Entry Definition:**

**Item Description Notes**

Rev 1.2 Page237 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.289.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

Struct The command entry typedef struct

app\_tws\_cmd\_ins definition {

tance\_t uint32\_t cmdcode;

const char

\*log\_cmd\_code\_str;

app\_tws\_cmd\_send\_handler\_t

tws\_cmd\_send;

app\_tws\_cmd\_receivd\_handler\_t

cmdhandler; /\*\*< command handler

function \*/

uint32\_t

timeout\_ms;

app\_tws\_rsp\_timeout\_handle\_t

app\_tws\_rsp\_timeout\_handle;

app\_tws\_rsp\_handle\_t

app\_tws\_rsp\_handle;

app\_tws\_cmd\_tx\_done\_handler\_t

app\_tws\_cmd\_tx\_done\_handler;

} \_\_attribute\_\_((packed))

app\_tws\_cmd\_instance\_t;

Use the following sample code to configure GPIO\_3\_2 as a general GPIO in the 1.8v voltage domain, no pull state.

For example:

No-wait-response TWS custom command:

{

APP\_IBRT\_CUSTOM\_CMD\_TEST1, "TWS\_CMD\_TEST1",

app\_ibrt\_customif\_test1\_cmd\_send,

app\_ibrt\_customif\_test1\_cmd\_send\_handler, 0,

app\_ibrt\_custom\_cmd\_rsp\_timeout\_handler\_null,

app\_ibrt\_custom\_cmd\_rsp\_handler\_null

},

tws\_ctrl\_send\_cmd(APP\_IBRT\_CUSTOM\_CMD\_TEST1, (uint8\_t\*)cmd\_test,

sizeof(ibrt\_custom\_cmd\_test\_t));

Wait-response TWS custom command:

{

APP\_IBRT\_CUSTOM\_CMD\_TEST2, "TWS\_CMD\_TEST2",

app\_ibrt\_customif\_test2\_cmd\_send,

Rev 1.2 Page238 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.290.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.035.jpeg)*Software Development User Guide*

app\_ibrt\_customif\_test2\_cmd\_send\_handler,

RSP\_TIMEOUT\_DEFAULT,

app\_ibrt\_customif\_test2\_cmd\_send\_rsp\_timeout\_handler,

app\_ibrt\_customif\_test2\_cmd\_send\_rsp\_handler

},

tws\_ctrl\_send\_cmd(APP\_IBRT\_CUSTOM\_CMD\_TEST2, (uint8\_t\*)cmd\_test,

sizeof(ibrt\_custom\_cmd\_test\_t));

1. ` `**GATT over BR/EDR**

The Generic Attribute profile (GATT) defines a service framework using the Attribute protocol. This framework defines

the procedures and formats of services and their characteristics. The procedures defined include discovering, reading,

writing, notifying and indicating characteristics, as well as configuring the broadcast of characteristics. GATT is just a

description of a simple protocol and is not limited to BLE or BR/EDR. The Bluetooth core specification 4.0 updated to

support GATT over BR/EDR in 2010. Define the macro GATT\_OVER\_BR\_EDR to enable this feature. After defining this

macro, GATT and GATT over BR/EDR are used in the same way.

GATT\_OVER\_BR\_EDR ?= 1

Take TOTA as an example. More details about TOTA can be found in 5.5

The user callback set of the GATT server is as follows.

**Table 86 GATT Server User Callback Set**

**Item Description Notes**

typedef struct GATT server typedef struct gatt\_srv\_cb

gatt\_srv\_cb user callback {

set void (\*cb\_event\_sent) (uint8\_t conidx,

uint8\_t user\_lid, uint16\_t dummy, uint16\_t

status);

void (\*cb\_att\_read\_get) (uint8\_t conidx,

uint8\_t user\_lid, uint16\_t token, uint16\_t

hdl, uint16\_t offset,

uint16\_t

max\_length);

void (\*cb\_att\_event\_get) (uint8\_t

conidx, uint8\_t user\_lid, uint16\_t token,

uint16\_t dummy, uint16\_t hdl,

uint16\_t

max\_length);

Rev 1.2 Page239 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.291.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)*Software Development User Guide*

void (\*cb\_att\_info\_get) (uint8\_t conidx,

uint8\_t user\_lid, uint16\_t token, uint16\_t

hdl);

void (\*cb\_att\_val\_set) (uint8\_t conidx,

uint8\_t user\_lid, uint16\_t token, uint16\_t

hdl, uint16\_t offset,

co\_buf\_t\* p\_data);

} gatt\_srv\_cb\_t;

This function is called when the GATT server user initiates an event sending request to the peer. The parameter conidx

is the connection index, user\_lid is the GATT user local identifier, dummy is the dummy parameter provided by upper

layer for command execution and status is the status of the procedure.

\_\_STATIC void tota\_gatt\_cb\_event\_sent(uint8\_t conidx, uint8\_t user\_lid,

uint16\_t dummy, uint16\_t status)

This function is called when the peer wants to read local attribute database values. The parameter conidx is the

connection index, user\_lid is the GATT user local identifier, token is the procedure token that must be returned in

confirmation function, hdl is the attribute handle, offset is the value offset, and max\_length is the maximum value

length to return.

\_\_STATIC void tota\_gatt\_cb\_att\_read\_get(uint8\_t conidx, uint8\_t user\_lid,

uint16\_t token, uint16\_t hdl, uint16\_t offset, uint16\_t max\_length)

This function is called when the GATT server user initiates an event sending procedure. The parameter conidx is the

connection index, user\_lid is the GATT user local identifier, token is the procedure token that must be returned in

confirmation function, dummy is the dummy parameter provided by the upper layer for command execution, hdl is the

attribute handle, offset is the value offset, and max\_length is the maximum value length to return.

\_\_STATIC void tota\_gatt\_cb\_att\_event\_get(uint8\_t conidx, uint8\_t user\_lid,

uint16\_t token, uint16\_t dummy, uint16\_t hdl, uint16\_t max\_length)

This function is called during a write procedure to get information about a specific attribute handle. The parameter

conidx is the connection index, user\_lid is the GATT user local identifier, token is the procedure token that must be

returned in confirmation function, hdl is attribute handle, offset is the value offset, and max\_length is the maximum

value length to return.

\_\_STATIC void tota\_gatt\_cb\_att\_info\_get(uint8\_t conidx, uint8\_t user\_lid,

uint16\_t token, uint16\_t hdl)

This function is called during a write procedure to modify the attribute handle. The parameter conidx is the connection

index, user\_lid is the GATT user local identifier, token is the procedure token that must be returned in confirmation

Rev 1.2 Page240 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.292.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.045.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

function, hdl is the attribute handle, offset is the value offset, and p\_data is the pointer to buffer that contains data to

write starting from offset.

\_\_STATIC void tota\_gatt\_cb\_att\_set(uint8\_t conidx, uint8\_t user\_lid,

uint16\_t token, uint16\_t hdl, uint16\_t offset, co\_buf\_t\* p\_buf)

Set of callback functions for communication with GATT as a GATT user server

\_\_STATIC const gatt\_srv\_cb\_t tota\_gatt\_srv\_cb = {

.cb\_event\_sent = tota\_gatt\_cb\_event\_sent,

.cb\_att\_read\_get = tota\_gatt\_cb\_att\_read\_get,

.cb\_att\_event\_get = tota\_gatt\_cb\_att\_event\_get,

.cb\_att\_info\_get = tota\_gatt\_cb\_att\_info\_get,

.cb\_att\_val\_set = tota\_gatt\_cb\_att\_set,

};

Register as a GATT User Server

status = gatt\_user\_srv\_register(PREFERRED\_BLE\_MTU, 0, &tota\_gatt\_srv\_cb,

&(tota\_env->srv\_user\_lid));

1. ` `**DUT Test Mode**
3. ` `**Signaling Test Mode**
1. ` `**Test Setup**

The flow of setup a test is shown in the following figure.

**Figure 53 Test Setup**

1. ` `**Software API**

Software API for signal tests is as follows:

extern osTimerId app\_env\_checker\_timer;

Rev 1.2 Page241 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.293.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

Interface to stop the battery measurement timer:

int app\_battery\_stop(void);

Interface for signal tests in factory mode:

void app\_factorymode\_bt\_signalingtest(APP\_KEY\_STATUS \*status, void \*param)

{

factory\_section\_data\_t \*factory\_section\_data =

factory\_section\_data\_ptr\_get();

APP\_FACTORY\_TRACE("%s",\_\_func\_\_);

#ifdef \_\_WATCHER\_DOG\_RESET\_\_

app\_wdt\_close();

#endif

hal\_cpu\_wake\_lock(APP\_FACT\_CPU\_WAKE\_LOCK);

app\_stop\_10\_second\_timer(APP\_PAIR\_TIMER\_ID);

app\_stop\_10\_second\_timer(APP\_POWEROFF\_TIMER\_ID);

app\_status\_indication\_set(APP\_STATUS\_INDICATION\_TESTMODE);

osTimerStop(app\_env\_checker\_timer);

app\_battery\_stop();

pmu\_sleep\_en(0);

BESHCI\_Close();

btdrv\_hciopen();

btdrv\_sleep\_config(0);

//btdrv\_hcioff();

osDelay(2000);

//btdrv\_testmode\_start();

//btdrv\_sleep\_config(0);

btdrv\_ins\_patch\_test\_init();

btdrv\_feature\_default();

//btdrv\_test\_mode\_addr\_set();

if (factory\_section\_data){

btdrv\_write\_localinfo((char \*)factory\_section\_data->device\_name,

strlen((char \*)(factory\_section\_data->device\_name)) + 1,

factory\_section\_data->bt\_address);

}

btdrv\_enable\_dut();

}

Rev 1.2 Page242 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.294.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

3. ` `**Non-signaling Test Mode**
1. ` `**Test Setup**

The flow of setting up a test is shown in the following figure.

**Figure 54 Test Setup**

1. ` `**Software API**

Interface for non-signal tests in factory mode:

void app\_factorymode\_bt\_nosignalingtest(APP\_KEY\_STATUS \*status, void

\*param)

{

factory\_section\_data\_t \*factory\_section\_data =

factory\_section\_data\_ptr\_get();

APP\_FACTORY\_TRACE("%s",\_\_func\_\_);

#ifdef \_\_WATCHER\_DOG\_RESET\_\_

app\_wdt\_close();

#endif

hal\_cpu\_wake\_lock(APP\_FACT\_CPU\_WAKE\_LOCK);

app\_stop\_10\_second\_timer(APP\_PAIR\_TIMER\_ID);

app\_stop\_10\_second\_timer(APP\_POWEROFF\_TIMER\_ID);

app\_status\_indication\_set(APP\_STATUS\_INDICATION\_TESTMODE1);

osTimerStop(app\_env\_checker\_timer);

app\_battery\_stop();

pmu\_sleep\_en(0);

BESHCI\_Close();

btdrv\_hciopen();

btdrv\_sleep\_config(0);

//btdrv\_hcioff();

Rev 1.2 Page243 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.295.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

osDelay(2000);

//btdrv\_testmode\_start();

//btdrv\_sleep\_config(0);

btdrv\_ins\_patch\_test\_init();

#ifdef CHIP\_BEST2300

\*(volatile uint32\_t \*)0xd03503a0 |= 1;

#endif

btdrv\_feature\_default();

if (factory\_section\_data){

btdrv\_write\_localinfo((char \*)factory\_section\_data->device\_name,

strlen((char \*)(factory\_section\_data->device\_name)) + 1,

factory\_section\_data->bt\_address);

}

//bt\_drv\_check\_calib();

btdrv\_hcioff();

btdrv\_uart\_bridge\_loop();

}

In some version of SDK, the preceding function is replaced by app\_factorymode\_bt\_bridgemode(), but the content

should be the same.

3. ` `**Test Proceduce**

The test procedure is as follows:

1. ` `Code entry

Method 1: enter test mode in the key process handler (for quick test)

void app\_bt\_key\_simulation(APP\_KEY\_STATUS \*status, void \*param)

{

TRACE("Get key event %d", status->event);

switch(status->event)

{

…

case APP\_KEY\_EVENT\_TRIPLECLICK:

//clear\_dump\_log();

app\_factorymode\_bt\_signalingtest(status, param);

break;

Rev 1.2 Page244 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.296.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

case APP\_KEY\_EVENT\_ULTRACLICK:

app\_factorymode\_bt\_nosignalingtest(status, param);

break;

case APP\_KEY\_EVENT\_LONGPRESS:

app\_tws\_simulate\_pairing();

break;

default:

break;

}

}

Method 2: enter test mode in reboot mode (Recommended because the initial condition is the same

every time when entering test mode). Define the macro \_\_ENGINEER\_MODE\_SUPPORT\_\_ in target**.**mk

int app\_init(void)

{

…

TRACE("!!!!!ENGINEER\_MODE!!!!!\n");

nRet = 0;

btdrv\_start\_bt();

//BesbtInit();

app\_nvrecord\_rebuild();

if (hal\_sw\_bootmode\_get() & HAL\_SW\_BOOTMODE\_TEST\_SIGNALINGMODE){

hal\_sw\_bootmode\_clear(HAL\_SW\_BOOTMODE\_TEST\_MASK);

app\_factorymode\_bt\_signalingtest(NULL, NULL);

}

if (hal\_sw\_bootmode\_get() & HAL\_SW\_BOOTMODE\_TEST\_BRIDGEMODE){

hal\_sw\_bootmode\_clear(HAL\_SW\_BOOTMODE\_TEST\_MASK);

app\_factorymode\_bt\_bridgemode(NULL, NULL);

}

…

}

void app\_bt\_key\_simulation(APP\_KEY\_STATUS \*status, void \*param)

{

TRACE("Get key event %d", status->event);

switch(status->event)

{

Rev 1.2 Page245 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.297.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

…

case APP\_KEY\_EVENT\_TRIPLECLICK:

//clear\_dump\_log();

//app\_factorymode\_bt\_signalingtest(status, param);

hal\_sw\_bootmode\_clear(HAL\_SW\_BOOTMODE\_REBOOT);

hal\_sw\_bootmode\_set(HAL\_SW\_BOOTMODE\_TEST\_MODE|HAL\_SW\_BOOTMODE\_TEST\_SIGN

ALINGMODE);

hal\_cmu\_sys\_reboot();

break;

case APP\_KEY\_EVENT\_ULTRACLICK:

//app\_factorymode\_bt\_nosignalingtest(status, param);

hal\_sw\_bootmode\_clear(HAL\_SW\_BOOTMODE\_REBOOT);

hal\_sw\_bootmode\_set(HAL\_SW\_BOOTMODE\_TEST\_MODE|HAL\_SW\_BOOTMODE\_TEST\_BRID

GEMODE);

hal\_cmu\_sys\_reboot();

break;

case APP\_KEY\_EVENT\_LONGPRESS:

app\_tws\_simulate\_pairing();

break;

default:

break;

}

}

1. ` `Set up the connection with the tester

For BR/EDR:

o Reset the target board.

o Press the PWR\_ON button to start the application.

o Click the PWR button three times quickly to let the application enter DUT test mode.

Then the device can be found by the tester over the air.

For BLE:

o Reset the target board.

o Press the PWR button to start the application.

Rev 1.2 Page246 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.298.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

o Click the PWR button for four times quickly to let the application enter Direct test mode.

o Connect the UART (debug port) to the tester, configure the baud rate to 115200.

Then, the tester can communicate with the target board.

3. ` `**Test Sample Data**

DTM (standard HCI command)

Reset

<UART>TX:[01:03:0C:00]

<UART>RX:[04:0E:04:05:03:0C:00]

BLE transfer test is as follows.

**Table 87 BLE TX Test**

**Test item Test condition** Command raw data

Case 1 TX Channel: 0 (2402MHz) <UART>TX:[01:1E:20:03:00:25:04]

Payload Pattern: 4:11111111 <UART>RX:[04:0E:04:05:1E:20:00]-

Payload Size:37

Case 2 TX Channel: 1 (2404MHz) <UART>TX:[01:1E:20:03:01:1E:02]

Payload Pattern: 2 (10101010) <UART>RX:[04:0E:04:05:1E:20:00]

Payload Size:30

BLE receive test is as follows.

**Table 88 BLE RX Test**

**Test item Test condition** Command raw data

Case 1 RX channel: 0 (2402MHz) RX start

<UART>TX:[01:1D:20:01:00]

<UART>RX:[04:0E:04:05:1D:20:00]

Receiving packet from tester…

Test end (report received packet number)

<UART>TX:[01:1F:20:00]

<UART>RX:[04:0E:06:05:1F:20:00:00:00]

Case 2 RX channel: 39 (2480MHz) RX start

<UART>TX:[01:1D:20:01:27]

<UART>RX:[04:0E:04:05:1D:20:00]

Rev 1.2 Page247 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.299.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.300.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.301.jpeg)*Software Development User Guide*

Receiving packet from tester…

Test End (report received packet number)

<UART>TX:[01:1F:20:00]

<UART>RX:[04:0E:06:05:1F:20:00:00:00]

1. ` `**Throughput Usage Guide**

There are two applications for testing throughput, Bestechnic and BES ThroughPut. Before using these two applications,

be sure that the phone is connected to the board. These two applications can test the throughput or BLE or SPP, and

SPP throughput test is taken as an example in this article.

3. ` `**Throughput Command Specification**
1. ` `**BLE Data Path**

**Figure 55 BLE Data Path**

For the BLE data path, the smartphone application connects to the audio device via BLE. The smartphone acts as the

master while the audio device is the slave. The application makes use of BLE write without response type requests to

send the command and audio data. On the contrary direction, the device sends the data and command via BLE

notifications.

**Table 89 BLE service profile**

**Item Description**

Service UUID 0x00,0x00,0x82,0x6f,0x63,0x2e,0x74,0x6e,0x69,0x6f,0x70,0x6c,0x65,0x63,0x78,0x65

Cmd TX Value 0x01,0x00,0x82,0x6f,0x63,0x2e,0x74,0x6e,0x69,0x6f,0x70,0x6c,0x65,0x63,0x78,0x65

Cmd CCC 0x02, 0x29

Cmd RX Value 0x02,0x00,0x82,0x6f,0x63,0x2e,0x74,0x6e,0x69,0x6f,0x70,0x6c,0x65,0x63,0x78,0x65

Voice Data TX Value 0x03,0x00,0x82,0x6f,0x63,0x2e,0x74,0x6e,0x69,0x6f,0x70,0x6c,0x65,0x63,0x78,0x65

Rev 1.2 Page248 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.302.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.303.jpeg)*Software Development User Guide*

Voice Data CCC 0x02, 0x29

Data RX Value 0x04,0x00,0x82,0x6f,0x63,0x2e,0x74,0x6e,0x69,0x6f,0x70,0x6c,0x65,0x63,0x78,0x65

The command and the data are split into two characteristic paths.

1. ` `**BT SPP Data Path**

**Figure 56 BT Data Path**

For BT SPP data path, the mobile application connects to the audio device via classic BT SPP service. The audio device

registers itself as the SPP server, waiting for the connection request from the smartphone. Both the command and the

data are exchanged via the SPP data path.

1. ` `**Communication Procedure**

The communicated content between the smartphone and the audio device includes commands, and data:

Rev 1.2 Page249 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.304.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 57 Command**

The command can be defined as “need to wait for the response” or “no need to wait for the response”, while the

waiting time-out period can be customized.

The data format of the command request:

**Table 90 Data Format**

Offset Length(bytes) Type Description

(bytes)

0 2 uint16\_t Command code

2 2 uint16\_t The length of the following parameter

4 to (N-1) N-4 Array of uint8\_t Parameter, N = 20~508, depending the

MTU size

The command code list:

**Table 91 Command Code List**

**Command Code Value Description**

OP\_RESPONSE\_TO\_CMD 0x8000 Response to cmd (for internal use)

OP\_INFORM\_THROUGHPUT\_TEST\_CONFIG 0x8009 Used by the smart-phone to inform the expected throughput

test configuration.Used by the audio device to inform the

actual negotiated configuration.

OP\_THROUGHPUT\_TEST\_DATA 0x800A Throughput test data packet

OP\_THROUGHPUT\_TEST\_DATA\_ACK 0x800B Ack of the throughput test data packet

OP\_THROUGHPUT\_TEST\_DONE 0x800C Signal of the throughput test done

The data format of the command response:

**Table 92 Data Format of Command Response**

Offset Length(bytes) Type Description

(bytes)

0 2 uint16\_t Rsp cmd code, fixed value: 0x8000

2 2 uint16\_t The length of the followingdata

4 2 uint16\_t The responded cmd code

6 2 uint16\_t handling result of the command, from

the error code table

8 2 uint16\_t The length of the response parameter

10-N N-10 Array of uint8\_t Parameter, N = 20~508, depending the

MTU size

Rev 1.2 Page250 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.305.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

The error code list:

**Table 93 Error Code List**

**Command Code Value Description**

NO\_ERROR 0 No error

INVALID\_CMD 1 Invalid command code

INVALID\_DATA\_PACKET 2 Invalid data packet format

PARAM\_LEN\_OUT\_OF\_RANGE 3 Parameter length out of range

PARAM\_LEN\_TOO\_SHORT 4 Parameter length too short

CMD\_HANDLING\_FAILED 5 Command handling failed

WAITING\_RSP\_TIMEOUT 6 Waiting response time-out

DATA\_XFER\_ALREADY\_STARTED 7 The data transfer has already been started

DATA\_XFER\_NOT\_STARTED\_YET 8 The data transfer hasn’t been started

DATA\_SEGMENT\_CRC\_CHECK\_FAILED 9 Data segment CRC check failed

WHOLE\_DATA\_CRC\_CHECK\_FAILED 10 Whole data CRC check failed

DATA\_XFER\_LEN\_NOT\_MATCHED 11 The data transfer length doesn’t match the actually received data

length

MUSIC\_ALREADY\_PLAYING 12 The music playing on the cloud side is already on

MUSIC\_NOT\_PLAYING\_YET 13 The music playing on the cloud side is not started yet

Rev 1.2 Page251 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.306.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Throughput Test Procedure**

**Figure 58 Throughput Test Procedure**

The format of the throughput test commands:

The parameters are small-endian. For example, the test lasting time is 10 seconds, so the bytes are 0x0a 0x00.

**Table 94 Data Format**

Offset Length(bytes) Type Description

(bytes)

Inform the configuration 0x8009 16 Byte 0: Test data pattern:

of the throughput test

0x00 Random data (default)

0x01 Pattern of alternating bits ‘11110000’

0x02 Pattern of alternating bits ‘10101010’

0x03 Pattern of All ‘1’ bits

0x04 Pattern of All ‘0’ bits

0x05 Pattern of alternating bits ‘00001111’

0x06 Pattern of alternating bits ‘0101’

Rev 1.2 Page252 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.307.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

Byte 1-2: Test lasting time in second

Default value is 10 seconds

Byte 3-4: Size of the data packets. For BLE, the maximum

value is (512-3=509).For SPP, the maximum value is 672.

Default value is the maximum value.

Byte 5: Direction

1 - Down

0 - Up

Down means the data is from smart-phone to device.

Up means the data is from device to smart-phone.

Default value is 0.

Bytes 6: With or without response.

1 - with response

0 - without response

For BLE, 1 means the up test uses indication and the down

stream uses write request. 0 means the up test uses

notification.

For SPP, 1 means the data packet transmission has to wait

until getting the ACK of the last data packet.

Default value is 0.

Byte 7: Is to use the specific BLE connection parameter.

Only valid for BLE.

0 - No

1 - Yes

Default value: 1

Rev 1.2 Page253 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.308.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

Byte 8-9: min connection interval in ms. Only valid for BLE.

Default value 10

Byte 10-11: max connection interval in ms. Only valid for

BLE.

Default value 20

Byte 12-15: reserve

Throughput test data 0x800A Data Depends on the test data pattern of the configuration:

packet packet size

\- 4 0x00 Random data (default)

0x01 Pattern of alternating bits ‘11110000’

0x02 Pattern of alternating bits ‘10101010’

0x03 Pattern of All ‘1’ bits

0x04 Pattern of All ‘0’ bits

0x05 Pattern of alternating bits ‘00001111’

0x06 Pattern of alternating bits ‘0101’

The ACK of Throughput 0x800B 0 Only valid for SPP.

test data packet If the configuration of the SPP is “with response”. The data

packet transmission has to wait until getting the ACK of

the last data packet.

Throughput test done 0x800C 0 For up test, the device will send this cmd to inform smart-

phone that the test lasting time has arrived and the test is

done.

For down test, the smart-phone will send this cmd to

inform device that the test lasting time has arrived and

the test is done.

3. ` `**Throughput Test with Bestechnic**

Click these buttons in sequence after opening the APP, as shown in the following figure.

Rev 1.2 Page254 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.309.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 59 Bestechnic for Testing Throughput**

The THROUGH PUT interface is as follows.

Steps to test SPP throughput:

1. ` `Click Choose Spp Device(To test BLE throughput, click Choose Ble Device)
1. ` `Choose the device which to be tested.
1. ` `Click Connect Device

Rev 1.2 Page255 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.310.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 60 THROUGH PUT Interface**

The THROUGH PUT interface is as follows. The left is for upstream tests while the right is for downstream tests.

Ø Data size

Ø Response type

Ø Up-Throughput rate

Ø Down-Throughput rate

Ø ThroughPut Data

Ø Lasting time in second

Ø Data Size

Ø Is With response

Ø Through Up Start

Ø Through Down Start

Rev 1.2 Page256 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.311.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 61 SW Image Power Off Flow**

3. ` `**Throughput test with BES ThroughtPut**

BES ThroughtPut is dedicated to testing throughput.

After the phone is connected to Bluetooth, open the through put APP. Choose BLE or SPP

Rev 1.2 Page257 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.312.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 62 BES ThroughPut Main Interface**

Connect the Bluetooth to be tested.

**Figure 63 Choose Bluetooth**

Rev 1.2 Page258 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.313.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

After the connection, the interface is as follows

**Figure 64 SPP Test**

Real Test Value:

Ø Data size

Ø Response type

Ø Up-Throughput rate

Ø Down-Throughput rate

Config Value:

Ø ThroughPut Data

Ø Lasting time in second

Ø Data Size

Ø Is With response

Ø Through Up Start

Ø Through Down Start

Rev 1.2 Page259 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.314.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**OTA**
1. ` `**OTA Flash Memory Map**

**Figure 65 Main Flash Section**

There are four main flash sections:

1. ` `Secondary bootloader

Once programmed, it never changes. It is in charge of doing image mapping and jumping to the dedicated

image.

FLASH\_OTA\_BOOT\_INFO\_T is located at 0x1000, to tell the secondary bootloader which image area shall be

mapped and jumped to.

1. ` `A area and B area

Dual copy sections including the application image, voice prompt and other user binaries that needs to be

updated all-together over the OTA.

A and B areas have the same size and same start offset of each sub-sections.

As the BES QSPI controller support flash physical->logic address mapping, the OTA procedure could program

the new image to the area flip-flop according the current applied area.

1. ` `Volatile sections

To store the informations that are changing all over the lifetime. E.g. TWS & mobile pairing information,

Rev 1.2 Page260 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.315.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

volume, etc.

1. ` `Non-volatile sections

Never changed once programmed on the production line.

The factory section is always located at the last 4KB flash page, for the BES download tool to program the non-

volatile information: classic BT mac address, BT name. BLE mac address, BLE name. XTAL trim value.

The ANC audio configuration section is to store the ANC configuration and the ANC related calibration values

gathered from the production line.

1. ` `**OTA Flow**

The OTA flow chart is as follows:

**Figure 66 OTA Flow**

As the figure shows, the OTA flow is divided into 6 parts:

1. ` `Receive data over the air.

After the connection is established between the APP and OTA device, the OTA device receives the image sent

by APP.

1. ` `Write the data to flash.

OTA device writes the received data to flash.

1. ` `Receive all data.

If all data is received, end the transmission and disconnect the device. Otherwise, it continues to receive data.

Rev 1.2 Page261 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.316.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `Update boot information.

BES code will update FLASH\_OTA\_BOOT\_INFO\_T as follows when the whole upgrade packet is received,

distributed and verified:

magicNumber: the boot type. This value is changed from NORMAL\_BOOT to COPY\_NEW\_IMAGE after

upgrade.

imageSize: the size of image.

imageCrc: the CRC of image.

newImageFlashoffset: the offset where the new image is stored in flash.

boot\_word: Identify A area and B area, indicating the area of new image stored.

1. ` `Reboot.

Reboot the OTA device to select a new image.

1. ` `Boot up to set the new image.

No matter whether the image is in the A area or B area, the logical address for booting up is the address of the

A area. Therefore, the system checks the Boot word of FLASH\_OTA\_BOOT\_INFO\_T when the secondary

bootloader boots up. If Boot word is B, the system calls the QSPI controller API to map B physical area to A

logic area. Then all the access to the logic address belonging to A will actually access the physical address of B

area. If Boot word is A, it directly jumps to the application image via A logic address.

**Figure 67 Boot Area Selection**

1. ` `**OTA Protocol**
1. ` `**Framework**
1. ` `**Data Structure Type**

Little endian, for example, the image size is 0x1234, and the data order is 0x34 0x12.

Rev 1.2 Page262 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.317.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Data Transfer Path**

\- IOS APP

BLE: Using write requests to send data, and using notificaion to receive the feedback.

GATT OVER BR/EDR: Using the GATT command to send data and receive the responses

\- Android APP

BLE: Using write requests to send data, and using notificaions to receive the responses.

SPP: Using the SPP command to send data and receive the responses

1. ` `**OTA Command Type and Description**

**Table 95 OTA Command Type**

**APP command packet Device response packet**

Transmission resuming at break- 0x8C Transmission resuming at break-point 0x8D

point check verify response

Start OTA 0x80 Start OTA response 0x81

OTA configure 0x86 OTA configure response 0x87

Data packet 0x85

Segment CRC verify 0x82 Segment CRC verify response 0x83

Whole image CRC verify 0x88 OTA result response 0x84

Read flash content 0x89 Flash content response 0x8A

Data ack for SPP 0x8B

Transmission side selection 0x90 Side selection response 0x91

Image overwriting confirmation 0x92 Image overwriting response 0x93

Set OTA user 0x97 Set OTA user response 0x98

Get OTA protocol version 0x99 Response OTA protocol version 0x9A

Command details:

**Table 96 OTA Command Descriprion**

**Packet type Direction Description**

0x8C APP->device To check transmission resuming at break-point

0x8D Device->APP Transmission resuming at break-point verify response

0x80 APP->device Fetch OTA

0x81 Device->APP Inform APP that device is ready for OTA and provide

the basic information

0x86 APP->device Configure the following OTA flow

0x87 Device->APP OTA configure response

0x85 APP->device OTA Data packet

Rev 1.2 Page263 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.318.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.319.jpeg)*Software Development User Guide*

0x82 Device->APP Do the segment CRC check

0x83 APP->device Segment CRC verify response

0x88 Device->APP Ask the device to do whole image CRC check

0x84 APP->device OTA result response

0x89 Device->APP Read flash content

0x8A APP->device Flash content response

0x8B Device->APP Data ack for using SPP transfer path

0x8E APP->device Get current version

0x8F Device->APP Read version response

0x90 APP->device Select side

0x91 Device->APP Select side response

0x92 APP->device Confirm boot and overwrite image

0x93 Device->APP Response to overwrite command

0x97 APP->device Set OTA user

0x98 Device->APP Response to set OTA user command

0x99 APP->device Get OTA protocol version

0x9A Device->APP Response the OTA protocol version

1. ` `**OTA Command Packet Structure Definition**
1. ` `**Transmission Resuming at Break Point (Check Packet)**

**Table 97 Transmission Resuming at Break Point (Request Packet)**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x8c

2 10bit bit Length of the following data

2 22bit bit RFU(Reserved for Future Use), must be all 0 for now

3 4 uint32\_t MagicCode, should be 0x54534542

4 32 uint8\_t[32] Random code

5 4 uint32\_t Segmentsize

6 4 uint32\_t Crc32,crc of randomcode and segment size

1. ` `**Transmission Resuming at Break Point (Verification Response Packet)**

**Table 98 Transmission Resuming at Break Point (Verification Response Packet)**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x8d

2 10bit bit Length of the following data

2 22bit bit RFU, must be all 0 for now

Rev 1.2 Page264 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.320.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.321.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.322.jpeg)*Software Development User Guide*

3 4 uint32\_t Breakpoint, 0 if NOT a resuming transmission

4 32 uint8\_t[32] New random code if NOT a resuming transmission, otherwise

equal to 0

5 4 uint32\_t Crc32, crc of breakpoint and randomcode

1. ` `**Get a Current Version (Request Packet)**

**Table 99 Get a Current Version (Request Packet)**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x8e

2 10bit bit Length of the following data

2 22bit bit RFU(Reserved for Future Use), must be all 0 for now

3 4 uint32\_t MagicCode, should be 0x54534542

1. ` `**Get a Current Version (Response Packet)**

**Table 100 Get a Current Version (Response Packet)**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x8e

2 10bit bit Length of the following data

2 22bit bit RFU(Reserved for Future Use), must be all 0 for now

3 4 uint32\_t MagicCode, should be 0x54534542

4 1 uint8\_t 0x00: Stereo device

0x01: TWS device, current connected device is left earbud

0x02: TWS device, current connected device is right earbud

5 4 uint8\_t Version of the stereo device, or the left earbuds for the TWS

devices.

6 4 uint8\_t Version of the right earbud for the TWS devices.

1. ` `**Start an OTA Task (Request Packet)**

**Table 101 Start an OTA Task (Request Packet)**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x80

2 10bit bit Length of the following data

2 22bit bit RFU(Reserved for Future Use), must be all 0 for now

3 4 uint32\_t MagicCode, should be 0x54534542

4 4 uint32\_t Imagesize, size of image file - 4

Rev 1.2 Page265 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.323.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.324.jpeg)*Software Development User Guide*

5 4 uint32\_t Crc32ofimage, crc32 of the image, the image size is (size of

image file – 4)

1. ` `**Start an OTA Task (Response Packet)**

**Table 102 Start an OTA Task (Response Packet)**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x81

2 10bit bit Length of the following data

2 22bit bit RFU(Reserved for Future Use), must be all 0 for now

3 4 uint32\_t MagicCode, should be 0x54534542

4 2 uint16\_t SwVersion, software version

5 2 uint16\_t HwVersion, hardware version

6 2 uint16\_t MTU exchange result, APP will use it as the maximum data size

per data packet

1. ` `**OTA Configuration Packet**

**Table 103 OTA Configuration Packet**

**Order Length Type Description**

1 1 byte uint8\_t PacketType, should be 0x81

2 10 bit bit Length of the following data

2 22 bit bit RFU(Reserved for Future Use), must be all 0 for now

3 4 byte uint32\_t LengthOfFollowingData, The length of the OTA configuration

content, including the last CRC32

4 4 byte uint32\_t Startlocationtowriteimage, the offset of the flash to start

writing the image

5 1 bit bit Istoclearuserdata

5 1 bit bit Istorenamebt

5 1 bit bit Istorenameble

5 1 bit bit Istoupdatebtaddr

5 1 bit bit Istoupdatebleaddr

5 27 bit bit Reserved

6 32 byte uint8\_t Newbtname

7 32 byte uint8\_t Newblename

8 6 byte uint8\_t Newbtaddr

9 6 byte uint8\_t Newbleaddr

10 4 byte uint32\_t Crcofconfiguration

Rev 1.2 Page266 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.325.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.326.jpeg)*Software Development User Guide*

1. ` `**OTA Configuration Respone Packet**

**Table 104 OTA Configuration Respone Packet**

**Order Length Type Description**

1 1 uint8\_t Packettype, should be 0x87

2 10 bit bit Length of the following data

2 22 bit bit RFU, must be all 0 for now

3 1 uint8\_t Isconfigurationdone, 1 if the configuration has been done

successfully, otherwise, 0

1. ` `**Data Packet**

**Table 105 Data Packet Description**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x85

2 10 bit bit Length of the following data

2 22 bit bit RFU, must be all 0 for now

3 n uint8\_t OTA data

1. **Segment CRC Verification Packet**

**Table 106 Segment CRC Verification Packet**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x82

2 10 bit bit Length of the following data

2 22 bit bit RFU, must be all 0 for now

3 4 uint32\_t MagicCode, should be 0x54534542

4 4 uint32\_t Crc32ofsegment, crc32 of one segment

1. **Segement CRC Verification Response Packet**

**Table 107 Segement CRC Verification Response Packet**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x83

2 10 bit bit Length of the following data

2 22 bit bit RFU, must be all 0 for now

3 1 uint8\_t IsVerificationPassed, 1 is pass, 0 is fail

Rev 1.2 Page267 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.327.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.328.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.329.jpeg)*Software Development User Guide*

1. **Whole-image CRC Check Packet**

**Table 108 Whole-image CRC Check Packet**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x88

2 10bit bit Length of the following data, should be 0

2 22bit bit RFU, must be all 0 for now

1. **OTA Result Response Packet**

**Table 109 OTA Result Response Packet**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x84

2 10 bit bit Length of the following data

2 22 bit bit RFU, must be all 0 for now

3 1 uint8\_t Bit1 isVerificationPassed, 1 is pass, 0 is fail,

Bit2 is received size error,

Bit3 is write flash off set error,

Bit4 is segment verify error,

Bit5 is break point error,

Bit6 is image size error

1. **New-image Side Selection Packet**

**Table 110 New-image Side Selection Packet**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x90

2 10 bit bit Length of the following data

2 22 bit bit RFU, must be all 0 for now

3 1 uint8\_t 0x00: Apply stereo device

0x01: Apply left earbud only

0x10: Apply right earbud only

0x11: Apply both earbuds

1. **New-image Side Selection Response Packet**

**Table 111 New-image Side Selection Response Packet**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x91

Rev 1.2 Page268 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.330.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.331.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.332.jpeg)*Software Development User Guide*

2 10 bit bit Length of the following data

2 22 bit bit RFU, must be all 0 for now

3 1 uint8\_t IsAppliedSuccessfully, 1 is pass, 0 is fail

1. **Image Overwriting Confirmation Packet**

**Table 112 Image Overwriting Confirmation Packet**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x92

2 10 bit bit Length of the following data

2 22 bit bit RFU, must be all 0 for now

3 4 uint32\_t MagicCode, should be 0x54534542

1. **Image Overwriting Confirmation Response Packet**

**Table 113 Image Overwriting Confirmation Response Packet**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x93

2 10 bit bit Length of the following data

2 22 bit bit RFU, must be all 0 for now

3 1 uint8\_t IsVerificationPassed, 1 is pass, 0 is fail

1. **Set an OTA User**

**Table 114 Set an OTA User**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x97

2 10 bit bit Length of the following data

2 22 bit bit RFU, must be all 0 for now

3 1 uint8\_t 1 for FIRMWARE, 2 for

LANGUAGE\_PACKAGE

1. **Set an OTA Version (Response Packet)**

**Table 115 Set an OTA Version (Response Packet)**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x98

2 10 bit bit Length of the following data

2 22 bit bit RFU, must be all 0 for now

Rev 1.2 Page269 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.333.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.334.jpeg)*Software Development User Guide*

3 1 uint8\_t IsVerificationPassed, 1 is pass, 0 is fail

1. **Get an OTA Version**

**Table 116 Get an OTA Version**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x99

2 10 bit bit Length of the following data

2 22 bit bit RFU, must be all 0 for now

3 4 uint8\_t OTA protocol version on APP

1. **Get an OTA Version (Response Packet)**

**Table 117Get an OTA Version (Response Packet)**

**Order Length Type Description**

1 1 uint8\_t PacketType, should be 0x9A

2 10 bit bit Length of the following data

2 22 bit bit RFU, must be all 0 for now

3 4 uint8\_t OTA protocol version on APP

Rev 1.2 Page270 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.335.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Upgrade Process**
1. ` `**OTA Process Overview**

**Figure 68 Upgrade Process**

As shown in the preceding figure, the upgrade procedure is as follows:

1. ` `OTA Connection: The APP and OTA device establish a connection.
1. ` `Get an OTA protocol version: Get an OTA protocol version. The current latest version is 2.0.
1. ` `Set the OTA user: Select the upgrade section: image, voice prompts or both.
1. ` `Get the current version: Get the OTA device firmware version.
1. ` `Select a side:

If the OTA device is a stereo earphone or single earphone, select update once.

If the OTA device is an earphone and two earphones share a flash, select update once but double

response.

If the OTA device is an earphone and two earphones have independent flashes, select Two Image Turn

1. ` `Breakpoint check: Check the breakpoint, choose to send the whole image, or resume transmission from

the breakpoint. If transmission resumes, skip step 6 and 7.

1. ` `CMD START: Send the OTA start command.

Rev 1.2 Page271 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `CMD CONFIG: Send the OTA configure command.
1. ` `Send data: The APP send segement data to the OTA device.
1. ` `Segment check: The APP sends the segment CRC check code. If APP receives a reply that the segment data

is correct, turn to step 9 to send the next segment data. If APP receives a reply that the segment data is

uncorrect, return to step 9 to retransmit the previous segment. When the whole image transmission is

finished, turn to step 11.

1. ` `Image overwriting confirmation and disconnection: The APP sends the overwriting confirmation

command. If upgrade is successful, the APP recieves a disconnection event.

1. ` `Read the flash: Reboot and read the flash.

During the OTA process, the APP waits for a timeout period of 5 seconds, and if a reply is not received, the upgrade

fails.

The APP data flow and Device data flow are as follows:

App data flow ->

Device data flow <<<

1. ` `**OTA Connection**

è App establishes a connection with the OTA device.

If the phone supports MTU exchanges, send an exchange MTU command. The MTU value is 512 bytes. If not, go to

the next step.

1. ` `**Get an OTA Protocol Version**

è Get the OTA protocol version:

**99 // packet type**

**N // length of following data, should be 4 here**

**xx[4] // should be 00 00 00 01 for current version, 00 00 00 00 for legacy version**

<<< Get OTA protocol version response:

**9A // packet type**

**N // length of following data, should be 4 here**

**xx[4] // should be 00 00 00 01 for current version, 00 00 00 00 for legacy version**

1. ` `**Set an OTA User**

è Set the OTA user:

**97 // packet type**

**N // length of following data, should be 1 here**

**USER // 1 for FIRMWARE, 2 for LANGUAGE\_PACKAGE**

Rev 1.2 Page272 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

<<< Set the OTA user response:

**98 // packet type**

**N // length of following data, should be 1 here**

**Result // 0 for ok, other for fail**

1. ` `**Get a Current Version**

è Get the current version:

**8E // packet type**

**N // length of following data, should be 4 here**

**42 45 53 54 // magic code**

<<< Current version response

**8F // packet type**

**N // length of following data, should be 13 here**

**42 45 53 54 // magic code**

**0x // device type**

**xx[4] // stereo of left side version**

**xx[4] // right side version**

1. ` `**Select a Side**

è Select a side:

**90 // packet type**

**N // length of following data, should be 1 here**

**0x // side number**

<<< Side selection response

**91 // packet type**

**N // length of following data, should be 1 here**

**0x // status**

1. ` `**Break-point Check**

è Check transmission resuming at break-point:

Check packet:

**8C // packet type**

**N // length of following data, should be 36 here**

**42 45 53 54 // magic code**

**xx[32] // The random code generated by the device at last upgrade**

Waiting for device response

Rev 1.2 Page273 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.336.jpeg)*Software Development User Guide*

<<< Receive transmission-resuming verification response

Received data:

**8D // packet type**

**N // length of following data, should be 36 here**

**aa bb cc dd // breakpoint , 0 if NOT a resuming transmisson**

**xx[32]// new checkpoint If breakpoint equal to 0, otherwise equal to 0.**

If the breakpoint in response is NOT 0, the checkpoint in response doesn’t need to be recorded, then transmit

the remaining image from the breakpoint

If the breakpoint in response is 0, the App needs to record the new checkpoint in response firstly,and transmit

the whole image

1. ` `**CMD START**

è Start the OTA process

Request packet:

**80 // packet type**

**N // length of following data, should be 8 here**

**42 45 53 54 // magic code**

**xx yy mm nn // image data size, it’s image file size - 4**

**aa bb cc dd // CRC32 value**

<<< Receive the response within 2 seconds.

Received data:

**81 // PacketType**

**N // length of following data, should be 10 here**

**42 45 53 54 // magic code**

**aa bb // SwVersion**

**cc dd // HwVersion**

**xx yy // MTU, the maximum size per packet during the OTA**

Send the OTA process configuration information according to the contents of the configuration UI. The

configuration information is as follows:

xx yy mm nn // The length of the following OTA configuration content, including the last CRC32

aa bb cc dd // the offset of the flash to start writing the image,

ee ff gg hh // enable switch, bit is 1 means enable, bit is 0 means disable:

// bit 0-isToClearUserData

// bit 1-isToRenameBT

// bit 2-isToRenameBLE

Rev 1.2 Page274 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

// bit 3-isToUpdateBTAddr

// bit 4-isToUpdateBLEAddr

BT name, size is 32 bytes // If isToRenameBT bit is 0, BT name is zero

BLE name, size is 32 bytes // If isToRenameBLE bit is not selected, BLE name is zero

BT mac addr, size is 6 bytes // If isToUpdateBTAddr bit is not selected, BT mac is zero

BLE mac addr, size is 6 bytes // If isToUpdateBLEAddr bit is not selected, BLE mac is zero

CRC32 // CRC32 values for all of the above configuration contents

1. ` `**CMD CONFIG**

è Send the configuration command:

**86 // packet type**

**N // length of following data**

**Configure content // The number of the packets are decided by the size of the received MTU, until all**

**the configuration content are sent**

Waiting for device response

<<< Receive the response from the device

**87 // packet type**

**N // length of following data, should be 1 here**

**Aa // 1 if the configuration has been done successfully, otherwise, 0**

If the response is 1, the APP starts sending OTA data.

If the response is 0, the OTA process fails.

1. **Send Data**

è Send OTA data

**85 // packet type**

**N // length of following data**

**data // maximum value is MTU-3, the actual value depends on the segment size.**

One segment is 1% of the image size, used as the unit of the segment CRC check.

In order to be compatible with the property of the flash programming that data needs to be programmed in

the unit of 256 bytes page, the segment size needs to be coordinated to be 256 bytes aligned.

So there are (Segment Size + (MTU – 1) – 1) /(MTU – 1) data packets per segment, and the size of the last data

packet in the segment is Segment Size – (n-1)\*(MTU-1).

1. **Segment Check**

è Send the segment CRC check command

CRC check packet:

Rev 1.2 Page275 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**82 // packet type**

**N // length of following data, should be 8 here**

**42 45 53 54 // magic code**

**aa bb cc dd // The CRC32 value of the segment data sent before**

Waiting for device response

<<< Receive the CRC check response

Received data:

**83 // packet type**

**N // length of following data, should be 1 here**

**xx // CRC result: 01 is successful, 00 is failed**

If the response is 01, continue with the next segment of the data packets.

If the response is 00, retransmit the current segment.

1. **Image Overwriting Confirmation and Disconnection**

è Image overwriting confirmation packet:

**92 //packet type**

**N // length of following data, should be 4 here**

**42 45 53 54 // magic code**

Waiting for a reply.

<<< Image overwriting confirmation response:

Received data:

**93 // packet type**

**N // length of following data, should be 1 here**

**Xx // isVerificationPassed, 1 is pass, 0 is fail**

If the upgrade is successful, the APP display is successful and initiates the disconnection.

<<< The device receives a disconnected event and reboots to use the new image.

1. **Read Flash Data**

è Read flash content:

**89 // packet type**

**N // length of following data, should be 9 here**

**Xx // 1 for start reading, 0 for stop reading**

**aa bb cc dd // small endian, start offset of the flash to read**

**ee ff gg hh // small endian, size of flash content to read**

Rev 1.2 Page276 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

Waiting for a reply.

<<< response:

**8A // packet type**

**N // length of following data, max value is 128**

**uint8\_t[N] // flash content**

**8A // packet type**

**N // length of following data, max value is 128**

**uint8\_t[N] // flash content**

**…**

Repeat response to APP until required data length reaches

1. ` `**OTA User Guide**
1. ` `**Image Config and Burning Option**

There are two kinds of OTAs:

OTA and TOTA OTA

Different from OTA, TOTA OTA is based on TOTA. The following section describes the usage of these two OTAs

respectively.

1. ` `OTA

Before the executable image file is generated, some basic configuration of target.mk is required to support

OTA upgrade.

BES\_OTA ?= 1

If it is an iphone, and the OTA device is upgraded by GATT OVER BR/EDR, and two macro switches

GATT\_OVER\_BR\_ERD and IS\_BLE\_TOTA\_ENABLED also need to be configured in target.mk.

GATT\_OVER\_BR\_EDR ?= 1

TOTA ?= 0

TOTA\_v2 ?= 0

1. ` `TOTA OTA

Before the executable image file is generated, some basic configuration of target.mk is required to support

TOTA OTA upgrade.

BES\_OTA=1 GATT\_OVER\_BR\_EDR ?= 1

TOTA\_v2 ?= 1

OTA\_OVER\_TOTA\_ENABLED ?= 1

Rev 1.2 Page277 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.337.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

If it is an iphone, and the OTA device is upgraded by GATT OVER BR/EDR, and the macro switch

GATT\_OVER\_BR\_ERD also need to be enabled in target.mk.

GATT\_OVER\_BR\_EDR ?= 1

After generating the executable image file, the ota\_boot.bin needs to be generated by compiling the command “make

T=ota\_boot DEBUG=0”. DEBUG must be set 0 to make the generated file less than 96KB, depending on its storage

space.

After generating the image file and ota\_boot.bin, these two files need to be burned to the flash together.

**Figure 69 Burn with OTA BOOT**

1. ` `**Operating Instructions**
1. ` `**OTA Base on Android**
1. ` `**Install and Open the APP**

Install the APP named Bestechnic. Open it, enter the main view and click “**OTA**”.

Choose version2.0 because BES devices no longer support Version1.0.

The OTA device can be upgraded in two ways: SPP OTA and BLE OTA. Most of the steps are the same. Some differences

are explained in the following section.

Rev 1.2 Page278 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.338.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 70 Main View**

1. ` `**Bluetooth Pairing**

If you choose BLE OTA, skip this step.

Press and hold the “**PWR\_ON**” button. When hearing the “**pairing**” tone after the “**power on**” tone, pair the OTA device

with phone.

**Figure 71 Pairing**

Rev 1.2 Page279 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.339.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Select a Device**

Click **“Please Select Device”** and choose OTA device, then the selected device’s name and address are viewed as

follows:

**Figure 72 Device Selection**

1. ` `**Configure Upgrade**

\- Select OTA USER:

firmware: Only image.

language: Only voice prompt.

combo: Combo image and voice prompt.

\- Select RESPONSE:

without: No response.

with: Have response.

\- Select Upgrade Type:

normal: Normal upgrading rate, user can use OTA device normally in this mode.

fast: Faster upgrading rate but disable some function, such as voice calls.

Rev 1.2 Page280 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.340.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 73 Configure Upgrade**

1. ` `**Connect a Device**

Click “**Connect Device**”.

After a few seconds, the firmware version of OTA device are viewed as follows if the connection is successful.

**Figure 74 Device Connection**

1. ` `**Select an Image**

Click “**select**” to select the new image.

Rev 1.2 Page281 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.341.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 75 Image Selection**

1. ` `**Start the OTA Process**

Click “**Start OTA”**, and an option box appears. The content of the option box can edited only when the corresponding

checkbox is selected with “**Y**”. Click “**OK**” to start upgrading.

**Figure 76 Start OTA Process**

1. ` `**Finish the OTA Process**

When the upgrade is completed, the new application image is applied and the rebooting to execute the new image is

automatically done.

Rev 1.2 Page282 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.342.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 77 OTA Process Completed**

1. ` `**OTA Base on iOS**
1. ` `**Install and open the APP**

Install the APP named Bestechnic. Open it, enter the main view and click “**OTA**”.

Choose version2.0 because BES devices no longer support Version1.0.

The OTA device can be upgraded in two ways: GATT OVER BR/EDR OTA and BLE OTA. Most of the steps are the same,

and some differences are explained in the following section.

**Figure 78 Main View**

Rev 1.2 Page283 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.343.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Bluetooth Pairing and Connection**

If you choose BLE OTA, skip this step.

Press and hold the “**PWR\_ON**” button. When hearing the “**pairing**” tone after the “**power on**” tone, pair the OTA device

with iphone.

**Figure 79 Pairing and Connection**

1. ` `**Select a Device**

Click **“Choose Device”** and select the OTA device, then the selected device’s name can be viewed as follows:

**Figure 80 Device Selection**

Rev 1.2 Page284 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.344.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Configure Upgrade**

\- Select OTA USER:

firmware: Only image.

language: Only voice prompt.

combo: Combo image and voice prompt.

\- Select RESPONSE:

without: No response.

with: Have response.

\- Select Upgrade type:

normal: Normal upgrade rate. Users can use OTA device normally in this mode.

fast: Faster upgrade rate but disable some function, such as voice calls.

**Figure 81 Configure Upgrade**

1. ` `**Connect a Device**

Click “**Connect Device”.**

After a few seconds, the firmware version of OTA device can be viewed as follows if the connection is successful.

Rev 1.2 Page285 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.345.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 82 Device Connection**

1. ` `**Select an Image**

Click “**select**” to select the new image.

**Figure 83 Image Selection**

1. ` `**Start the OTA Process**

Click “**Start OTA”**, and an option box appears. The content of the option box can edited only when the corresponding

checkbox is selected with “**Y**”. Click “**OK**” to start upgrading.

Rev 1.2 Page286 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.346.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 84 Start OTA Process**

1. ` `**Finish the OTA Process**

When the upgrade is completed, the new application image is applied and the rebooting to execute the new image is

automatically done.

**Figure 85 Upgrade Completed**

Rev 1.2 Page287 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.347.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**TOTA OTA Base on Android**
1. ` `**Install and open the APP**

Install the APP named Bestechnic. Open it, enter the main view and click “**OTA**”.

Choose version2.0 because BES devices no longer support Version1.0.

There are two kinds of TOTA OTA: SPP OTA and BLE TOTA OTA. Most of the steps are the same, and some differences

are explained in the following section.

**Figure 86 Main View**

1. ` `**Bluetooth Pairing and Connection**

If you choose BLE TOTA OTA, skip this step.

Press and hold the “**PWR\_ON**” button. When hearing the “**pairing**” tone after the “**power on**” tone, pair the OTA device

with phone.

Rev 1.2 Page288 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.348.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 87 Pairing**

1. ` `**Select a Device**

Click **“Please Select Device”** and choose OTA device, then the selected device’s name and address can be viewed as

follows:

**Figure 88 Device Selection**

1. ` `**Configure Upgrade**

\- Select OTA USER:

firmware: Only image.

language: Only voice prompt.

Rev 1.2 Page289 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.349.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

combo: Combo image and voice prompt.

\- Select RESPONSE:

without: No response.

with: Have response.

\- Select Upgrade type:

normal: Normal upgrading rate. Users can use OTA device normally in this mode.

fast: Faster upgrading rate but disable some function, such as voice calls.

**Figure 89 Configure Upgrade**

1. ` `**Connect a Device**

Click “**Connect Device**”.

After a few seconds, the firmware version of OTA device can be viewed as follows if the connection is successful.

Rev 1.2 Page290 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.350.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 90 Device Connection**

1. ` `**Select an Image**

Click “**select**” to select the new image.

**Figure 91 Image Selection**

1. ` `**Start the OTA Process**

Click “**Start OTA”**, and an option box appears. The content of the option box can edited only when the corresponding

checkbox is selected with “**Y**”. Click “**OK**” button to start upgrading.

Rev 1.2 Page291 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.351.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 92 Start OTA Process**

1. ` `**Finish the OTA Process**

When the upgrade is completed, the new application image is applied and the rebooting to execute the new image is

automatically done.

**Figure 93 OTA Completed**

Rev 1.2 Page292 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.352.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**TOTA OTA Base on IOS**
1. ` `**Install and open the APP**

Install the APP named Bestechnic. Open it, enter the main view and click “**OTA**”.

Choose version2.0 because BES devices no longer support Version1.0.

There are two kinds of TOTA OTA: GATT OVER BR/EDR TOTA OTA and BLE TOTA OTA. Most of the steps are the same,

and some differences are explained in the following section.

**Figure 94 Main View**

1. ` `**Bluetooth Pairing and Connection**

If you choose BLE TOTA OTA, skip this step.

Press and hold the “**PWR\_ON**” button. When hearing the “**pairing**” tone after the “**power on**” tone, pair the OTA device

with iphone.

Rev 1.2 Page293 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.353.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 95 Pairing and Connection**

1. ` `**Select a Device**

Click **“Choose Device”** and select the OTA device, then the selected device’s name can be viewed as follows:

**Figure 96 Device Selection**

1. ` `**Configure upgrade**

\- Select OTA USER:

firmware: Only image.

language: Only voice prompt.

combo: Combo image and voice prompt.

Rev 1.2 Page294 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.354.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

\- Select RESPONSE:

withoutResponse: No response.

withRespons: Have response.

\- Select Upgrade type:

normal: Normal upgrade rate. Users can use OTA device normally in this mode.

fast: Faster upgrade rate but disable some functions, such as voice calls.

**Figure 97 Configure Upgrade**

1. ` `**Connect a Device**

Click “**Connect Device”.**

After a few seconds, the firmware version of OTA device can be viewed as follows if the connection is successful.

Rev 1.2 Page295 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.355.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 98 Device Connection**

1. ` `**Select an Image**

Click “**select**” to select the new image.

If you select multiple devices, multiple buttons can be viewed to select multiple OTA files. There are only two buttons

here because only one OTA device was selected. The top button is used to select OTA files for all OTA devices. If you

want to select different OTA files for different devices, click the button corresponding to the device to select OTA file

respectively.

**Figure 99 Image Selection**

Rev 1.2 Page296 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.356.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Start the OTA Process**

Click “**Start OTA”**, and an option box appears. The content of the option box can edited only when the corresponding

checkbox is selected with “**Y**”. Click “**OK**” button to start upgrading.

**Figure 100 Start OTA Process**

1. ` `**Finish the OTA Process**

When the upgrade is completed, the new application image is applied and the rebooting to execute the new image is

automatically done.

**Figure 101 Upgrade Completed**

Rev 1.2 Page297 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.357.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**TOTA**
1. ` `**TOTA Protocol**

\- TOTA packet

The dongle packet has a maximum length of 208 bytes, and the data content has a maximum length of 192 bytes, as

defined in the following macro in “app\_tota.cpp”:

#define DONGLE\_PACKET\_FRAME 208

#define DONGLE\_DATA\_FRAME 192

Packet format:

**Figure 102 TOTA Packet Format**

A basic rate packet consists of 5 entities: the HEAD, the dataLen, the data, the crc and the TAIL.

Head and Tail are used to distinguish a packet of data. Data is encrypted and can be decrypted only after receiving the

entire packet.

The data fields include cmdCode, dataLen and param.

cmdCode: tota command

dataLen: param length

param: cmdCode parameter

Note that the dataLen in the data field does not necessarily correspond to the dataLen in the packet due to encryption

and subcontracting:

Encryption requires 16-byte alignment. If the value is less than 16 bytes, fill in 0. So the packet length contains padding

bytes in addition to content. If the data content is larger than 192 bytes, the packet must be subcontracted and sent.

The length of the first packet is 208 bytes (the data part is 192 bytes, and no padding is required). The last packet is

filled with bytes before transmission.

\- Information interaction between the Dongle and earbuds

Rev 1.2 Page298 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.358.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.035.jpeg)*Software Development User Guide*

The TOTA test between the Dongle and the earbuds uses SPP connection. After the SPP connection, the secret key is

negotiated through BASIC commands, and then other commands are encrypted and transmitted.

The communication process is as follows:

1. ` `SPP is connected, but TOTA is not connected. Only the BASIC CMD is allowed to interact with each other, and other

commands are filtered out.

1. ` `Complete TOTA connection and encryption through the BASIC CMD. The interaction process is shown in the following

figure.

1. ` `Encrypt and transmit data.

The Dongle communicates with the earbuds only through CMD and RSP, and there is no other message such as ACK.

**Figure 103 Interaction Process of TOTA Test**

For the read command, the earbuds directly respond if the command is successfully executed. If the earbuds fail to

execute, the response cmd is returned with the error number. For write or set commands, the earbuds return the

response cmd with the execution result.

\- Test handler function format

Define the code segment “tota\_handler\_table” to which all handlers are added. When you receive the total command,

look for the corresponding handler in this section.

#define TOTA\_COMMAND\_TO\_ADD(cmdCode, cmdHandler, isNeedResponse,

timeoutWaitingRspInMs,

cmdRspHandler) \

static const APP\_TOTA\_CMD\_INSTANCE\_T cmdCode##\_entry \_\_attribute\_\_((used,

section(".tota\_handler\_table"))) = \

{(cmdCode), (cmdHandler), (isNeedResponse), (timeoutWaitingRspInMs),

(cmdRspHandler)};

Rev 1.2 Page299 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.359.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.035.jpeg)*Software Development User Guide*

extern uint32\_t \_\_tota\_handler\_table\_start[];

extern uint32\_t \_\_tota\_handler\_table\_end[];

Test handler function format:

typedef struct

{

uint32\_t cmdCode;

app\_tota\_cmd\_handler\_t cmdHandler; /\*\*< command handler function \*/

uint16\_t isNeedResponse; /\*\*< true if needs the response from the peer

device \*/

uint16\_t timeoutWaitingRspInMs; /\*\*< time-out of waiting for response in

milli-seconds \*/

app\_tota\_cmd\_response\_handler\_t cmdRspHandler; /\*\*< command response

handler function \*/

} APP\_TOTA\_CMD\_INSTANCE\_T;

\- Processes of receiving and sending messages

The receiving process is shown in the following figure:

**Figure 104 Message Receiving Process**

The data received by SPP is stored in “totaEnv.rxDataQueue” to cache data packets.

Call the unpack function, process the data according to the connection status, and save the packet to the

“totaEnv.rxDataQueue”.

If the connection status is TOTA\_CONNECTED, the data is cached directly.

If the connection status is TOTA\_SHAKE\_HANDED, the packet needs to be decrypted and cached.

Call the parsing function to parse the packet.

Packet-receiving handler function:

//receiving spp packet

void s\_app\_tota\_rx(uint8\_t \* cmd\_buf, uint16\_t len)

//buffer queue

int tota\_rx\_queue\_push(uint8\_t \*buff, uint16\_t len)

//unpacking

int app\_tota\_rx\_unpack(uint8\_t \* pdata, uint16\_t dataLen)

//cache packet

Rev 1.2 Page300 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.360.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.065.jpeg)*Software Development User Guide*

TOTA\_STORE\_STATUS\_E app\_tota\_store(uint8\_t \* pdata, uint16\_t dataLen)

//command handler function

APP\_TOTA\_CMD\_RET\_STATUS\_E app\_tota\_cmd\_received(uint8\_t\* ptrData, uint32\_t

dataLength)

The sending process is shown in the following figure:

**Figure 105 Message Sending Process**

For large data packets, they need to be unpacked first.

Packet-sending handler function:

//sending function

bool app\_tota\_send(uint8\_t \* pdata, uint16\_t dataLen, APP\_TOTA\_CMD\_CODE\_E

opCode)

bool app\_tota\_send\_rsp(APP\_TOTA\_CMD\_CODE\_E rsp\_opCode,

APP\_TOTA\_CMD\_RET\_STATUS\_E rsp\_status,

uint8\_t \* pdata, uint16\_t dataLen)

bool app\_tota\_data\_send(APP\_TOTA\_CMD\_CODE\_E opCode, uint8\_t \* data,

uint16\_t dataLen)

//encrypt function

uint16\_t tota\_encrypt(uint8\_t \* out, uint8\_t \* in, uint16\_t inLen)

//pack function

uint16\_t app\_tota\_tx\_pack(uint8\_t \* pdata, uint16\_t dataLen)

//spp sending function

bool app\_spp\_tota\_send\_data(uint8\_t\* ptrData, uint16\_t length)

1. ` `**TOTA User Guide**
1. ` `To make firmware best1600\_ibrt.bin, use the compilation instruction:

"make T=best1600\_ibrt TOTA\_v2=1 POWER\_ON\_ENTER\_TWS\_PAIRING\_ENABLED=1 BLE=1 -j"

bin path: /out/best1600\_ibrt/best1600\_ibrt.bin

1. ` `Burn the firmware best1600\_ibrt.bin into the earbuds.
1. ` `In the OTA function of the App, the option with TOTA is TOTA\_v2 by default, such as BLE TOTA OTA;

In the App code, the TOTA\_v2 function is determined by the totaConnect and useTotaV2 attributes in

Rev 1.2 Page301 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.361.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

"BesServiceConfig". TOTA\_v2 is enabled if both attributes are set to YES.

1. ` `Click Choose Device to choose a device, and click Connect Device to connect the device. The process of

establishing a TOTA connection can be seen through the App console or the log in the headset.

APP name: Bestechnic.

IOS App:

**Figure 106 IOS App Operation Process**

Android App:

Rev 1.2 Page302 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.362.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 107 Android App Operation Process**

1. ` `The App console log is shown as follows. The connection process of TOTA\_v2 can be understood through the short

line, and receiving the long line command indicates that the TOTA connection is successful.

**Figure 108 App Console Log**

1. ` `The following firmware serial port log shows corresponding to the App log. The short line part is the same as THE

App. If "tota connect success" is displayed, the TOTA connection is successful.

Rev 1.2 Page303 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.363.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 109 Firmware Serial Port Log**

1. ` `**Add a Custom UART Command**

Uart commands are used to implement corresponding functions. You can add the command string and its

corresponding function to the structure array.

static const ble\_audio\_uart\_handle\_with\_param\_t

aob\_uart\_test\_handle\_with\_param[]=

{

// Example: [AOB,mobile\_connect|214 204 251 165 185 226]

{"mobile\_connect", ble\_audio\_mobile\_connect\_test},

{"mobile\_disconnect", ble\_audio\_mobile\_disconnect\_test},

}

Here is an example to show how to add a custom uart command list (support parameters) with a prefix string.

The function ble\_audio\_uart\_cmd\_init can call the function app\_trace\_rx\_register with two arguments: the prefix name

and its callback function ble\_audio\_uart\_cmd\_callback.

void ble\_audio\_uart\_cmd\_init(void)

{

#ifdef APP\_TRACE\_RX\_ENABLE

TRACE(0,"ble\_audio\_uart\_cmd\_init");

app\_trace\_rx\_register("AOB", ble\_audio\_uart\_cmd\_callback);

#endif

}

For the format of the UART instruction with arguments, the callback function calls the function

ble\_audio\_uart\_cmd\_with\_param\_handler to match the input character instruction in UART with the prefix string

Rev 1.2 Page304 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.364.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

defined in the aob\_uart\_test\_handle\_with\_param array. When the same string is found, the corresponding function

instruction is executed.

ble\_audio\_uart\_test\_function\_handle\_with\_param

ble\_audio\_test\_find\_uart\_handle\_with\_param(char\* buf)

{

ble\_audio\_uart\_test\_function\_handle\_with\_param p = NULL;

for(uint32\_t i = 0; i < ARRAY\_SIZE(aob\_uart\_test\_handle\_with\_param);

i++)

{

if (strncmp((char\*)buf, aob\_uart\_test\_handle\_with\_param[i].string,

strlen(aob\_uart\_test\_handle\_with\_param[i].string))==0 ||

strstr(aob\_uart\_test\_handle\_with\_param[i].string, (char\*)buf))

{

TRACE(1, "AOB cmd:%s",

aob\_uart\_test\_handle\_with\_param[i].string);

p = aob\_uart\_test\_handle\_with\_param[i].function;

break;

}

}

return p;

}

1. ` `**Debugging Methods**
1. ` `**UART Log Print**
1. ` `**Crash Analysis**
1. ` `**Exception Analysis**

Exception refers to the abnormal interrupt generated by the CPU, which includes the following four types:

1. ` `Hard Fault
1. ` `Mem Manage Fault
1. ` `Bus Fault
1. ` `Usage Fault

The CPU saves the status of the system interrupt in SHCSR (System Handler Control and Status Registers). The bit that is

set to 1 indicates the fault that occurred.

Rev 1.2 Page305 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.365.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 110 SHCSR Bit Assignmonts**

1. ` `**Hard Fault**

For the cause of Hard Fault, you can query the register HFSR, as shown in the following figure.

There are two reasons for the CPU to generate Hard Fault:

1. ` `VECTTBL

This reason means that when the interrupt is triggered, the CPU encounters Bus Fault when reading the

interrupt vector from the vector table.

1. ` `FORCED

This reason means that when other faults are triggered, the faults cannot be responded to due to lower

priority or interrupts being turned off. Therefore, Hard Fault is triggered. Because the priority of the Hard

Fault interrupt is -1, which is second only to the Reset interrupt and NMI interrupt, the Hard Fault interrupt is

not masked. When other fault interrupts cannot be responded to, the Hard Fault interrupt is triggered to

stop the CPU.

Therefore, when encountering an exception caused by this reason, you also need to check other Fault states

and reasons.

**Figure 111 HardFault Status Register**

Rev 1.2 Page306 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.366.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Table 118 HFSR Bit Assigments**

**Bits Name Function**

[31] DEBUGEVT Reserved for Debug use. When writing to the register you must write 0 to this

bit, otherwise the behavior is unpredictable.

[30] FORCED Indicates a forced hard fault, generated by escalation of a fault with configurable

priority that cannot be handled, because of priority or because it is disabled:

0 = no forced HardFault

1 = forced HardFault.

When this bit is set to 1, the HardFault handler must read the other fault status

registers to find the cause of the fault.

[29:2] - Reserved.

[1] VECTTBL Indicates a BusFault on a vector table read during exception processing:

0 = no BusFault on vector table read

1 = BusFault on vector table read.

This error is always handled by the hard fault handler.

When this bit is set to 1, the PC value stacked for the exception points to the

instruction that was preempted by the exception.

[0] - Reserved

1. ` `**Mem Manage Fault**

For the cause of Mem Manage Fault, you can query the register MMFSR, as shown in the following figure.

There are many reasons for Mem Manage Fault.

Common reasons:

1. ` `IACCVIOL

This reason means that the access address is the MPU protection area when the CPU fetches instructions.

1. ` `DACCVIOL

This reason means that when the CPU reads or writes data, the access address is the MPU protected area.

Other reasons:

1. ` `MUNSTKERR

This reason means that when returning from an interrupt, the CPU accesses the MPU protection area when

restoring the thread stack.

1. ` `MSTKERR

This reason means that when entering the interrupt, the CPU accesses the MPU protection area when

pushing the stack.

Rev 1.2 Page307 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.367.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `MLSPERR

This reason means that the MPU protection area is accessed when the reduced FPU is pushed and popped.

As the following figure shows, the bit 7 of MMFSR is the MMARVALID signal, which indicates whether the MMAR is

valid. If it is valid, the illegally accessed address is stored in the MMAR. For example, if the 0 address is illegally

accessed, 0 is stored in the MMAR.

**Figure 112 MemManage Fault Status Register**

**Table 119 MMFSR Bit Assignments**

**Bits Name Function**

[7] MMARVALID MemManage Fault Address Register (MMFAR) valid flag:

0 = value in MMAR is not a valid fault address

1 = MMAR holds a valid fault address.

If a MemManage fault occurs and is escalated to a HardFault because of priority,

the HardFault handler must set this bit to 0. This prevents problems on return to

a stacked active MemManage fault handler whose MMAR value has been

overwritten.

[6] - Reserved

[5] MLSPERR 0 = no MemManage fault occurred during floating-point lazy state preservation

1 = a MemManage fault occurred during floating-point lazy state preservation.

[4] MSTKERR MemManage fault on stacking for exception entry:

0 = no stacking fault

1 = stacking for an exception entry has caused one or more access violations.

When this bit is 1, the SP is still adjusted but the values in the context area on

the stack might be incorrect. The processor has not written a fault address to the

MMAR.

[3] MUNSTKERR MemManage fault on unstacking for a return from exception:

0 = no unstacking fault

1 = unstack for an exception return has caused one or more access violations.

This fault is chained to the handler. This means that when this bit is 1, the

original return stack is still present. The processor has not adjusted the SP from

Rev 1.2 Page308 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.368.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

the failing return, and has not performed a new save. The processor has not

written a fault address to the MMAR.

[2] - Reserved

[1] DACCVIOL Data access violation flag:

0 = no data access violation fault

1 = the processor attempted a load or store at a location that does not permit

the operation.

When this bit is 1, the PC value stacked for the exception return points to the

faulting instruction. The processor has loaded the MMAR with the address of the

attempted access.

[0] IACCVIOL Instruction access violation flag:

0 = no instruction access violation fault

1 = the processor attempted an instruction fetch from a location that does not

permit execution.

This fault occurs on any access to an XN region, even when the MPU is disabled

or not present.

When this bit is 1, the PC value stacked for the exception return points to the

faulting instruction. The processor has not written a fault address to the MMAR.

Taking bes1600\_ibrt which is ARM\_ARCH\_8M architecture as an example, the MPU protection area in the BES code is

shown in the following code. The area from address 0 to ROM BASE area is executable only, and the RAMX area is

readable and executable. So when you write a value to any address in the RAMX area, the Mem Manage Fault is

triggered.

typedef struct

{

uint32\_t addr;

uint32\_t len;

// MPU attribute

enum MPU\_ATTR\_T ap\_attr;

// memory attribute

enum MEM\_ATTR\_T mem\_attr;

} mpu\_regions\_t;

#define ROM\_DATA\_MAP\_BASE 0x20000

#define RAM\_TOTAL\_SIZE 0xE0000

static const mpu\_regions\_t mpu\_boot\_table[] = {

{0, ROM\_DATA\_MAP\_BASE, MPU\_ATTR\_EXEC, MEM\_ATTR\_INT\_SRAM },

{RAMX\_BASE, RAM\_TOTAL\_SIZE, MPU\_ATTR\_READ\_EXEC, MEM\_ATTR\_INT\_SRAM },

Rev 1.2 Page309 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

};

1. ` `**Bus Fault**

For the cause of Bus Fault, you can query the register BFSR, as shown in the following figure.

There are many reasons for Bus Fault.

Common reasons:

1. ` `IBUSERR

Instruction bus error. The CPU accesses an illegal address when fetching an instruction.

1. ` `PRECISERR

Data bus error. The CPU accesses an illegal address when reading and writing data.

1. ` `IMPRECISERR

Data bus error. The difference from 2 is that the address accessed by the data bus has nothing to do with the

currently executing instruction.

Other reasons:

1. ` `UNSTKERR

This reason means that the CPU resumes the thread stack with an illegal address access when exiting from an

interrupt.

1. ` `STKERR

This reason means that the CPU pushes the stack and there is an illegal address access when entering the

interrupt.

1. ` `LSPERR

This reason means that the CPU access illegal address when the compact FPU is pushed and popped.

Bus Fault is very similar to Mem Manage Fault. The only difference is whether the accessed address is protected by

MPU or cannot be found on the address bus.

The bit 7 of BFSR is the BFARVALID signal, which indicates whether BFAR is valid. If it is valid, BFAR saves the address of

illegal access. For example, if address 0 is illegally accessed, 0 is saved in BFAR.

Rev 1.2 Page310 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.369.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 113 BusFault Status Register**

**Table 120 BFSR Bit Assignments**

**Bits Name Function**

[7] BFARVALID BusFault Address Register (BFAR) valid flag:

0 = value in BFAR is not a valid fault address

1 = BFAR holds a valid fault address.

The processor sets this bit to 1 after a BusFault where the address is known.

Other faults can set this bit to

0, such as a MemManage fault occurring later.

If a BusFault occurs and is escalated to a hard fault because of priority, the hard

fault handler must set this bit to 0. This prevents problems if returning to a

stacked active BusFault handler whose BFAR value has been overwritten.

[6] - Reserved

[5] LSPERR 0 = no bus fault occurred during floating-point lazy state preservation

1 = a bus fault occurred during floating-point lazy state preservation.

[4] STKERR BusFault on stacking for exception entry:

0 = no stacking fault

1 = stacking for an exception entry has caused one or more BusFaults.

When the processor sets this bit to 1, the SP is still adjusted but the values in the

context area on the stack might be incorrect. The processor does not write a

fault address to the BFAR.

[3] UNSTKERR BusFault on unstacking for a return from exception:

0 = no unstacking fault

1 = unstack for an exception return has caused one or more BusFaults.

This fault is chained to the handler. This means that when the processor sets this

bit to 1, the original return stack is still present. The processor does not adjust

the SP from the failing return, does not performed a new save, and does not

write a fault address to the BFAR.

Rev 1.2 Page311 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.370.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

[2] IMPRECISERR Imprecise data bus error:

0 = no imprecise data bus error

1 = a data bus error has occurred, but the return address in the stack frame is not

related to the instruction that caused the error.

When the processor sets this bit to 1, it does not write a fault address to the

BFAR.

This is an asynchronous fault. Therefore, if it is detected when the priority of the

current process is higher than the BusFault priority, the BusFault becomes

pending and becomes active only when the processor returns from all higher

priority processes. If a precise fault occurs before the processor enters the

handler for the imprecise BusFault, the handler detects both IMPRECISERR set to

1 and one of the precise fault status bits set to 1.

[1] PRECISERR Precise data bus error:

0 = no precise data bus error

1 = a data bus error has occurred, and the PC value stacked for the exception

return points to the instruction that caused the fault.

When the processor sets this bit is 1, it writes the faulting address to the BFAR.

[0] IBUSERR Instruction bus error:

0 = no instruction bus error

1 = instruction bus error.

The processor detects the instruction bus error on prefetching an instruction, but

it sets the IBUSERR flag to 1 only if it attempts to issue the faulting instruction.

When the processor sets this bit is 1, it does not write a fault address to the

BFAR.

1. ` `**Usage Fault**

For the reason for Usage Fault, you can query the special register UFSR, as shown in the following figure.

There are many reasons for Usage Fault.

Common reasons:

1. ` `UNDEFINSTR

This error indicates that the instruction found by the CPU is an unrecognized instruction.

1. ` `INVSTATE

This error indicates that the CPU incorrectly modifies EPSR to an illegal value after executing the instruction.

The EPSR contains the Thumb State Bit. The lowest bit of all Thumb instruction addresses should be 1. If the

lowest bit of the instruction address is 0, it is considered by the CPU as not a Thumb instruction, thus

Rev 1.2 Page312 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.371.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

modifying the Thumb State in the EPSR. The Cortex-M series only supports the Thumb instruction set, so

when the Thumb State in EPSR is not 1, the CPU triggers the Usage Fault.

1. ` `INVPC

This error indicates that EXC\_RETURN is an illegal value when returning from interrupt.

1. ` `NOCP

This error indicates that the instruction found by the CPU reference requires a coprocessor, but there is no

coprocessor or the coprocessor is turned off.

1. ` `UNALIGNED

The error indicates that the access is not aligned. For example, to do a 4-byte read and write, the address is

odd. This error is configurable and will not be generated by the CPU when unaligned accesses are supported.

1. ` `DIVBYZERO

This error indicates that a division by 0 error occurred. The error is also configurable.

**Figure 114 UsageFault Status Register**

**Table 121 UFSR Bit Assignments**

**Bits Name Function**

[15:10] - Reserved.

[9] DIVBYZERO Divide by zero UsageFault:

0 = no divide by zero fault, or divide by zero trapping not enabled

1 = the processor has executed an SDIV or UDIV instruction with a divisor of 0.

When the processor sets this bit to 1, the PC value stacked for the exception

return points to the instruction that performed the divide by zero.

Enable trapping of divide by zero by setting the DIV\_0\_TRP bit in the CCR to 1.

[8] UNALIGNED Unaligned access UsageFault:

0 = no unaligned access fault, or unaligned access trapping not enabled

1 = the processor has made an unaligned memory access.

Enable trapping of unaligned accesses by setting the UNALIGN\_TRP bit in the

CCR to 1.

Rev 1.2 Page313 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.372.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

Unaligned LDM, STM, LDRD, and STRD instructions always fault irrespective of

the setting of UNALIGN\_TRP.

[7:4] - Reserved.

[3] NOCP No coprocessor UsageFault. The processor does not support coprocessor

instructions:

0 = no UsageFault caused by attempting to access a coprocessor

1 = the processor has attempted to access a coprocessor.

[2] INVPC Invalid PC load UsageFault, caused by an invalid PC load by EXC\_RETURN:

0 = no invalid PC load UsageFault

1 = the processor has attempted an illegal load of EXC\_RETURN to the PC, as a

result of an invalid context, or an invalid EXC\_RETURN value.

When this bit is set to 1, the PC value stacked for the exception return points to

the instruction that tried to perform the illegal load of the PC.

[1] INVSTATE Invalid state UsageFault:

0 = no invalid state UsageFault

1 = the processor has attempted to execute an instruction that makes illegal use

of the EPSR.

When this bit is set to 1, the PC value stacked for the exception return points to

the instruction that attempted the illegal use of the EPSR.

This bit is not set to 1 if an undefined instruction uses the EPSR.

[0] UNDEFINSTR Undefined instruction UsageFault:

0 = no undefined instruction UsageFault

1 = the processor has attempted to execute an undefined instruction.

When this bit is set to 1, the PC value stacked for the exception return points to

the undefined instruction.

An undefined instruction is an instruction that the processor cannot decode.

1. ` `**Some Examples**

The following examples are given to explain how to analyze exceptions.

1. ` `**Mem Fault-Data Access Violation**

The fault type and the fault reason are parsed and printed out in log. The log directly shows that it is Mem Fault, and

the reason is Data access violation. MMFAR records the last accessed address, which can be seen to be 0x0000.

According to the MPU protection range, the protected address is from 0 to ROM BASE, and this area is executable only.

The triggering crash means that a value was written to the protected area.

The way to determine which instruction accesses this address is to read the lst file, and find the corresponding code by

PC. As the following figure shows, the PC stores the value of R2 in the address of R3. It can be seen that 1 is written to

0x0000. This indicates this type of crash.

Rev 1.2 Page314 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.373.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.040.jpeg)*Software Development User Guide*

1408be5a: 601a str r2, [r3, #0]

**Figure 115 Mem Fault Dump**

**Sample Code 72: Data Access Error**

{"data\_access\_error", data\_access\_error\_test},

1. ` `**Bus Fault-Instruction Bus Error**

As the following figure shows, it’s an instruction bus error, and the value of the PC is 0x4000000, which is no longer a

code segment. Becase the PC is abnormal, the way of finding out the position in code triggered crash is to query the LR

register. The value saved in LR is 0x1408B6F1 which means the address that executes after the jump return. Because of

the Thumb instruction, the lowest bit is set to 1. Remove the lowest bit and get 0x1408B6F0. Therefore, the jump

instruction 0x1408B6F0 is being executed. Query register R3, and you can see that the value is 0x4000000 as PC.

1408be3a: 2300 ldr r3, [sp, #0]

1408be3c: 4798 blx r3

Rev 1.2 Page315 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.374.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 116 Instruction bus error Dump**

**Sample Code 73: Instruction Bus Error**

{"instruction\_bus\_error", instruction\_bus\_error\_test},

1. ` `**Bus Fault-Precise Data Bus Error**

As the following figure shows, the crash is similar to the Mem Manage Fault, and the analysis method is also similar.

The instruction to access the abnormal address can be found out according to the PC register. A number is read from

the address corresponding to the value stored in R3. The value stored in R3 is 0x4000000, which is an illegal address,

this address cannot be found on the bus. So Precise data bus fault is triggered.

1408c65e: 681b ldr r3, [r3, #0]

Rev 1.2 Page316 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.375.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 117 Precise Data Bus Error Dump**

**Sample Code 74: Precise Data Bus Error**

{"data\_bus\_error", data\_bus\_error\_test},

1. ` `**Usage Fault-Invalid State**

The Invalid State that causes a CPU crash is explained as the Bit [24] Thumb State state in the EPSR register is cleared. It

can be seen that the EPSR register becomes 0. Any operation that changes the PC value may change the Thumb State

state, so the crash is not caused by the current instruction. To locate the crash address, you need to query the LR

register. The instruction before jump can be found out from LR, which is BLX R3. Although R3 is a function address, the

lowest bit is 0, which is considered by the CPU as not a Thumb instruction.

1408be22: 4798 blx r3

Rev 1.2 Page317 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.376.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 118 Usage Fault Dump**

**Sample Code 75: Usage Fault**

{"usage\_fault", usage\_fault\_test},

1. ` `**Hard Fault-Usage Fault**

As the following figure shows, the FaultInfo is HardFault, but the fault cause is Invalid state UsageFault. And the

PRIMASK is 1, which means that it is turned off. Therefore, the usage fault interrupt cannot be responded, the

HardFault is triggered by CPU. It is actually a usage fault.

1408c650: 4798 blx r3

**Figure 119 Hard Fault Dump**

**Sample Code 76: Hard Fault**

Rev 1.2 Page318 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.008.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

{"hard\_fault", hard\_fault\_test},

1. ` `**ASSERT Analysis**

Assert is used to catch the scene in some impossible events or results in the software code. Each Assert has a

corresponding Assert string. The location of the crash can be found quikly by searching the Assert string in code. This

positioning is much easier than Exception, but you may not understand why the Assert is here or what causes the

Assert. Several common Assert positioning methods and ideas are summarized as follows.

1. ` `**app\_wt-irq\_\_handle**

The reason for the watchdog crash is that watchdog isn’t fed before timeout. Now we are feeding the dog in the timer

thread, so this crash occurs when the timer thread cannot be scheduled. There are usually two cases:

1. ` `The system MIPS is not enough, and other threads occupy all the CPU, so the timer thread can’t be

scheduled.

1. ` `The Timer thread and other threads are deadlocked, causing the subsequent timer callback to fail to execute.

The first type of crash can be easily identified by looking at the CPU usage. The solution is usually to optimize MIPS or

increase the CPU frequency for certain scenario.

The second type of crash is showed in the following figure. The timer thread state is WAIT\_MUT, which means the timer

thread is stopped by waiting mutex. Looking for other threads, thread 14 named Thread\_test is also waiting mutex.

Then through the C code, it can be viewed that deadlock\_mutex1 is taken first in the timer callback and then waits for

deadlock\_mutex2. Thread\_test takes deadlock\_mutex2 first and then waits for deadlock\_mutex1. In this way, two

threads cannot wait for each other's mutex and does not release their own mutex, so the two threads can never

continue to execute.

So waiting for mutex in the timer thread is usually prohibitted. One reason is that it may cause a deadlock, and the

other reason is that it may take a long time to get the mutex, which will cause other timers to fail to respond on time.

Rev 1.2 Page319 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.377.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 120 Deadlock Causes Watchdog Crash**

static void deadlock\_test\_timer\_cb(void const \*arg)

{

osMutexWait(deadlock\_mutex1\_id, osWaitForever);

osDelay(100);

TRACE(0, "%s try to get deadlock mutex2", \_\_func\_\_);

osMutexWait(deadlock\_mutex2\_id, osWaitForever);

TRACE(0, "%s got deadlock mutex2", \_\_func\_\_);

osMutexRelease(deadlock\_mutex1\_id);

osMutexRelease(deadlock\_mutex2\_id);

}

static void Thread\_test(void const \*argument) {

while (1)

{

osMutexWait(deadlock\_mutex2\_id, osWaitForever);

osThreadYield();

osMutexWait(deadlock\_mutex1\_id, osWaitForever);

osMutexRelease(deadlock\_mutex2\_id);

Rev 1.2 Page320 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.378.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.025.jpeg)*Software Development User Guide*

osMutexRelease(deadlock\_mutex1\_id);

}

}

**Sample Code 77: Deadlock Causes Watchdog Crash**

{"dead\_lock", dead\_lock\_test},

1. ` `**Stact Smashing Detected**

The reason for this crash is that the thread stack is destroyed. As shown in the following assembly code in the Ist file,

GCC take a stack check, a value is loaded from the flash and stored at register SP offset 20 after entering the function

stack\_overflow\_test. When the function is exited, the value of SP offset 20 is taken out and compared with the value in

the flash. If the value is different, it jumps to \_\_stack\_chk\_fail.

Therefore, it’s necessary to find the previous function that jumps into \_\_stack\_chk\_fail from the stack space when

encountering such a crash, then check whether there is a possibility of buffer overflow in this function.

1408c6b8 <\_ZL19stack\_overflow\_testv>:

\_ZL19stack\_overflow\_testv():

/home/project/mcu-

sw/out/best1600\_ibrt/../../services/../bthost/service/ble\_audio/ble\_audio\_t

est/ble\_audio\_test.cpp:2515

{

1408c6b8: b500 push {lr}

1408c6ba: 4b11 ldr r3, [pc, #68] ; (1408c700

<\_ZL19stack\_overflow\_testv+0x48>)

1408c6bc: b087 sub sp, #28

1408c6be: 681b ldr r3, [r3, #0]

1408c6c0: 9305 str r3, [sp, #20]

1408c6c2: f04f 0300 mov.w r3, #0

/home/project/mcu-

sw/out/best1600\_ibrt/../../services/../bthost/service/ble\_audio/ble\_audio\_t

est/ble\_audio\_test.cpp:2517

uint8\_t test\_cnt = GET\_CURRENT\_MS();

1408c6c6: f0bf fafb bl 1414bcc0 <\_\_hal\_sys\_timer\_get\_veneer>

1408c6ca: 4602 mov r2, r0

/home/project/mcu-

sw/out/best1600\_ibrt/../../services/../bthost/service/ble\_audio/ble\_audio\_t

est/ble\_audio\_test.cpp:2518

memset(test\_buf, 0xbb, test\_cnt);

1408c6cc: 21bb movs r1, #187 ; 0xbb

Rev 1.2 Page321 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.379.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1408c6ce: f3c2 1207 ubfx r2, r2, #4, #8

1408c6d2: a802 add r0, sp, #8

1408c6d4: 9201 str r2, [sp, #4]

1408c6d6: f0bf fb33 bl 1414bd40 <\_\_memset\_veneer>

/home/project/mcu-

sw/out/best1600\_ibrt/../../services/../bthost/service/ble\_audio/ble\_audio\_t

est/ble\_audio\_test.cpp:2519

DUMP8("%02x ", test\_buf, test\_cnt);

1408c6da: 9a01 ldr r2, [sp, #4]

1408c6dc: ab02 add r3, sp, #8

1408c6de: 2101 movs r1, #1

1408c6e0: 4808 ldr r0, [pc, #32] ; (1408c704

<\_ZL19stack\_overflow\_testv+0x4c>)

1408c6e2: f79a fe4d bl 14027380 <hal\_trace\_dump>

/home/project/mcu-

sw/out/best1600\_ibrt/../../services/../bthost/service/ble\_audio/ble\_audio\_t

est/ble\_audio\_test.cpp:2520

}

1408c6e6: 4b06 ldr r3, [pc, #24] ; (1408c700

<\_ZL19stack\_overflow\_testv+0x48>)

1408c6e8: 681a ldr r2, [r3, #0]

1408c6ea: 9b05 ldr r3, [sp, #20]

1408c6ec: 405a eors r2, r3

1408c6ee: f04f 0300 mov.w r3, #0

1408c6f2: d102 bne.n 1408c6fa <\_ZL19stack\_overflow\_testv+0x42>

1408c6f4: b007 add sp, #28

1408c6f6: f85d fb04 ldr.w pc, [sp], #4

1408c6fa: f7b2 ffc5 bl 1403f688 <\_\_stack\_chk\_fail>

1408c6fe: bf00 nop

1408c700: 20502d90 .word 0x20502d90

1408c704: 3414eb20 .word 0x3414eb20

Rev 1.2 Page322 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.380.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 121 Stack Smashing**

**Sample Code 78: stack\_overflow**

{" stack\_overflow", stack\_overflow\_test},

1. ` `**Generic Crash Analysis**

There is a general crash analysis method, namely, using the software gcc-arm-none-eabi to find the crash location of

code.

1. ` `Download and install gcc-arm-none-eabi. Add the installation path to the environment variable if the

installation OS is Windows.

Rev 1.2 Page323 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.381.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 122 Install gcc-arm-none-eabi**

1. ` `Turn to the compiled elf file path, open the command shell, and enter the command arm-none-eabi-

addr2line -e xxx.elf xxxxx as follows:

**Figure 123 Get Crash Location**

As the figure shows, the location before the crash in the code is /bthost/service/ble\_audio\_test.cpp line 257

1. ` `Turn to the code location to find the bug.
1. ` `**Full CPU Workload Power Consumption Measurement**

Before measuring the full CPU workload power consumption, the two macro switches need to be configured in the

target.mk:

SPECIFIC\_FREQ\_POWER\_CONSUMPTION\_MEASUREMENT\_ENABLE ?= 1

WATCHER\_DOG ?= 0

The CPU frequency needs to be configured by APP\_SYSFREQ\_USER before measurement.

Rev 1.2 Page324 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.382.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.037.jpeg)*Software Development User Guide*

Multiple users can set CPU frequencies at the same time, but only one takes effect. Basecally, the highest requested

frequency will be the configured value if several users ask for different frequencies. If a user doesn’t need to frequency

anymore, it will release the frequency and the existing frequency request list will be went through again to choose the

highest one.

enum APP\_SYSFREQ\_USER\_T {

APP\_SYSFREQ\_USER\_APP\_INIT = HAL\_SYSFREQ\_USER\_INIT,

APP\_SYSFREQ\_USER\_APP\_0 = HAL\_SYSFREQ\_USER\_APP\_0,

APP\_SYSFREQ\_USER\_APP\_1 = HAL\_SYSFREQ\_USER\_APP\_1,

APP\_SYSFREQ\_USER\_APP\_2 = HAL\_SYSFREQ\_USER\_APP\_2,

APP\_SYSFREQ\_USER\_APP\_3 = HAL\_SYSFREQ\_USER\_APP\_3,

APP\_SYSFREQ\_USER\_APP\_4 = HAL\_SYSFREQ\_USER\_APP\_4,

APP\_SYSFREQ\_USER\_APP\_5 = HAL\_SYSFREQ\_USER\_APP\_5,

APP\_SYSFREQ\_USER\_APP\_6 = HAL\_SYSFREQ\_USER\_APP\_6,

APP\_SYSFREQ\_USER\_APP\_7 = HAL\_SYSFREQ\_USER\_APP\_7,

APP\_SYSFREQ\_USER\_APP\_8 = HAL\_SYSFREQ\_USER\_APP\_8,

APP\_SYSFREQ\_USER\_APP\_9 = HAL\_SYSFREQ\_USER\_APP\_9,

APP\_SYSFREQ\_USER\_APP\_10 = HAL\_SYSFREQ\_USER\_APP\_10,

APP\_SYSFREQ\_USER\_APP\_11 = HAL\_SYSFREQ\_USER\_APP\_11,

APP\_SYSFREQ\_USER\_APP\_12 = HAL\_SYSFREQ\_USER\_APP\_12,

APP\_SYSFREQ\_USER\_APP\_13 = HAL\_SYSFREQ\_USER\_APP\_13,

APP\_SYSFREQ\_USER\_APP\_14 = HAL\_SYSFREQ\_USER\_APP\_14,

APP\_SYSFREQ\_USER\_APP\_15 = HAL\_SYSFREQ\_USER\_APP\_15,

APP\_SYSFREQ\_USER\_APP\_16 = HAL\_SYSFREQ\_USER\_APP\_16,

APP\_SYSFREQ\_USER\_APP\_17 = HAL\_SYSFREQ\_USER\_APP\_17,

APP\_SYSFREQ\_USER\_APP\_18 = HAL\_SYSFREQ\_USER\_APP\_18,

APP\_SYSFREQ\_USER\_APP\_19 = HAL\_SYSFREQ\_USER\_APP\_19,

APP\_SYSFREQ\_USER\_QTY

};

By default, each user is assigned with APP\_SYSFREQ\_32K and the system frequency is 32KHz, which means that system

can enter deep sleep mode. If any user requests a frequency higher than 32KHz, the system won’t be allowed to enter

deep sleep mode.

The frequency is configured as 26MHz here.

enum APP\_SYSFREQ\_FREQ\_T {

APP\_SYSFREQ\_32K = HAL\_CMU\_FREQ\_32K,

APP\_SYSFREQ\_26M = HAL\_CMU\_FREQ\_26M,

APP\_SYSFREQ\_52M = HAL\_CMU\_FREQ\_52M,

APP\_SYSFREQ\_78M = HAL\_CMU\_FREQ\_78M,

Rev 1.2 Page325 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.383.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

APP\_SYSFREQ\_104M = HAL\_CMU\_FREQ\_104M,

#ifdef HAL\_CMU\_FREQ\_15M

APP\_SYSFREQ\_12M = HAL\_CMU\_FREQ\_12M,

APP\_SYSFREQ\_15M = HAL\_CMU\_FREQ\_15M,

APP\_SYSFREQ\_30M = HAL\_CMU\_FREQ\_30M,

APP\_SYSFREQ\_48M = HAL\_CMU\_FREQ\_48M,

APP\_SYSFREQ\_120M = HAL\_CMU\_FREQ\_120M,

APP\_SYSFREQ\_144M = HAL\_CMU\_FREQ\_144M,

APP\_SYSFREQ\_168M = HAL\_CMU\_FREQ\_168M,

#endif

APP\_SYSFREQ\_208M = HAL\_CMU\_FREQ\_208M,

APP\_SYSFREQ\_FREQ\_QTY = HAL\_CMU\_FREQ\_QTY

};

#define POWER\_CONSUMPTION\_MEASUREMENT\_FREQ APP\_SYSFREQ\_26M

A thread named power\_consumption\_thread is created when the system is initiated. This thread firstly releases all the

allocated frequencies, makes the coprocessor work at full load if there is a coprocessor in the CPU, sets the frequency,

and finally executes the while loop to make the CPU work at full load.

static void power\_consumption\_thread(const void \*arg)

{

// release all the allocated frequencies

for (uint32\_t user = APP\_SYSFREQ\_USER\_APP\_INIT;

user < APP\_SYSFREQ\_USER\_QTY; user++)

{

app\_sysfreq\_req((enum APP\_SYSFREQ\_USER\_T)user, APP\_SYSFREQ\_32K);

}

// Let coprocessor work at full load

#if defined(CP\_IN\_SAME\_EE)&&defined(IS\_TEST\_MCU\_AND\_CP)

power\_consumption\_measurement\_start\_cp();

#endif

app\_sysfreq\_req(APP\_SYSFREQ\_USER\_APP\_15,

(enum APP\_SYSFREQ\_FREQ\_T)POWER\_CONSUMPTION\_MEASUREMENT\_FREQ);

while(1);

}

Rev 1.2 Page326 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.384.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

If all thread information is printed out (see details in 7.4 Thread information periodic print), the log shows that the

thread power\_consumption\_thread has made the CPU work at full load.

At this time, the full CPU workload power consumption can be measured by the electric current.

**Figure 124 power\_consumption\_thread Infomation**

1. ` `**Thread Information Periodic Print**

In order to periodically print thread information, enable the macro switch OS\_THREAD\_TIMING\_STATISTICS\_ENABLE in

target.mk:

OS\_THREAD\_TIMING\_STATISTICS\_ENABLE ?= 1

The system creates a timer thread to print all the thread information periodically as follows:

static void cpu\_usage\_timer\_handler(void const \*param)

{

rtx\_show\_all\_threads\_usage();

}

void rtx\_show\_all\_threads\_usage(void)

{

const os\_thread\_t \*thread;

static bool first\_time = 1;

uint32\_t sample\_time;

static uint32\_t start\_sample\_time = 0;

if (first\_time) {

start\_sample\_time = rtx\_get\_hwticks();

first\_time = 0;

return;

}

sample\_time = HWTICKS\_TO\_MS(rtx\_get\_hwticks() - start\_sample\_time);

Rev 1.2 Page327 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.385.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

REL\_TRACE\_IMM\_NOTS(0," ");

REL\_TRACE\_NOTS(0,"Thread List:");

// Current List

\_rtx\_show\_thread\_usage(osRtxInfo.thread.run.curr, sample\_time);

// Next List

if (osRtxInfo.thread.run.next != osRtxInfo.thread.run.curr)

\_rtx\_show\_thread\_usage(osRtxInfo.thread.run.next, sample\_time);

// Ready List

for (thread = osRtxInfo.thread.ready.thread\_list;

thread != NULL; thread = thread->thread\_next) {

\_rtx\_show\_thread\_usage(thread, sample\_time);

}

// Delay List

for (thread = osRtxInfo.thread.delay\_list;

thread != NULL; thread = thread->delay\_next) {

\_rtx\_show\_thread\_usage(thread, sample\_time);

}

// Wait List

for (thread = osRtxInfo.thread.wait\_list;

thread != NULL; thread = thread->delay\_next) {

\_rtx\_show\_thread\_usage(thread, sample\_time);

}

// Terminate List

for (thread = osRtxInfo.thread.terminate\_list;

thread != NULL; thread = thread->thread\_next) {

\_rtx\_show\_thread\_usage(thread, sample\_time);

}

start\_sample\_time = rtx\_get\_hwticks();

REL\_TRACE\_IMM\_NOTS(0," ");

}

The timer thread prints out all information of the threads in Current List, Next List, Ready List, Delay List, Wait List and

Terminate List thread through the function rtx\_show\_thread\_usage.

Rev 1.2 Page328 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.386.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

The thread information consists of the thread name, CPU load and minimum free stack size as the follows:

**Figure 125 Thread Information**

Rev 1.2 Page329 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.387.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `**Audio Dump Tool Usage**

GUI Interface

**Figure 126 Audio Developer GUI**

1. ` `**Preparation**

Enable the realtive “DUMP” macro in the BES code

1. ` `Download PCM data from the main kernel (monolithic kernel or multiple kernels):

Build binary with AUDIO\_DEBUG=1 in the M33 command line.

1. ` `Download PCM data from other kernels (multiple kernels):

Build binary with AUDIO\_DEBUG=1 DSP\_M55\_TRC\_TO\_MCU=0 DEBUG\_PORT=1 in M55 compile command,

DSP\_M55\_TRC\_TO\_MCU=0 DEBUG\_PORT=2 in the M33 command line.

DSP\_M55\_TRC\_TO\_MCU is used for stop transmission between M33 and M55.

DEBUG\_PORT is used for seperate M55 TRACE print from M33. Please ask for help from the hardware

engineer to verify the UART connection method according to the black board version:

Rev 1.2 Page330 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.388.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

NOTE: TRACE affects PCM data dump. If you print many TRACE in an instant, CHIP may not output PCM data, which will

cause data lost in the PC. In this case, you can decrease the priority of log print(main.cpp): hal\_trace\_set\_log\_level().

1. ` `**COM**
1. ` `Run Audio Developer v0.5.3\dist\main.exe.
1. ` `Unfold COM, and set the corresponding Port and Baud Rate. Normally, set the baudrate to 2000000.

Check the platform\hal\hal\_trace.c file for details if necessary. The BES chip can support up to 3M baudrate.

Note: Make sure that your USB2UART tool can support bigger baudrate than your setting in the BES code.

**Figure 127 COM**

To check the port, right click My Computer/This PC on the desktop, select Manage. The following window

appears:

**Figure 128 Computer Management**

Click **Device Manager**, and unfold Ports (COM & LPT) in the right box. The current used port is displayed.

Note: For multiple kernels, there exists more than one COM list. Please choose the correct COM based on logs

or GPIO list.

Rev 1.2 Page331 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.389.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 129 COM3 Port**

After the settings is completed, click Close to change the status to Open (the port is opened now), and we can

start tuning. Likewise, click Open will change the status back to Close (the port is closed now) and tuning is

stopped.

1. ` `**Trace Manager**

Save Data

1. ` `Modify BES SDK to use the data\_dump\_run function to output data through UART.

data\_dump\_run("[mic1\_data]", mic1\_buf, mic1\_buf\_len);

1. ` `Unfold **TRACE Manager**, and choose **Save Data** > **Add New**.

Rev 1.2 Page332 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.390.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

**Figure 130 Save Data**

1. ` `Set the Head and File path, then click Enable to start saving data. If you want to finish saving data, click Enable

again to save data into the file.

**Figure 131 Trace Manager**

\- We recommend the Head string include [] and the string length > 6.

\- File path can include the folder path and you can find saved file under out\Save\_Data\ folder.

\- If you disable DUMP\_PLC\_ENABLE in firmware, PLC should be DEFAULT. If you enable

DUMP\_PLC\_ENABLE, PLC should be MAX, ZERO or LOST.

Rev 1.2 Page333 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.391.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.392.jpeg)*Software Development User Guide*

**Figure 132 DUMP\_PLC\_ENABLE**

\- You can click Add New to add more channels.

1. ` `Make sure that the Com baud Rate is enough to dump data.
1. ` `**Recording**
1. ` `Unfold Record, set the Wav File path, and click Enable to start recording. If you want to finish recording, click

Enable again to save data into the file.

**Figure 133 Record**

\- Wav File path can include the folder path and you can find save file under out\Record\ folder.

\- If you disable DUMP\_PLC\_ENABLE in firmware, PLC should be DEFAULT. If you enable

DUMP\_PLC\_ENABLE, PLC should be MAX, ZERO or LOST

**Figure 134 DUMP\_PLC\_ENABLE**

Rev 1.2 Page334 / 335 BES Confidential and Proprietary





![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.393.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.006.jpeg)![](BES\_TWS\_Software\_Development\_User\_Manual\_v1.2.007.jpeg)*Software Development User Guide*

1. ` `Make sure that the Com baud Rate is enough to Record data.
1. ` `If you want to dump PCM data during phone call, you can enable BT\_SCO\_CHAIN\_AUDIO\_DUMP. PCM data is

16k sample rate, 16 bits and 2 channels by default.

**Figure 135 BT\_SCO\_CHAIN\_AUDIO\_DUMP**

1. ` `If you want to dump data in your stream, refer to BT\_SCO\_CHAIN\_AUDIO\_DUMP.

Rev 1.2 Page335 / 335 BES Confidential and Proprietary
